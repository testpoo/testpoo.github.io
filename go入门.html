<!doctype html>
  <html lang="en">

  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <title>测试铺</title>
    <link rel="stylesheet" type="text/css" href="https://testpoo.github.io/themes/css/style.css">
    <link rel="stylesheet" type="text/css" href="https://testpoo.github.io/themes/css/xui.css">
    <link rel="stylesheet" type="text/css" href="https://testpoo.github.io/themes/css/markdown.css">
    <link rel="shortcut icon" type="image/ico" href="https://testpoo.github.io/themes/img/favicon.ico">
  </head>

  

  <body>
    <div class="sider">
      <div class="categories">
        <div class="title">
          <a href="https://testpoo.github.io">
            <img src="https://testpoo.github.io/themes/img/title.jpg">
            <div class="linkbutton testpoo">测试铺</div>
          </a>
        </div>
        <div class="scrollheight">
          <ul>
            
            <li><a href="https://testpoo.github.io/关于我.html"><label style="color: #38b6fd"></label>&nbsp;关于我</a></li>
            
            <li><a href="https://testpoo.github.io/常用链接.html"><label style="color: #38b6fd"></label>&nbsp;常用链接</a></li>
            
            <li><a href="https://testpoo.github.io/问题解决.html"><label style="color: #38b6fd"></label>&nbsp;问题解决</a></li>
            
            <li><a href="https://testpoo.github.io/debian安装设置.html"><label style="color: #ffba48"></label>&nbsp;系统安装</a></li>
            
            <li><a href="https://testpoo.github.io/javascript代码小抄.html"><label style="color: #ffba48"></label>&nbsp;代码小抄</a></li>
            
            <li><a href="https://testpoo.github.io/只有一个读音的九篇古文.html"><label style="color: #ffba48"></label>&nbsp;其他</a></li>
            
            <li><a href="https://testpoo.github.io/Jinja2简介.html"><label style="color: #ffba48"></label>&nbsp;测试</a></li>
            
            <li><a href="https://testpoo.github.io/shell三剑客简介.html"><label style="color: #ffba48"></label>&nbsp;技术</a></li>
            
          </ul>
        </div>
        <div class="github"><a href="https://github.com/testpoo" target="_blank" title="GitHub:https://github.com/testpoo"></a><a href="#" title="微信号：puyaweis"></a><a href="#" title="邮箱：pu_yawei@qq.com"></a><a href="https://testpoo.github.io/rss.xml" target="_blank"></a></div>
      </div>
      <div class="articles">
        <div class="category">分类：技术</div>
        <div class="scrollheight">
          <ul>
            
            <li><a href="https://testpoo.github.io/shell三剑客简介.html"><span><label style="color: #38b6fd"></label>&nbsp;shell三剑客简介</span><span>2024-02-29&nbsp;&nbsp;共18477个字</span><span class="tag">linux</span><span class="tag">awk</span><span class="tag">grep</span><span class="tag">sed</span></a></li>
            
            <li><a href="https://testpoo.github.io/FastApi简析.html"><span><label style="color: #38b6fd"></label>&nbsp;FastApi简析</span><span>2023-12-06&nbsp;&nbsp;共16006个字</span><span class="tag">fastapi</span><span class="tag">python</span></a></li>
            
            <li><a href="https://testpoo.github.io/go入门.html"><span><label style="color: #38b6fd"></label>&nbsp;go入门</span><span>2023-08-15&nbsp;&nbsp;共23389个字</span><span class="tag">go</span></a></li>
            
            <li><a href="https://testpoo.github.io/tkinter教程.html"><span><label style="color: #38b6fd"></label>&nbsp;tkinter教程</span><span>2022-11-14&nbsp;&nbsp;共93974个字</span><span class="tag">python</span><span class="tag">tkinter</span></a></li>
            
            <li><a href="https://testpoo.github.io/mysql函数汇总.html"><span><label style="color: #38b6fd"></label>&nbsp;mysql函数汇总</span><span>2022-04-18&nbsp;&nbsp;共48992个字</span><span class="tag">mysql</span></a></li>
            
            <li><a href="https://testpoo.github.io/shell简介.html"><span><label style="color: #38b6fd"></label>&nbsp;shell简介</span><span>2022-04-18&nbsp;&nbsp;共14941个字</span><span class="tag">linux</span><span class="tag">shell</span></a></li>
            
            <li><a href="https://testpoo.github.io/Docker入门教程.html"><span><label style="color: #38b6fd"></label>&nbsp;Docker入门教程</span><span>2022-03-02&nbsp;&nbsp;共16064个字</span><span class="tag">docker</span></a></li>
            
            <li><a href="https://testpoo.github.io/Python进阶.html"><span><label style="color: #38b6fd"></label>&nbsp;Python进阶</span><span>2021-11-30&nbsp;&nbsp;共39681个字</span><span class="tag">python</span></a></li>
            
            <li><a href="https://testpoo.github.io/Git简介.html"><span><label style="color: #38b6fd"></label>&nbsp;Git简介</span><span>2021-09-15&nbsp;&nbsp;共29722个字</span><span class="tag">git</span></a></li>
            
            <li><a href="https://testpoo.github.io/Python正则表达式.html"><span><label style="color: #38b6fd"></label>&nbsp;Python正则表达式</span><span>2021-06-23&nbsp;&nbsp;共21614个字</span><span class="tag">python</span><span class="tag">正则表达式</span></a></li>
            
            <li><a href="https://testpoo.github.io/mysql的安装.html"><span><label style="color: #38b6fd"></label>&nbsp;mysql的安装</span><span>2020.05.09&nbsp;&nbsp;共8129个字</span><span class="tag">mysql</span><span class="tag">安装</span></a></li>
            
            <li><a href="https://testpoo.github.io/分分种学会python3.html"><span><label style="color: #38b6fd"></label>&nbsp;分分种学会python3</span><span>2020-05-14&nbsp;&nbsp;共10704个字</span><span class="tag">python</span></a></li>
            
            <li><a href="https://testpoo.github.io/Markdown笔记.html"><span><label style="color: #38b6fd"></label>&nbsp;Markdown笔记</span><span>2020-04-03&nbsp;&nbsp;共9889个字</span><span class="tag">markdown</span></a></li>
            
            <li><a href="https://testpoo.github.io/Linux下SVN服务器的搭建.html"><span><label style="color: #38b6fd"></label>&nbsp;Linux下SVN服务器的搭建</span><span>2020-01-01&nbsp;&nbsp;共13069个字</span><span class="tag">svn</span><span class="tag">linux</span></a></li>
            
            <li><a href="https://testpoo.github.io/mysql笔记.html"><span><label style="color: #38b6fd"></label>&nbsp;mysql笔记</span><span>2019-10-11&nbsp;&nbsp;共4893个字</span><span class="tag">mysql</span></a></li>
            
            <li><a href="https://testpoo.github.io/python标准异常.html"><span><label style="color: #38b6fd"></label>&nbsp;python标准异常</span><span>2019-10-11&nbsp;&nbsp;共2684个字</span><span class="tag">python</span><span class="tag">标准异常</span></a></li>
            
            <li><a href="https://testpoo.github.io/svn命令全解.html"><span><label style="color: #38b6fd"></label>&nbsp;svn命令全解</span><span>2019-10-11&nbsp;&nbsp;共3837个字</span><span class="tag">svn</span></a></li>
            
            <li><a href="https://testpoo.github.io/debian命令apt和dpkg用法.html"><span><label style="color: #38b6fd"></label>&nbsp;debian命令apt和dpkg用法</span><span>2019-07-05&nbsp;&nbsp;共6342个字</span><span class="tag">debian</span><span class="tag">apt</span><span class="tag">dpkg</span></a></li>
            
          </ul>
        </div>
        <div class="item-num">总共18项</div>
      </div>
    </div>
    <div class="main">
      <div class="header"><span>go入门</span><span>一个85后测试老人<br />最后更新于2024-08-13 14:23:34</span></div>
      <input class="xswitch xonoff" type="checkbox" id="catalog">
      <div class="posts">
        <div class="toc">
<ul>
<li><a href="#1">1. 简介</a></li>
<li><a href="#2">2. 开始</a></li>
<li><a href="#3">3. 工作区</a></li>
<li><a href="#4">4. 变量</a></li>
<li><a href="#5">5. 数据类型</a><ul>
<li><a href="#51">5.1 数字，字符串 和 布尔型</a></li>
<li><a href="#52-arrays-slice-maps">5.2 数组(Arrays), 切片(Slice) 和 映射(Maps)</a></li>
</ul>
</li>
<li><a href="#6">6. 类型转换</a></li>
<li><a href="#7">7. 条件语句</a><ul>
<li><a href="#71-if-else">7.1 if else</a></li>
<li><a href="#72-switch-case">7.2 switch case</a></li>
<li><a href="#73">7.3 循环</a></li>
</ul>
</li>
<li><a href="#8">8. 指针</a></li>
<li><a href="#9">9. 函数</a></li>
<li><a href="#10">10. 方法、结构体和接口</a><ul>
<li><a href="#101-struct">10.1 结构体(Struct)</a></li>
<li><a href="#102-methods">10.2 方法(Methods)</a></li>
<li><a href="#103">10.3 接口</a></li>
</ul>
</li>
<li><a href="#11">11. 包</a><ul>
<li><a href="#111-go">11.1 安装一个包go</a></li>
<li><a href="#112">11.2 自定义包</a></li>
<li><a href="#113">11.3 包的文档</a></li>
</ul>
</li>
<li><a href="#12-go">12. Go中的一些内置包</a><ul>
<li><a href="#121-fmt">12.1 fmt</a></li>
<li><a href="#122-json">12.2 json</a></li>
</ul>
</li>
<li><a href="#13">13. 错误处理</a><ul>
<li><a href="#131">13.1 返回自定义错误</a></li>
<li><a href="#132-panic">13.2 Panic</a></li>
<li><a href="#133-defer">13.3 Defer</a></li>
</ul>
</li>
<li><a href="#14">14. 并发</a><ul>
<li><a href="#141-go-routine">14.1 Go routine</a></li>
<li><a href="#142-channels">14.2 Channels</a></li>
<li><a href="#143-channel">14.3 单向channel</a></li>
<li><a href="#144-selectgo-routinechannel">14.4 使用select语句在Go routine中处理多个channel</a></li>
<li><a href="#145-buffered-channel">14.5 Buffered channel</a></li>
</ul>
</li>
<li><a href="#15-golang">15. 为什么 Golang 能够成功呢？</a></li>
</ul>
</div>
<h3 id="1">1. 简介</h3>
<p>Go由Google工程师Robert Griesemer，Rob Pike和Ken Thompson设计。它是一种静态类型的编译语言。 2012 年 3 月发布了第一个开源版本。</p>
<blockquote>
<p>Go 是一种开源编程语言，可以轻松构建简单、可靠和高效的软件”。— GoLang</p>
</blockquote>
<p>在很多计算机语言中，有很多方式可以去解决一个给定的问题。</p>
<p>程序员花费大量的时间去思考最好的方式去解决它。</p>
<p>而Go功能简洁，只有一种正确的方式去解决问题。</p>
<p>这样可以节约程序员的时间，并且使大型代码库易于维护。</p>
<p>Go里面没有像映射(maps)和过滤器(filters)这样富有表现力的特征。</p>
<blockquote>
<p>“当你有增加表现力的功能时，它通常会增加成本”——罗伯·派克</p>
</blockquote>
<h3 id="2">2. 开始</h3>
<blockquote>
<p>本文以windows为例，所以只安装windows下的 <code>go</code>，下载地址为：<code>https://golang.google.cn/dl/go1.21.0.windows-amd64.msi</code></p>
</blockquote>
<p>Go 是由包组成的。 main 包告诉 Go 编译器，程序被编译为可执行文件，而不是共享库。它是应用程序的入口点。主包定义为：</p>
<pre class="codehilite"><code class="language-go">package main
</code></pre>

<p>我们先写一个简单的 <code>hello world</code> 示例，方法就是在 Go GOPATH中创建 <code>main.go</code> 文件。</p>
<h3 id="3">3. 工作区</h3>
<p>Go的工作区是由环境变量<code>GOPATH</code>决定的。  </p>
<p>你可以在工作区里写任意代码，Go会在<code>GOPATH</code>或者<code>GOROOT</code>目录下搜索包，这是在安装Go时默认设置的。<code>GOROOT</code>是Go的安装路径。</p>
<p>设置<code>GOPATH</code>为你想要的目录。现在，咱们设置它的目录为 <code>~/workspace</code>：</p>
<pre class="codehilite"><code class="language-shell"># 环境变量
export GOPATH=~/workspace
# 进入工作区目录
cd ~/workspace
</code></pre>

<p>以上是在linux下设置的，但本次分享是在Windows下进行的，所以我们设置Windows下的环境变量，设置的目录为 <code>D:\learn\gocode</code></p>
<pre class="codehilite"><code class="language-shell"># 设置环境变量
go env GOPATH=D:\learn\gocode
# 恢复默认
go env -u GOPATH
</code></pre>

<p>在工作区目录里创建<code>mian.go</code>文件。</p>
<pre class="codehilite"><code class="language-go">package main

import (
 &quot;fmt&quot;
)

func main(){
  fmt.Println(&quot;Hello World!&quot;)
}
</code></pre>

<p>在上面的例子中，<code>fmt</code> 是Go中的内置包，主要用来格式化输入/输出。</p>
<p>在 Go 中我们使用 <code>import</code> 来导入一个包文件，<code>func main</code>是执行代码的入口，<code>Println</code> 是包fmt中的一个函数，它为我们打印 <code>“hello world”</code>。</p>
<p>让我们运行这个文件来看看。Go有两种运行方式。正如我们所知，Go 是一种编译语言，所以我们首先要在执行之前编译它。</p>
<pre class="codehilite"><code class="language-shell">go build main.go
</code></pre>

<p>这个命令会生成二进制可执行文件 main，然后我们再运行它。</p>
<pre class="codehilite"><code class="language-shell">main.exe
#Hello World!
</code></pre>

<p>还有另外一个简单的方法运行程序。<code>go run</code>可以抽象编译步骤，你可以简单的使用下面的命令执行程序。</p>
<pre class="codehilite"><code class="language-shell">go run main.go
# Hello World!
</code></pre>

<h3 id="4">4. 变量</h3>
<p>Go中的变量是显式声明的。Go 是一种静态类型语言。这意味着在变量在声明时会检查变量的类型。变量可以像下面这样声明：</p>
<pre class="codehilite"><code class="language-go">var a int
</code></pre>

<p>在本例中，该值默认设置为0。也可以直接指定变量的值，如下：</p>
<pre class="codehilite"><code class="language-go">var a = 1
</code></pre>

<p>在这里，变量被自动赋值为 <code>int</code> 型。我们也可以对变量进行一个简短的声明，如下:</p>
<pre class="codehilite"><code class="language-go">message := &quot;hello world&quot;
</code></pre>

<p>我们也可以在一行声明多个变量，如下：</p>
<pre class="codehilite"><code class="language-go">var b, c int = 2, 3
</code></pre>

<h3 id="5">5. 数据类型</h3>
<p>像其他一些计算机语言，Go 也支持各种不同的变量类型，如下：</p>
<h4 id="51">5.1 数字，字符串 和 布尔型</h4>
<p>Go 支持的数字存储类型有很多，比如 <code>int</code>, <code>int8</code>, <code>int16</code>, <code>int32</code>, <code>int64</code>,<code>uint</code>, <code>uint8</code>, <code>uint16</code>, <code>uint32</code>, <code>uint64</code>, <code>uintptr</code> 等等。</p>
<p>字符串类型存储一个字节序列。使用关键字<code>string</code>来表示和声明。</p>
<p>布尔型使用<code>bool</code>声明。</p>
<p>Go 还支持复数类型的数据类型，可以使用<code>complex64</code>和<code>complex128</code>进行声明。</p>
<pre class="codehilite"><code class="language-go">var a bool = true
var b int = 1
var c string =&quot;hello world&quot;
var d float32 = 1.222
var x complex128 = cmplx.Sqrt(-5+12i)
</code></pre>

<h4 id="52-arrays-slice-maps">5.2 数组(Arrays), 切片(Slice) 和 映射(Maps)</h4>
<p>数组是具有相同数据类型的元素的序列。数组在声明时定义了固定长度，因此不能随意扩展超。如下：</p>
<pre class="codehilite"><code class="language-go">var s [5]int
</code></pre>

<p>数组也可以是多维的，声明方式如下：</p>
<pre class="codehilite"><code class="language-go">var multiD [2][3]int
</code></pre>

<p>Go 中的数组有一定限制，比如不能修改数组长度、不能添加元素、不能获取子数组。这时候，更适合使用切片(slices)这一类型。</p>
<p>切片(slices)用于存储一组元素，允许随时扩展其长度。切片(slices)的声明类似数组，只是去掉了长度声明。</p>
<pre class="codehilite"><code class="language-go">var b []int
</code></pre>

<p>这行代码会创建一个 0容量、0长度的切片。也可以使用以下代码设置切片的容量和长度。</p>
<pre class="codehilite"><code class="language-go">numbers := make([]int,5,10)
</code></pre>

<p>这里，切片的初始长度是5，容量是10。</p>
<p>切片是数组的抽象。切片使用数组作为底层结构。切片包含三个组成部分:容量、长度和指向底层数组的指针。</p>
<p>切片的容量可以通过<code>append</code>或<code>copy</code>函数来增加。<code>append</code> 函数将值添加到数组的末尾，并在需要时增加容量。</p>
<pre class="codehilite"><code class="language-go">numbers = append(numbers, 1, 2, 3, 4)
</code></pre>

<p>另一个增加切片容量的方法是<code>copy</code>函数。只需创建另一个容量更大的片，并将原始片复制到新创建的片：</p>
<pre class="codehilite"><code class="language-go">// 创建一个新的大容量的切片
number2 := make([]int, 15)
// 把原来的切片复制到新切片
copy(number2, numbers)
</code></pre>

<p>我们可以创建一个切片的子切片吗？这个可以用如下简单的代码来完成：</p>
<pre class="codehilite"><code class="language-go">// 初始化一个长度为4并有值的切片
number2 = []int{1,2,3,4}
fmt.Println(number2) // -&gt; [1 2 3 4]
// 创建一个子切片
slice1 := number2[2:]
fmt.Println(slice1) // -&gt; [3 4]
slice2 := number2[:3]
fmt.Println(slice2) // -&gt; [1 2 3]
slice3 := number2[1:4]
fmt.Println(slice3) // -&gt; [2 3 4]
</code></pre>

<p>Maps也是Go的一个数据类型，用于记录键值间的映射关系。我们可以用下面的命令定义一个 <code>map</code> :</p>
<pre class="codehilite"><code class="language-go">var m map[string]int
</code></pre>

<p>这里 <code>m</code>是一个新的 <code>map</code>变量，它有字符型的主键和整型的值，我们可以很容易的给 <code>map</code> 加主键和值：</p>
<h3 id="6">6. 类型转换</h3>
<p>可以使用类型转换将一种数据类型转换为另一种数据类型。我们来看一个简单的类型转换:</p>
<pre class="codehilite"><code class="language-go">a := 1.1
b := int(a)
fmt.Println(b)
//-&gt; 1
</code></pre>

<p>并非所有的数据类型都能转换成其他类型。确保数据类型与转换类型相互兼容。</p>
<h3 id="7">7. 条件语句</h3>
<h4 id="71-if-else">7.1 if else</h4>
<p>对于条件语句，我们可以使用if-else语句，如下例所示。确保花括号与条件在同一行。</p>
<pre class="codehilite"><code class="language-go">if num := 9; num &lt; 0 {
 fmt.Println(num, &quot;is negative&quot;)
} else if num &lt; 10 {
 fmt.Println(num, &quot;has 1 digit&quot;)
} else {
 fmt.Println(num, &quot;has multiple digits&quot;)
}
</code></pre>

<h4 id="72-switch-case">7.2 switch case</h4>
<p>switch-case用于组织多个条件语句，下面的例子展示了一个简单的switch case语句:</p>
<pre class="codehilite"><code class="language-go">i := 2
switch i {
case 1:
 fmt.Println(&quot;one&quot;)
case 2:
 fmt.Println(&quot;two&quot;)
default:
 fmt.Println(&quot;none&quot;)
}
</code></pre>

<h4 id="73">7.3 循环</h4>
<p>Go的循环只有一个关键字。<code>for</code> 循环命令可以帮助实现不同类型的循环:</p>
<pre class="codehilite"><code class="language-go">i := 0
sum := 0
for i &lt; 10 {
 sum += 1
  i++
}
fmt.Println(sum)
</code></pre>

<p>以上代码类似于C语言中的<code>while</code>循环。相同的语句可以用在普通的 <code>for</code> 循环：</p>
<pre class="codehilite"><code class="language-go">sum := 0
for i := 0; i &lt; 10; i++ {
  sum += i
}
fmt.Println(sum)
</code></pre>

<p>Go中的死循环</p>
<pre class="codehilite"><code class="language-go">for {
}
</code></pre>

<h3 id="8">8. 指针</h3>
<p>Go 提供了指针。指针是保存值的地址的地方。指针由 <code>*</code> 定义。指针是根据数据类型来定义的。如下：</p>
<pre class="codehilite"><code class="language-go">var ap *int
</code></pre>

<p>这里<code>ap</code>是指向整型的指针。<code>&amp;</code> 操作符用于获取变量的地址。</p>
<pre class="codehilite"><code class="language-go">a := 12
ap = &amp;a
</code></pre>

<p>指针所指向的值可以使用 <code>*</code> 操作符访问:</p>
<pre class="codehilite"><code class="language-go">fmt.Println(*ap)
// =&gt; 12
</code></pre>

<p>在将结构体作为参数传递或为已定义的类型声明方法时，通常首选指针。</p>
<ul>
<li>当传递值时，值实际上被复制，这意味着更多的内存。</li>
<li>传递指针后，方法/函数可以直接修改指针所指向的值。</li>
</ul>
<p>比如：</p>
<pre class="codehilite"><code class="language-go">func increment(i *int) {
  *i++
}
func main() {
  i := 10
  increment(&amp;i)
  fmt.Println(i)
}
//=&gt; 11
</code></pre>

<p>注意：不要忘记在需要的时候写上package main和import fmt或其他包</p>
<h3 id="9">9. 函数</h3>
<p><code>main</code>包中定义的<code>main</code>函数是go程序执行的入口，我们还可以定义和使用更多其他函数。先来看个例子吧：</p>
<pre class="codehilite"><code class="language-go">func add(a int, b int) int {
 c := a + b
 return c
}
func main() {
 fmt.Println(add(2, 1))
}
//=&gt; 3
</code></pre>

<p>如上所示，一个 Go 函数是用 <code>func</code> 关键字和函数名定义的。函数接受的参数需要根据它的数据类型来定义，最后是返回的数据类型。</p>
<p>函数的返回值也可以在函数中提前定义：</p>
<pre class="codehilite"><code class="language-go">func add(a int, b int) (c int) {
  c = a + b
  return
}
func main() {
  fmt.Println(add(2, 1))
}
//=&gt; 3
</code></pre>

<p>这里 <code>c</code> 被定义为返回变量。因此，定义的变量 <code>c</code> 将自动返回，而不需要在最后的返回语句中定义。</p>
<p>您也可以从单个函数返回多个返回值，返回值之间用逗号分隔。</p>
<pre class="codehilite"><code class="language-go">func add(a int, b int) (int, string) {
  c := a + b
  return c, &quot;successfully added&quot;
}
func main() {
  sum, message := add(2, 1)
  fmt.Println(message)
  fmt.Println(sum)
}
</code></pre>

<h3 id="10">10. 方法、结构体和接口</h3>
<p>Go 并不是一种完全面向对象的语言，但是通过结构、接口和方法，让它有了很多面向对象的支持和效果。</p>
<h4 id="101-struct">10.1 结构体(Struct)</h4>
<p>结构体包含不同类型的字段，可用来对数据进行分组。例如，如果我们要对Person类型的数据进行分组，那么可以定义一个人的各种属性，包括姓名，年龄，性别等。</p>
<p>结构体是不同字段的类型化集合。结构体用于将数据进行分组。例如，如果我们想对Person类型的数据进行分组，我们定义一个人的属性，该属性包括姓名、年龄、性别。结构体可以使用以下语法定义:</p>
<pre class="codehilite"><code class="language-go">type person struct {
  name string
  age int
  gender string
}
</code></pre>

<p>Person类型定义后，现在我们来创建一个 Person对象:</p>
<pre class="codehilite"><code class="language-go">//方法 1: 指定参数和值
p := person{name: &quot;Bob&quot;, age: 42, gender: &quot;Male&quot;}
//方法 2: 仅指定值
person{&quot;Bob&quot;, 42, &quot;Male&quot;}
</code></pre>

<p>我们可以容易的使用<code>.</code>来获取一个对象的参数。</p>
<pre class="codehilite"><code class="language-go">p.name
//=&gt; Bob
p.age
//=&gt; 42
p.gender
//=&gt; Male
</code></pre>

<p>你也可以通过结构体的指针对象来获取参数。</p>
<pre class="codehilite"><code class="language-go">pp := &amp;person{name: &quot;Bob&quot;, age: 42, gender: &quot;Male&quot;}
pp.name
//=&gt; Bob
</code></pre>

<h4 id="102-methods">10.2 方法(Methods)</h4>
<p>方法是一种带有接收器的特殊函数。一个接收器可以是一个值或指针。我们可以创建一个叫 <code>describe</code> 的方法作为刚刚创建的Person类型的接收器，如下：</p>
<pre class="codehilite"><code class="language-go">package main
import &quot;fmt&quot;

// 定义结构体
type person struct {
  name   string
  age    int
  gender string
}

// 定义方法
func (p *person) describe() {
  fmt.Printf(&quot;%v is %v years old.&quot;, p.name, p.age)
}
func (p *person) setAge(age int) {
  p.age = age
}

func (p person) setName(name string) {
  p.name = name
}

func main() {
  pp := &amp;person{name: &quot;Bob&quot;, age: 42, gender: &quot;Male&quot;}
  pp.describe()
  // =&gt; Bob is 42 years old
  pp.setAge(45)
  fmt.Println(pp.age)
  //=&gt; 45
  pp.setName(&quot;Hari&quot;)
  fmt.Println(pp.name)
  //=&gt; Bob
}
</code></pre>

<p>正如我们在上面的例子中看到的那样，现在可以使用点操作符pp.describe来调用该方法。注意，接收器是一个指针。有了指针，我们传递了一个值的引用，所以如果我们在方法中做了任何改变，它将反映在接收器pp中。它也不会创建对象的新副本，这节省了内存。</p>
<p>注意，在上面的例子中，<code>age</code> 的值被改变了，而 <code>name</code> 的值没有改变，因为 <code>setName</code>是接收者类型，而 <code>setAge</code> 是指针类型。</p>
<h4 id="103">10.3 接口</h4>
<p>在 Go 中，接口是方法的集合。接口可以对一个类型的属性进行分组，我们以动物为例，比如：</p>
<pre class="codehilite"><code class="language-go">type animal interface {
  description() string
}
</code></pre>

<p>这里<code>animal</code>是一个接口。现在让我们来创建两种不同类型的动物来实现<code>animal</code>接口。</p>
<pre class="codehilite"><code class="language-go">package main

import (
  &quot;fmt&quot;
)

type animal interface {
  description() string
}

type cat struct {
  Type  string
  Sound string
}

type snake struct {
  Type      string
  Poisonous bool
}

func (s snake) description() string {
  return fmt.Sprintf(&quot;Poisonous: %v&quot;, s.Poisonous)
}

func (c cat) description() string {
  return fmt.Sprintf(&quot;Sound: %v&quot;, c.Sound)
}

func main() {
  var a animal
  a = snake{Poisonous: true}
  fmt.Println(a.description())
  a = cat{Sound: &quot;Meow!!!&quot;}
  fmt.Println(a.description())
}

//=&gt; Poisonous: true
//=&gt; Sound: Meow!!!
</code></pre>

<p>在main函数中，我们创建了 一个类型为 <code>animal</code>的变量 <code>a</code>，然后把蛇和猫分配给类型 <code>animal</code> ，并且打印<code>a.description</code>。因此我们用两种类型(猫和蛇)以不同的方式实现了方法，最后我们得到了关于动物类型的描述。</p>
<h3 id="11">11. 包</h3>
<p>在 Go 中，所有的代码都写在包里面。<code>main</code>包是程序执行的入口，Go 自带了很多内置包，最有名的就是刚刚用过的<code>fmt</code>包。</p>
<blockquote>
<p>“Go packages in the main mechanism for programming in the large that go provides and they make possible to divvy up a large project into smaller pieces.”<br />
— Robert Griesemer</p>
</blockquote>
<p>翻译不出来，感觉大意就是 Go 包是 Go 的特色，可以把大型项目分成很多个小包，好维护。</p>
<h4 id="111-go">11.1 安装一个包go</h4>
<pre class="codehilite"><code class="language-go">go get &lt;package-url-github&gt;
// 举个例子
go get github.com/satori/go.uuid
</code></pre>

<p>包默认安装在<code>GOPATH</code>环境变量设置的工作区中。可以使用<code>cd $GOPATH/pkg</code>命令进入目录，查看已安装的包。windows下是<code>cd %GOPATH%\pkg</code>，目前这个<code>GOPATH</code>还是在win下不好用。</p>
<h4 id="112">11.2 自定义包</h4>
<p>首先在 <code>$GOPATH\src</code>目录下创建一个<code>custom_package</code>文件夹</p>
<pre class="codehilite"><code class="language-shell">mkdir custom_package
cd custom_package
</code></pre>

<p>要创建自定义包，我们首先要创建一个包含所需包名的文件夹，那我们就创建刚刚提到的<code>person</code>包，即在<code>custom_package</code>目录下创建一个<code>person</code>文件夹，如下：</p>
<pre class="codehilite"><code class="language-shell">mkdir person
cd person
</code></pre>

<p>然后在 <code>person</code> 文件夹下创建一个 <code>person.go</code>文件</p>
<pre class="codehilite"><code class="language-go">package person
func Description(name string) string {
  return &quot;The person name is: &quot; + name
}
func secretName(name string) string {
  return &quot;Do not share&quot;
}
</code></pre>

<p>现在我们需要安装这个包，以便引入并使用它。现在我们来安装它，如下：</p>
<pre class="codehilite"><code class="language-go">&gt; go install person
</code></pre>

<p>然后我们回到<code>main</code>目录下，创建一个<code>20.go</code>文件。</p>
<pre class="codehilite"><code class="language-go">package main
import(
  &quot;custom_package/person&quot;
  &quot;fmt&quot;
)
func main(){ 
  p := person.Description(&quot;Milap&quot;)
  fmt.Println(p)
}
// =&gt; The person name is: Milap
</code></pre>

<p>现在，我们可以导入我们创建的包 <code>person</code> 并使用 <code>Description</code> 函数了。注意，我们在包中创建的函数 <code>secretName</code> 将不可访问。在 Go 中，不是大写字母开头的方法名是私有的。</p>
<h4 id="113">11.3 包的文档</h4>
<p>下载 <code>godoc</code></p>
<pre class="codehilite"><code class="language-shell">go env -w GO111MODULE=on
go env -w GOPROXY=https://goproxy.cn,direct
go get golang.org/x/tools/cmd/godoc

go: downloading golang.org/x/tools v0.12.0
go: downloading golang.org/x/sys v0.11.0
go: downloading github.com/yuin/goldmark v1.4.13
go: downloading golang.org/x/mod v0.12.0
go: downloading github.com/yuin/goldmark v1.5.5
go: trying upgrade to github.com/yuin/goldmark@v1.5.5
go: added github.com/yuin/goldmark v1.5.5
go: added golang.org/x/mod v0.12.0
go: added golang.org/x/sys v0.11.0
go: added golang.org/x/tools v0.12.0
</code></pre>

<p>Go 内置了对包文档。运行以下命令生成文档:</p>
<pre class="codehilite"><code class="language-go">go doc person Description

// 结果
package person // import &quot;custom_package/person&quot;

func Description(name string) string
</code></pre>

<p>这将为包 <code>person</code> 中的 <code>Description</code> 函数生成文档。要查看文档，使用以下命令运行web服务器:</p>
<pre class="codehilite"><code class="language-shell">godoc -http=&quot;:8080&quot;
</code></pre>

<p>打开这个链接 <a href="http://localhost:8080/pkg">http://localhost:8080/pkg</a>，就能看到文档了。</p>
<h3 id="12-go">12. Go中的一些内置包</h3>
<h4 id="121-fmt">12.1 fmt</h4>
<p><code>fmt</code>包实现了格式化输入输出的功能。我们已经使用过这个包进行标准输出了。</p>
<h4 id="122-json">12.2 json</h4>
<p>Go 中另外一个很有用的包是<code>json</code>，它用来编码/解码<code>Json</code>数据。我们来看一些邓编码/解码的例子：</p>
<pre class="codehilite"><code class="language-go">// 编码
package main

import (
  &quot;fmt&quot;
  &quot;encoding/json&quot;
)

func main(){
  mapA := map[string]int{&quot;apple&quot;: 5, &quot;lettuce&quot;: 7}
  mapB, _ := json.Marshal(mapA)
  fmt.Println(string(mapB))
}
// 解码
package main

import (
  &quot;fmt&quot;
  &quot;encoding/json&quot;
)

type response struct {
  PageNumber int `json:&quot;page&quot;`
  Fruits []string `json:&quot;fruits&quot;`
}

func main(){
  str := `{&quot;page&quot;: 1, &quot;fruits&quot;: [&quot;apple&quot;, &quot;peach&quot;]}`
  res := response{}
  json.Unmarshal([]byte(str), &amp;res)
  fmt.Println(res.PageNumber)
}
//=&gt; 1
</code></pre>

<p>当使用<code>Unmarshal</code>解码json字节时，第一个参数是json字节，第二个参数是我们期望的解码后的结构体指针。注意：<code>json:"page"</code>负责把<code>page</code>映射到结构体中的<code>PageNumber</code>键上。</p>
<h3 id="13">13. 错误处理</h3>
<p>错误是程序不希望出现的和意想不到的结果。假设我们正在对外部服务进行API调用。此API调用可能成功，也可能失败。当出现错误类型时，可以识别出程序中的错误。我们来看看这个例子:</p>
<pre class="codehilite"><code class="language-go">resp, err := http.Get(&quot;http://example.com/&quot;)
</code></pre>

<p>在这里，对错误对象的API调用可能通过，也可能失败。我们可以检查错误是否为nil或者存在错误，并正确地处理响应：</p>
<pre class="codehilite"><code class="language-go">package main

import (
  &quot;fmt&quot;
  &quot;net/http&quot;
)

func main(){
  resp, err := http.Get(&quot;http://example.com/&quot;)
  if err != nil {
    fmt.Println(err)
    return
  }
  fmt.Println(resp)
}
</code></pre>

<h4 id="131">13.1 返回自定义错误</h4>
<p>在写函数时，我们可能会遇到需要报错的情景，这时可以返回一个自定义的<code>error</code>对象。</p>
<p>当我们编写自己的函数时，有时会出现错误。这些错误可以自定义一个 <code>error</code> 对象返回：</p>
<pre class="codehilite"><code class="language-go">func Increment(n int) (int, error) {
  if n &lt; 0 {
    // return error object
    return 0, errors.New(&quot;math: cannot process negative number&quot;)
  }
  return (n + 1), nil
}
func main() {
  num := 5

  if inc, err := Increment(num); err != nil {
    fmt.Printf(&quot;Failed Number: %v, error message: %v&quot;, num, err)
  }else {
    fmt.Printf(&quot;Incremented Number: %v&quot;, inc)
  }
}
</code></pre>

<p>Go 内置的大多数包，或者我们使用的外部包，都有错误处理机制。所以我们调用的任何函数都可能有错误。这些错误永远不会被忽略，并且总是在调用时总能被很好地处理，就像我们在上面的例子中所做的那样。</p>
<h4 id="132-panic">13.2 Panic</h4>
<p>Panic是指在程序执行过程中突然遇到的无法处理的问题。在Go中，panic不是处理程序异常的理想方式。建议使用error对象。当出现panic时，程序会停止运行，但会运行<code>defer</code>语句代码。</p>
<pre class="codehilite"><code class="language-go">//Go
package main

import &quot;fmt&quot;

func main() {
    f()
    fmt.Println(&quot;Returned normally from f.&quot;)
}

func f() {
    defer func() {
        if r := recover(); r != nil {
            fmt.Println(&quot;Recovered in f&quot;, r)
        }
    }()
    fmt.Println(&quot;Calling g.&quot;)
    g(0)
    fmt.Println(&quot;Returned normally from g.&quot;)
}

func g(i int) {
    if i &gt; 3 {
        fmt.Println(&quot;Panicking!&quot;)
        panic(fmt.Sprintf(&quot;%v&quot;, i))
    }
    defer fmt.Println(&quot;Defer in g&quot;, i)
    fmt.Println(&quot;Printing in g&quot;, i)
    g(i + 1)
}
</code></pre>

<h4 id="133-defer">13.3 Defer</h4>
<p><code>Defer</code> 总是在函数结束时执行。</p>
<p>在上面的例子中，我们使用panic()来执行panic。如你所注见，有一个总是需要在函数结束执行后执行的defer语句。当我们需要在函数末尾执行某些操作时，例如关闭文件，就可以使用Defer。</p>
<h3 id="14">14. 并发</h3>
<p>Go 在设计时就考虑了并发性。 Go 中的并发可以通过轻量级线程<code>Go routines</code>来实现。</p>
<h4 id="141-go-routine">14.1 Go routine</h4>
<p><code>Go routine</code>是可以与另一个函数并行或并发运行的函数。创建一个<code>Go routine</code>非常简单。只需在函数前面添加关键字Go，就可以使其并行执行。<code>Go routine</code>非常轻量级，因此我们可以创建数千个<code>routine</code>。让我们来看一个简单的例子:</p>
<pre class="codehilite"><code class="language-go">package main
import (
  &quot;fmt&quot;
  &quot;time&quot;
)
func main() {
  go c()
  fmt.Println(&quot;I am main&quot;)
  time.Sleep(time.Second * 2)
}
func c() {
  time.Sleep(time.Second * 2)
  fmt.Println(&quot;I am concurrent&quot;)
}
//=&gt; I am main
//=&gt; I am concurrent
</code></pre>

<p>正如你在上面的例子中看到的，函数c是一个与Go主线程并行执行的 <code>Go routine</code>。有时我们希望在多个线程之间共享资源。Go不喜欢与另一个线程共享一个线程的变量，因为这会增加死锁和资源等待的机会。还有另一种方法可以在 <code>Go routine</code> 之间共享资源：那就是 <code>go channels</code>。</p>
<h4 id="142-channels">14.2 Channels</h4>
<p>我们可以使用通道在两个 <code>Go routine</code> 之间传递数据。在创建通道时，有必要指定通道接收的数据类型。让我们创建一个字符串类型的通道，如下所示:</p>
<pre class="codehilite"><code class="language-go">c := make(chan string)
</code></pre>

<p>有了这个通道，我们可以发送字符串类型的数据。我们可以在这个通道中发送和接收数据:</p>
<pre class="codehilite"><code class="language-go">package main

import &quot;fmt&quot;

func main(){
  c := make(chan string)
  go func(){ c &lt;- &quot;hello&quot; }()
  msg := &lt;-c
  fmt.Println(msg)
}
//=&gt;&quot;hello&quot;
</code></pre>

<p>接收方<code>channel</code>会一直等待，直到发送方将数据发数据到<code>channel</code>。</p>
<h4 id="143-channel">14.3 单向channel</h4>
<p>在某些情况下，我们希望 <code>Go routine</code> 通过通道接收数据但不发送数据，反之亦然。为此，我们还可以创建一个单向通道。让我们来看一个简单的例子:</p>
<pre class="codehilite"><code class="language-go">package main

import (
 &quot;fmt&quot;
)

func main() {
 ch := make(chan string)

 go sc(ch)
 fmt.Println(&lt;-ch)
}

func sc(ch chan&lt;- string) {
 ch &lt;- &quot;hello&quot;
}
</code></pre>

<p>在上面的例子中，sc是一个 <code>Go routine</code> 例程，它只能向通道发送消息，但不能接收消息。</p>
<h4 id="144-selectgo-routinechannel">14.4 使用<code>select</code>语句在<code>Go routine</code>中处理多个<code>channel</code></h4>
<p>一个函数可能正在等待多个通道。这时，我们可以使用<code>select</code>语句。让我们看一个更清楚的例子：</p>
<pre class="codehilite"><code class="language-go">package main

import (
 &quot;fmt&quot;
 &quot;time&quot;
)

func main() {
 c1 := make(chan string)
 c2 := make(chan string)
 go speed1(c1)
 go speed2(c2)
 fmt.Println(&quot;Th first to arrive is:&quot;)
 select {
 case s1 := &lt;-c1:
  fmt.Println(s1)
 case s2 := &lt;-c2:
  fmt.Println(s2)
 }
}

func speed1(ch chan string) {
 time.Sleep(2 * time.Second)
 ch &lt;- &quot;speed 1&quot;
}

func speed2(ch chan string) {
 time.Sleep(1 * time.Second)
 ch &lt;- &quot;speed 2&quot;
}
</code></pre>

<p>在上面的示例中，主进程正在等待两个通道c1和c2。对于主函数打印的select case语句，消息从第一个接收到的通道发送。</p>
<h4 id="145-buffered-channel">14.5 Buffered channel</h4>
<p>您可以在go中创建缓冲通道。对于缓冲通道，如果缓冲区已满，则发送到该通道的消息将被阻塞。让我们来看看这个例子：</p>
<pre class="codehilite"><code class="language-go">package main

import &quot;fmt&quot;

func main(){
  ch := make(chan string, 2)
  ch &lt;- &quot;hello&quot;
  ch &lt;- &quot;world&quot;
  ch &lt;- &quot;!&quot; // extra message in buffer
  fmt.Println(&lt;-ch)
}

// =&gt; fatal error: all goroutines are asleep - deadlock!
</code></pre>

<p>正如我们在上面看到的，一个通道不能接受超过2个消息。</p>
<h3 id="15-golang">15. 为什么 <code>Golang</code> 能够成功呢？</h3>
<blockquote>
<p>Simplicity… — Rob-pike  </p>
<p>因为简单...</p>
</blockquote>
<p>好了，我们今天学习了Go的一些主要组件和特性。希望大家能有一些收获吧~！</p>
        <div class="copyright">
          <ul>
            <li>本文作者：畄月寒</li>
            <li>本文链接：<a href="https://testpoo.github.io/go入门.html">https://testpoo.github.io/go入门.html</a></li>
            <li>版权声明：本铺所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans"> BY-NC-SA 4.0</a> 许可协议。转载请注明出处！</li>
          </ul>
        </div>
      </div>
    </div>
    <input class="xswitch xonoff" type="checkbox" id="nvacatalog">
    <div class="nav">
      <ul>
        
        <li><a href="https://testpoo.github.io/关于我.html"><span><label style="color: #38b6fd"></label>&nbsp;关于我</span></a></li>
        
        <li><a href="https://testpoo.github.io/常用链接.html"><span><label style="color: #38b6fd"></label>&nbsp;常用链接</span></a></li>
        
        <li><a href="https://testpoo.github.io/问题解决.html"><span><label style="color: #38b6fd"></label>&nbsp;问题解决</span></a></li>
        
        <li><a href="https://testpoo.github.io/debian安装设置.html"><span><label style="color: #38b6fd"></label>&nbsp;debian安装设置</span></a></li>
        
        <li><a href="https://testpoo.github.io/javascript代码小抄.html"><span><label style="color: #38b6fd"></label>&nbsp;javascript代码小抄</span></a></li>
        
        <li><a href="https://testpoo.github.io/python代码小抄.html"><span><label style="color: #38b6fd"></label>&nbsp;python代码小抄</span></a></li>
        
        <li><a href="https://testpoo.github.io/只有一个读音的九篇古文.html"><span><label style="color: #38b6fd"></label>&nbsp;只有一个读音的九篇古文</span></a></li>
        
        <li><a href="https://testpoo.github.io/独孤羊放妻春条书.html"><span><label style="color: #38b6fd"></label>&nbsp;独孤羊放妻春条书</span></a></li>
        
        <li><a href="https://testpoo.github.io/Arch通过archinstall安装过程.html"><span><label style="color: #38b6fd"></label>&nbsp;Arch通过archinstall安装过程</span></a></li>
        
        <li><a href="https://testpoo.github.io/Jinja2简介.html"><span><label style="color: #38b6fd"></label>&nbsp;Jinja2简介</span></a></li>
        
        <li><a href="https://testpoo.github.io/shell三剑客简介.html"><span><label style="color: #38b6fd"></label>&nbsp;shell三剑客简介</span></a></li>
        
        <li><a href="https://testpoo.github.io/Python造假数据神器Faker.html"><span><label style="color: #38b6fd"></label>&nbsp;Python造假数据神器Faker</span></a></li>
        
        <li><a href="https://testpoo.github.io/FastApi简析.html"><span><label style="color: #38b6fd"></label>&nbsp;FastApi简析</span></a></li>
        
        <li><a href="https://testpoo.github.io/go测试库apitest简介.html"><span><label style="color: #38b6fd"></label>&nbsp;go测试库apitest简介</span></a></li>
        
        <li><a href="https://testpoo.github.io/go入门.html"><span><label style="color: #38b6fd"></label>&nbsp;go入门</span></a></li>
        
        <li><a href="https://testpoo.github.io/Arch手动安装过程.html"><span><label style="color: #38b6fd"></label>&nbsp;Arch手动安装过程</span></a></li>
        
        <li><a href="https://testpoo.github.io/BeautifulSoup简介.html"><span><label style="color: #38b6fd"></label>&nbsp;BeautifulSoup简介</span></a></li>
        
        <li><a href="https://testpoo.github.io/tkinter教程.html"><span><label style="color: #38b6fd"></label>&nbsp;tkinter教程</span></a></li>
        
        <li><a href="https://testpoo.github.io/debian+openbox安装过程.html"><span><label style="color: #38b6fd"></label>&nbsp;debian+openbox安装过程</span></a></li>
        
        <li><a href="https://testpoo.github.io/面试问答.html"><span><label style="color: #38b6fd"></label>&nbsp;面试问答</span></a></li>
        
        <li><a href="https://testpoo.github.io/UI自动化测试神器-Cypress.html"><span><label style="color: #38b6fd"></label>&nbsp;UI自动化测试神器-Cypress</span></a></li>
        
        <li><a href="https://testpoo.github.io/如何用自动化测试搞垮团队.html"><span><label style="color: #38b6fd"></label>&nbsp;如何用自动化测试搞垮团队</span></a></li>
        
        <li><a href="https://testpoo.github.io/mysql函数汇总.html"><span><label style="color: #38b6fd"></label>&nbsp;mysql函数汇总</span></a></li>
        
        <li><a href="https://testpoo.github.io/shell简介.html"><span><label style="color: #38b6fd"></label>&nbsp;shell简介</span></a></li>
        
        <li><a href="https://testpoo.github.io/Docker入门教程.html"><span><label style="color: #38b6fd"></label>&nbsp;Docker入门教程</span></a></li>
        
        <li><a href="https://testpoo.github.io/性能监控各指令详解.html"><span><label style="color: #38b6fd"></label>&nbsp;性能监控各指令详解</span></a></li>
        
        <li><a href="https://testpoo.github.io/Python进阶.html"><span><label style="color: #38b6fd"></label>&nbsp;Python进阶</span></a></li>
        
        <li><a href="https://testpoo.github.io/Git简介.html"><span><label style="color: #38b6fd"></label>&nbsp;Git简介</span></a></li>
        
        <li><a href="https://testpoo.github.io/Python正则表达式.html"><span><label style="color: #38b6fd"></label>&nbsp;Python正则表达式</span></a></li>
        
        <li><a href="https://testpoo.github.io/nose简介.html"><span><label style="color: #38b6fd"></label>&nbsp;nose简介</span></a></li>
        
        <li><a href="https://testpoo.github.io/Python自动化之unittest.html"><span><label style="color: #38b6fd"></label>&nbsp;Python自动化之unittest</span></a></li>
        
        <li><a href="https://testpoo.github.io/debian+i3安装过程.html"><span><label style="color: #38b6fd"></label>&nbsp;debian+i3安装过程</span></a></li>
        
        <li><a href="https://testpoo.github.io/mysql的安装.html"><span><label style="color: #38b6fd"></label>&nbsp;mysql的安装</span></a></li>
        
        <li><a href="https://testpoo.github.io/分分种学会python3.html"><span><label style="color: #38b6fd"></label>&nbsp;分分种学会python3</span></a></li>
        
        <li><a href="https://testpoo.github.io/Markdown笔记.html"><span><label style="color: #38b6fd"></label>&nbsp;Markdown笔记</span></a></li>
        
        <li><a href="https://testpoo.github.io/Linux下SVN服务器的搭建.html"><span><label style="color: #38b6fd"></label>&nbsp;Linux下SVN服务器的搭建</span></a></li>
        
        <li><a href="https://testpoo.github.io/mysql笔记.html"><span><label style="color: #38b6fd"></label>&nbsp;mysql笔记</span></a></li>
        
        <li><a href="https://testpoo.github.io/python标准异常.html"><span><label style="color: #38b6fd"></label>&nbsp;python标准异常</span></a></li>
        
        <li><a href="https://testpoo.github.io/svn命令全解.html"><span><label style="color: #38b6fd"></label>&nbsp;svn命令全解</span></a></li>
        
        <li><a href="https://testpoo.github.io/debian命令apt和dpkg用法.html"><span><label style="color: #38b6fd"></label>&nbsp;debian命令apt和dpkg用法</span></a></li>
        
      </ul>
    </div>
  </body>

  </html>