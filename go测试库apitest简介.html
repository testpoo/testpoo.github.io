<!doctype html>
  <html lang="en">

  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <title>测试铺</title>
    <link rel="stylesheet" type="text/css" href="https://testpoo.github.io/themes/css/style.css">
    <link rel="stylesheet" type="text/css" href="https://testpoo.github.io/themes/css/xui.css">
    <link rel="stylesheet" type="text/css" href="https://testpoo.github.io/themes/css/markdown.css">
    <link rel="shortcut icon" type="image/ico" href="https://testpoo.github.io/themes/img/favicon.ico">
  </head>

  

  <body>
    <div class="sider">
      <div class="categories">
        <div class="title">
          <a href="https://testpoo.github.io">
            <img src="https://testpoo.github.io/themes/img/title.jpg">
            <div class="linkbutton testpoo">测试铺</div>
          </a>
        </div>
        <div class="scrollheight">
          <ul>
            
            <li><a href="https://testpoo.github.io/关于我.html"><label style="color: #38b6fd"></label>&nbsp;关于我</a></li>
            
            <li><a href="https://testpoo.github.io/常用链接.html"><label style="color: #38b6fd"></label>&nbsp;常用链接</a></li>
            
            <li><a href="https://testpoo.github.io/问题解决.html"><label style="color: #38b6fd"></label>&nbsp;问题解决</a></li>
            
            <li><a href="https://testpoo.github.io/Arch通过archinstall安装过程.html"><label style="color: #ffba48"></label>&nbsp;linux</a></li>
            
            <li><a href="https://testpoo.github.io/Jinja2简介.html"><label style="color: #ffba48"></label>&nbsp;python</a></li>
            
            <li><a href="https://testpoo.github.io/go测试库apitest简介.html"><label style="color: #ffba48"></label>&nbsp;go</a></li>
            
            <li><a href="https://testpoo.github.io/debian+openbox+tint2安装过程.html"><label style="color: #ffba48"></label>&nbsp;debian</a></li>
            
            <li><a href="https://testpoo.github.io/面试问答.html"><label style="color: #ffba48"></label>&nbsp;笔记</a></li>
            
            <li><a href="https://testpoo.github.io/mysql函数汇总.html"><label style="color: #ffba48"></label>&nbsp;mysql</a></li>
            
          </ul>
        </div>
        <div class="github"><a href="https://github.com/testpoo" target="_blank" title="GitHub:TestPoo"></a><a href="#" title="微信号：puyaweis"></a><a href="#" title="邮箱：pu_yawei@qq.com"></a><a href="https://testpoo.github.io/rss.xml" target="_blank"></a></div>
      </div>
      <div class="articles">
        <div class="category">分类：go</div>
        <div class="scrollheight">
          <ul>
            
            <li><a href="https://testpoo.github.io/go测试库apitest简介.html"><span><label style="color: #38b6fd"></label>&nbsp;go测试库apitest简介</span><span>2023-08-23&nbsp;&nbsp;共58555个字</span><span class="tag">goapitest</span></a></li>
            
            <li><a href="https://testpoo.github.io/go入门.html"><span><label style="color: #38b6fd"></label>&nbsp;go入门</span><span>2023-08-15&nbsp;&nbsp;共23389个字</span><span class="tag">go</span></a></li>
            
          </ul>
        </div>
        <div class="item-num">总共2项</div>
      </div>
    </div>
    <div class="main">
      <div class="header"><span>go测试库apitest简介</span><span>一个80后测试老人<br />最后更新于2024-08-12 16:45:03</span></div>
      <input class="xswitch xonoff" type="checkbox" id="catalog">
      <div class="posts"><h3 id="1">1. 开始</h3>
<h4 id="11">1.1. 概述</h4>
<p>apitest是一个简单且可扩展的 Go 语言测试库。你可以使用 <code>apitest</code> 来简化 REST 服务、HTTP handlers(事件处理器) 和HTTP客户端的测试。</p>
<h4 id="12">1.2. 特征</h4>
<ul>
<li>
<p>可模拟外部http调用</p>
</li>
<li>
<p>在测试完成时可呈现序列图</p>
</li>
<li>
<p>可扩展——支持各种注入点</p>
</li>
<li>
<p>GraphQL（一种用于 API 的查询语言）支持</p>
</li>
<li>
<p>自定义断言函数和模拟匹配器</p>
</li>
<li>
<p>JSON路径断言，css选择器断言等等</p>
</li>
</ul>
<h4 id="13">1.3. 安装</h4>
<pre class="codehilite"><code class="language-shell">go get -u github.com/steinfletcher/apitest
# 使用时导入
import &quot;github.com/steinfletcher/apitest&quot;
# 就咱们现在这种网络状态，第一种方法基本不能用，目前只能手动下载，然后手动放到GOPATH/src/github.com/下。
</code></pre>

<p>apitest遵循语义版本控制，使用 Github 版本管理发布。</p>
<h4 id="14">1.4. 一个测试例子的解析</h4>
<p>例子主要包括三个部分</p>
<p>配置：定义将要测试的HTTP请求处理程序和所有其他特定的测试配置，例如模拟、调试模式和报告</p>
<p>请求：定义测试输入，这通常是一个http请求需要的</p>
<p>预期：定义被测应用程序应该如何响应。这通常是一个http响应需要的</p>
<pre class="codehilite"><code class="language-go">package main

import (
    &quot;net/http&quot;
    &quot;testing&quot;

    &quot;github.com/steinfletcher/apitest&quot;
)

func TestGetMessage(t *testing.T) {
    handler := func(w http.ResponseWriter, r *http.Request) {
        msg := `{&quot;message&quot;: &quot;hello&quot;}`
        _, _ = w.Write([]byte(msg))
        w.WriteHeader(http.StatusOK)
    }

    apitest.New(). // 配置
            HandlerFunc(handler).  // 不通过网络进行 HTTP 调用
            Get(&quot;/message&quot;). // 请求，必须写
            Expect(t).       // Expect(t).Body 匹配 HTTP 响应体
            Body(`{&quot;message&quot;: &quot;hello&quot;}`).
            Status(http.StatusOK).  // 断言http状态 http.StatusOK = 200
            End()  // 测试结束
}
</code></pre>

<p>使用 <code>go test</code> 执行测试，<code>go test -v</code> 打印测试函数的所有细节，如下：</p>
<pre class="codehilite"><code class="language-shell">$ go test 1_hello_test.go
ok      command-line-arguments  0.217s

=============================================

$ go test -v 1_hello_test.go
=== RUN   TestGetMessage

----------&gt; inbound http request
GET /message HTTP/1.1
Host: sut



&lt;---------- final response
HTTP/1.1 200 OK
Connection: close
Content-Type: text/plain; charset=utf-8

{&quot;message&quot;: &quot;hello&quot;}
Duration: 0s

--- PASS: TestGetMessage (0.00s)
PASS
ok      command-line-arguments  0.220s5s
</code></pre>

<p>源文件和测试文件放在同一目录下，测试文件以 <code>_test</code> 结尾，这个是固定格式，使用 <code>go build</code> 进行编译时，<code>_test</code> 文件不会编译。每个测试函数需要以 <code>Test</code> 为前缀，每个性能测试函数需要以 <code>Benchmark</code> 为前缀。</p>
<h3 id="2">2. 配置</h3>
<p><code>APITest</code> 配置类型公开了一些方法来注册测试钩子、启用调试日志记录、并定义被测处理程序。</p>
<h4 id="21-debug">2.1. Debug</h4>
<p>启用调试日志记录并把所有请求和响应交互的http连接情况写入控制台。</p>
<pre class="codehilite"><code class="language-go">apitest.New().
  Debug().
  Handler(myHandler)
</code></pre>

<p>这样会记录整个模拟交互过程，这对于定位失败测试用例背后的原因非常有用。在下面的示例中，由于模拟的 URL 不正确，导致不匹配。控制台会将每个模拟不匹配的原因记录下来。</p>
<pre class="codehilite"><code class="language-shell">----------&gt; inbound http request
GET /user HTTP/1.1
Host: application

failed to match mocks. Errors: received request did not match any mocks

Mock 1 mismatches:
• received path /user/12345 did not match mock path /preferences/12345

Mock 2 mismatches:
• received path /user/12345 did not match mock path /user/123456

----------&gt; request to mock
GET /user/12345 HTTP/1.1
Host: localhost:8080
User-Agent: Go-http-client/1.1
Accept-Encoding: gzip
...
</code></pre>

<h4 id="22-http-handler">2.2. HTTP Handler</h4>
<p>应该使用 Handler 或 HandlerFunc 测试定义的 <code>handler</code>，其中 myHandler 是 一个Go的 <code>http.handler</code>。</p>
<pre class="codehilite"><code class="language-go">apitest.New().Handler(myHandler)
</code></pre>

<p>设置 Handler 时，apitest 不会通过网络进行 HTTP 调用。相反，提供的 HTTP Handler 的 <code>serveHTTP</code> 方法在与测试代码相同的进程中调用。用户定义的请求和响应将通过 Go 的 <code>httptest</code> 包转换成 <code>http.Request</code> 和 <code>http.Response</code> 类型。这里的目标是测试内部应用程序而非网络。这种方法使测试既快速又简单。如果你想要用真正的 http 客户端发起一个请求去运行应用程序，则需要通过网络执行。</p>
<p>Handler 例子</p>
<pre class="codehilite"><code class="language-go">package jsonpath

import (
    &quot;net/http&quot;
    &quot;testing&quot;

    &quot;github.com/steinfletcher/apitest&quot;
)

func TestHandler(t *testing.T) {
    handler := http.NewServeMux()
    handler.HandleFunc(&quot;/data&quot;, func(w http.ResponseWriter, r *http.Request) {
        w.WriteHeader(http.StatusOK)
    })

    apitest.New().
        Handler(handler).
        Get(&quot;/data&quot;).
        Expect(t).
        Status(http.StatusOK).
        End()
}
</code></pre>

<p>HandlerFunc 例子</p>
<pre class="codehilite"><code class="language-go">package jsonpath

import (
    &quot;net/http&quot;
    &quot;testing&quot;

    &quot;github.com/steinfletcher/apitest&quot;
)

func TestHandlerFunc(t *testing.T) {
    handlerFunc := func(w http.ResponseWriter, r *http.Request) {
        w.WriteHeader(http.StatusOK)
    }

    apitest.New().
        HandlerFunc(handlerFunc).
        Post(&quot;/login&quot;).
        Expect(t).
        Status(http.StatusOK).
        End()
}
</code></pre>

<h4 id="23-hooks">2.3. Hooks</h4>
<p><strong>Intercept</strong></p>
<p>在请求调用前，<code>Intercept</code> 和 <code>Observe</code>类似。允许请求发起者将请求对象发送到被测系统之前对其进行更改。在此示例中，我们使用自定义方案设置请求参数。</p>
<pre class="codehilite"><code class="language-go">package main

import (
    &quot;net/http&quot;
    &quot;testing&quot;

    &quot;github.com/steinfletcher/apitest&quot;
)

func TestIntercept(t *testing.T) {
    handler := func(w http.ResponseWriter, r *http.Request) {
        if r.URL.RawQuery != &quot;a[]=xxx&amp;a[]=yyy&quot; {
            t.Fatal(&quot;unexpected query&quot;)
        }
        w.WriteHeader(http.StatusOK)
    }

    apitest.New().
        HandlerFunc(handler).
        Intercept(func(req *http.Request) {
            req.URL.RawQuery = &quot;a[]=xxx&amp;a[]=yyy&quot;
        }).
        Get(&quot;/&quot;).
        Expect(t).
        Status(http.StatusOK).
        End()
}
</code></pre>

<p><strong>Observe</strong></p>
<p><code>Observe</code> 可用于在测试完成时检查请求、响应和 APITest 实例。此方法在 apitest 内部使用，以捕获跨模拟服务器的所有交互，从而呈现测试结果。</p>
<pre class="codehilite"><code class="language-go">package main

import (
    &quot;net/http&quot;
    &quot;testing&quot;

    &quot;github.com/steinfletcher/apitest&quot;
)

func TestObserve(t *testing.T) {
    var observeCalled bool

    apitest.New().
        Observe(func(res *http.Response, req *http.Request, apiTest *apitest.APITest) {
            observeCalled = true
            if http.StatusOK != res.StatusCode {
                t.Fatal(&quot;unexpected status code&quot;)
            }
        }).
        HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            w.WriteHeader(http.StatusOK)
        }).
        Get(&quot;/hello&quot;).
        Expect(t).
        Status(http.StatusOK).
        End()

    if !observeCalled {
        t.Fatal(&quot;Observe not called&quot;)
    }
}
</code></pre>

<h4 id="24-networking">2.4. Networking</h4>
<p>如果要针对正在运行的应用程序发起 HTTP 请求，则需要网络。并传递带有 cookie 的 http 请求，类似浏览器的会话行为，其中 cookie 要在多个 apitest 请求中留从。此方法可用于执行端到端的测试。</p>
<pre class="codehilite"><code class="language-go">package main

import (
    &quot;fmt&quot;
    &quot;net/http&quot;
    &quot;net/http/cookiejar&quot;
    &quot;testing&quot;
    &quot;time&quot;

    &quot;github.com/steinfletcher/apitest&quot;
)

// TestEnableNetworking creates a server with two endpoints, /login sets a token via a cookie and /authenticated_resource
// validates the token. A cookie jar is used to verify session persistence across multiple apitest instances
func TestEnableNetworking(t *testing.T) {
    srv := &amp;http.Server{Addr: &quot;localhost:9876&quot;}
    finish := make(chan struct{})
    tokenValue := &quot;ABCDEF&quot;

    http.HandleFunc(&quot;/login&quot;, func(w http.ResponseWriter, r *http.Request) {
        http.SetCookie(w, &amp;http.Cookie{Name: &quot;Token&quot;, Value: tokenValue})
        w.WriteHeader(203)
    })

    http.HandleFunc(&quot;/authenticated_resource&quot;, func(w http.ResponseWriter, r *http.Request) {
        token, err := r.Cookie(&quot;Token&quot;)
        if err == http.ErrNoCookie {
            w.WriteHeader(400)
            return
        }
        if err != nil {
            w.WriteHeader(500)
            return
        }

        if token.Value != tokenValue {
            t.Fatalf(&quot;token did not equal %s&quot;, tokenValue)
        }
        w.WriteHeader(204)
    })

    go func() {
        if err := srv.ListenAndServe(); err != nil {
            panic(err)
        }
    }()

    go func() {
        defer func() {
            if r := recover(); r != nil {
                fmt.Println(&quot;Recovered in f&quot;, r)
            }
        }()

        cookieJar, _ := cookiejar.New(nil)
        cli := &amp;http.Client{
            Timeout: time.Second * 1,
            Jar:     cookieJar,
        }

        apitest.New().
            EnableNetworking(cli).
            Get(&quot;http://localhost:9876/login&quot;).
            Expect(t).
            Status(203).
            End()

        apitest.New().
            EnableNetworking(cli).
            Get(&quot;http://localhost:9876/authenticated_resource&quot;).
            Expect(t).
            Status(204).
            End()

        finish &lt;- struct{}{}
    }()

    &lt;-finish
}
</code></pre>

<h3 id="3">3. 请求</h3>
<p>要配置对被测系统的初始请求，您可以指定请求参数，例如 http 方法、url、标头和 cookie。</p>
<pre class="codehilite"><code class="language-go">apitest.New().
    Handler(handler).
    Method(http.MethodGet).
    URL(&quot;/user/12345&quot;)
</code></pre>

<p>这非常冗长，因此为常见的 http 动作定义了一些快捷方式，这些动作对方法和 URL 进行了封闭。该示例可以更简洁地表示为：</p>
<pre class="codehilite"><code class="language-go">apitest.Handler(handler).
    Get(&quot;/user/12345&quot;)
</code></pre>

<p>你还可以用标准的 Go http.Request 来定义请求。</p>
<pre class="codehilite"><code class="language-go">req := httptest.NewRequest(http.MethodGet, &quot;/user/1234&quot;, nil)
apitest.Handler(handler).
    Request(req)
</code></pre>

<h4 id="31-basic-auth">3.1. Basic Auth</h4>
<p>提供了一个向请求添加基本身份验证的方法。</p>
<p><code>BasicAuth("username", "password")</code></p>
<p>例子</p>
<pre class="codehilite"><code class="language-go">package main

import (
    &quot;net/http&quot;
    &quot;testing&quot;

    &quot;github.com/steinfletcher/apitest&quot;
)

func TestRequests_BasicAuth(t *testing.T) {
    handler := func(w http.ResponseWriter, r *http.Request) {
        username, password, ok := r.BasicAuth()
        if !ok {
            w.WriteHeader(http.StatusBadRequest)
            return
        }

        if username != &quot;username&quot; || password != &quot;password&quot; {
            w.WriteHeader(http.StatusBadRequest)
            return
        }

        w.WriteHeader(http.StatusOK)
    }

    apitest.New().
        HandlerFunc(handler).
        Get(&quot;/hello&quot;).
        BasicAuth(&quot;username&quot;, &quot;password&quot;).
        Expect(t).
        Status(http.StatusOK).
        End()
}
</code></pre>

<h4 id="32-body">3.2. Body</h4>
<p>有两个方法去设置请求体--<code>Bady</code> 和 <code>JSON</code> 。使用 <code>Body</code> 将数据复制到原始请求中并包装在 <code>io.Reader</code>。</p>
<pre class="codehilite"><code class="language-go">Post(&quot;/message&quot;).Body(&quot;hello&quot;)
</code></pre>

<p><code>JSON</code> 执行相同的操作并将提供的数据复制到正文，但 <code>JSON</code> 方法还将内容类型设置为 <code>application/json</code>。</p>
<pre class="codehilite"><code class="language-go">Post(&quot;/chat&quot;).JSON(`{&quot;message&quot;: &quot;hi&quot;}`)
</code></pre>

<p>如果要定义其他内容类型，请使用 <code>Body(data)</code> 设置包体，使用 <code>header</code> 设置标头。</p>
<pre class="codehilite"><code class="language-go">Post(&quot;/path&quot;).
Body(&quot;&lt;html&gt;content&lt;/html&gt;&quot;).
Header(&quot;Content-Type&quot;, &quot;text/html&quot;)
</code></pre>

<p>JSON 包体例子</p>
<pre class="codehilite"><code class="language-go">package main

import (
    &quot;io/ioutil&quot;
    &quot;net/http&quot;
    &quot;testing&quot;

    &quot;github.com/steinfletcher/apitest&quot;
)

func TestRequests_JSONBody(t *testing.T) {
    handler := func(w http.ResponseWriter, r *http.Request) {
        data, _ := ioutil.ReadAll(r.Body)
        if string(data) != `{&quot;a&quot;: 12345}` {
            w.WriteHeader(http.StatusInternalServerError)
            return
        }
        if r.Header.Get(&quot;Content-Type&quot;) != &quot;application/json&quot; {
            w.WriteHeader(http.StatusBadRequest)
            return
        }
        w.WriteHeader(http.StatusOK)
    }

    apitest.New().
        HandlerFunc(handler).
        Post(&quot;/hello&quot;).
        JSON(`{&quot;a&quot;: 12345}`).
        Expect(t).
        Status(http.StatusOK).
        End()
}
</code></pre>

<p>文本包体例子</p>
<pre class="codehilite"><code class="language-go">package main

import (
    &quot;io/ioutil&quot;
    &quot;net/http&quot;
    &quot;testing&quot;

    &quot;github.com/steinfletcher/apitest&quot;
)

func TestRequests_TextBody(t *testing.T) {
    handler := func(w http.ResponseWriter, r *http.Request) {
        data, _ := ioutil.ReadAll(r.Body)
        if string(data) != `hello` {
            w.WriteHeader(http.StatusInternalServerError)
            return
        }
        w.WriteHeader(http.StatusOK)
    }

    apitest.New().
        HandlerFunc(handler).
        Put(&quot;/hello&quot;).
        Body(`hello`).
        Expect(t).
        Status(http.StatusOK).
        End()
}
</code></pre>

<h4 id="33-cookies">3.3. Cookies</h4>
<p>有多种方法可以指定 http 的请求 cookie。这些方法可以一起使用。</p>
<p><strong>简短形式</strong></p>
<pre class="codehilite"><code class="language-go">Cookie(&quot;name&quot;, &quot;value&quot;)
</code></pre>

<p><strong>结构</strong></p>
<p>Cookies 是一个被用于获取已定义的不同数量的 cookie 的结构体。</p>
<pre class="codehilite"><code class="language-go">Cookies(apitest.NewCookie(&quot;name&quot;).
    Value(&quot;value&quot;).
    Path(&quot;/user&quot;).
    Domain(&quot;example.com&quot;))
</code></pre>

<p>该结构的底层字段都是指针类型。这样，断言库就可以忽略结构体中未定义的字段。</p>
<h4 id="34-form">3.4. Form</h4>
<p>在请求中创建 URL 表单有多种方法。以下几种方法可以一起使用。</p>
<p><strong>多个值的Form</strong></p>
<p>FormData 是一个可变函数，可用于为同一键获取不同数量的值。</p>
<pre class="codehilite"><code class="language-go">FormData(&quot;name&quot;, &quot;value1&quot;, &quot;value2&quot;)
</code></pre>

<p><strong>简短的Form</strong></p>
<pre class="codehilite"><code class="language-go">FormData(&quot;name&quot;, &quot;value&quot;)
</code></pre>

<h4 id="35-graphql">3.5. GraphQL</h4>
<p>以下帮助程序可简化 GraphQL 请求的构建。</p>
<pre class="codehilite"><code class="language-go">Post(&quot;/graphql&quot;).
GraphQLQuery(`query { todos { text } }`).

Post(&quot;/graphql&quot;).
GraphQLRequest(apitest.GraphQLRequestBody{
    Query: &quot;query someTest($arg: String!) { test(who: $arg) }&quot;,
    Variables: map[string]interface{}{
        &quot;arg&quot;: &quot;myArg&quot;,
    },
    OperationName: &quot;myOperation&quot;,
}).
</code></pre>

<p>例子</p>
<pre class="codehilite"><code class="language-go">package main

import (
    &quot;encoding/json&quot;
    &quot;io/ioutil&quot;
    &quot;net/http&quot;
    &quot;testing&quot;

    &quot;github.com/steinfletcher/apitest&quot;
    &quot;github.com/stretchr/testify/assert&quot;
)

func TestRequests_GraphQLQuery(t *testing.T) {
    apitest.New().
        HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            bodyBytes, err := ioutil.ReadAll(r.Body)
            if err != nil {
                t.Fatal(err)
            }

            var req apitest.GraphQLRequestBody
            if err := json.Unmarshal(bodyBytes, &amp;req); err != nil {
                t.Fatal(err)
            }

            assert.Equal(t, apitest.GraphQLRequestBody{
                Query: `query { todos { text } }`,
            }, req)

            w.WriteHeader(http.StatusOK)
        }).
        Post(&quot;/query&quot;).
        GraphQLQuery(`query { todos { text } }`).
        Expect(t).
        Status(http.StatusOK).
        End()
}

func TestRequests_GraphQLRequest(t *testing.T) {
    apitest.New().
        HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            bodyBytes, err := ioutil.ReadAll(r.Body)
            if err != nil {
                t.Fatal(err)
            }

            var req apitest.GraphQLRequestBody
            if err := json.Unmarshal(bodyBytes, &amp;req); err != nil {
                t.Fatal(err)
            }

            expected := apitest.GraphQLRequestBody{
                Query:         `query { todos { text } }`,
                OperationName: &quot;myOperation&quot;,
                Variables: map[string]interface{}{
                    &quot;a&quot;: float64(1),
                    &quot;b&quot;: &quot;2&quot;,
                },
            }

            assert.Equal(t, expected, req)

            w.WriteHeader(http.StatusOK)
        }).
        Post(&quot;/query&quot;).
        GraphQLRequest(apitest.GraphQLRequestBody{
            Query: &quot;query { todos { text } }&quot;,
            Variables: map[string]interface{}{
                &quot;a&quot;: 1,
                &quot;b&quot;: &quot;2&quot;,
            },
            OperationName: &quot;myOperation&quot;,
        }).
        Expect(t).
        Status(http.StatusOK).
        End()
}
</code></pre>

<p>上面的例子需要下载一些依赖项，如下：</p>
<pre class="codehilite"><code class="language-shell">go get github.com/stretchr/testify
go get github.com/davecgh/go-spew
go get github.com/pmezard/go-difflib
go get gopkg.in/yaml.v3
</code></pre>

<h4 id="36-headers">3.6. Headers</h4>
<p>有多种方法可以指定 http 请求头。以下方法可以一起使用。</p>
<p><strong>Map</strong></p>
<pre class="codehilite"><code class="language-go">Headers(map[string]string{&quot;name1&quot;: &quot;value1&quot;, &quot;name2&quot;: &quot;value2&quot;})
</code></pre>

<p><strong>Params</strong></p>
<pre class="codehilite"><code class="language-go">Header(&quot;name&quot;, &quot;value&quot;)
</code></pre>

<h4 id="37-intercept">3.7. Intercept</h4>
<p><code>Intercept</code> 会在请求前调用，允许实现者在请求对象发送到被测系统前对其进行更改。在本例中，我们使用自定义方案设置请求参数。</p>
<pre class="codehilite"><code class="language-go">package main

import (
    &quot;net/http&quot;
    &quot;testing&quot;

    &quot;github.com/steinfletcher/apitest&quot;
)

func TestIntercept(t *testing.T) {
    handler := func(w http.ResponseWriter, r *http.Request) {
        if r.URL.RawQuery != &quot;a[]=xxx&amp;a[]=yyy&quot; {
            t.Fatal(&quot;unexpected query&quot;)
        }
        w.WriteHeader(http.StatusOK)
    }

    apitest.New().
        HandlerFunc(handler).
        Intercept(func(req *http.Request) {
            req.URL.RawQuery = &quot;a[]=xxx&amp;a[]=yyy&quot;
        }).
        Get(&quot;/&quot;).
        Expect(t).
        Status(http.StatusOK).
        End()
}
</code></pre>

<h4 id="38-query-params">3.8. Query Params</h4>
<p>有多种指定查询参数的方法。这些方法可以一起使用。</p>
<p>例子</p>
<pre class="codehilite"><code class="language-go">package main

import (
    &quot;net/http&quot;
    &quot;testing&quot;

    &quot;github.com/steinfletcher/apitest&quot;
)

func TestRequests_Query(t *testing.T) {
    expectedQueryString := &quot;a=1&amp;a=2&amp;a=9&amp;a=22&amp;b=2&quot;
    handler := func(w http.ResponseWriter, r *http.Request) {
        if expectedQueryString != r.URL.RawQuery {
            w.WriteHeader(http.StatusBadRequest)
            return
        }
        w.WriteHeader(http.StatusOK)
    }

    apitest.New().
        HandlerFunc(handler).
        Get(&quot;/foo&quot;).
        Query(&quot;a&quot;, &quot;9&quot;).
        Query(&quot;a&quot;, &quot;22&quot;).
        QueryCollection(map[string][]string{&quot;a&quot;: {&quot;1&quot;, &quot;2&quot;}}).
        QueryParams(map[string]string{&quot;b&quot;: &quot;2&quot;}).
        Expect(t).
        Status(http.StatusOK).
        End()
}
</code></pre>

<p><strong>Collection</strong></p>
<pre class="codehilite"><code class="language-go">QueryCollection(map[string][]string{&quot;a&quot;: {&quot;1&quot;, &quot;2&quot;}})
</code></pre>

<p>参数的值设置为 <code>a=1&amp;a=2</code> 。</p>
<p><strong>Custom</strong></p>
<p>如果所提供的方法不合适，你可以定义自定义一个请求拦截器。</p>
<pre class="codehilite"><code class="language-go">apitest.New().
    Handler(handler).
    Intercept(func(req *http.Request) {
        req.URL.RawQuery = &quot;a[]=xxx&amp;a[]=yyy&quot;
    }).
    Get(&quot;/path&quot;)
</code></pre>

<p><strong>Map</strong></p>
<pre class="codehilite"><code class="language-go">QueryParams(map[string]string{&quot;param1&quot;: &quot;value1&quot;, &quot;param2&quot;: &quot;value2&quot;})
</code></pre>

<p><strong>Params</strong></p>
<pre class="codehilite"><code class="language-go">Query(&quot;param&quot;, &quot;value&quot;)
</code></pre>

<h3 id="4">4. 异常</h3>
<p>我们提供了多种机制来验证响应。如果这些机制都不能满足您的需要，您可以提供自定义的 Assert 函数。定义请求后，必须调用 Expect(t) 去定义期望的结果。</p>
<h4 id="41-body">4.1. Body</h4>
<p>通过在 <code>Body</code> 方法中输入字符串去匹配 HTTP 响应体。</p>
<pre class="codehilite"><code class="language-go">Expect(t).Body(`{&quot;param&quot;: &quot;value&quot;}`)
</code></pre>

<p>断言库会检查内容是否为 JSON，如果是，则使用 testify 的 assert.JSONEq 方法执行断言。如果内容不是 JSON，则使用 testify 的 assert.Equal 方法。</p>
<pre class="codehilite"><code class="language-go">package body

import (
    &quot;net/http&quot;
    &quot;testing&quot;

    &quot;github.com/steinfletcher/apitest&quot;
)

func TestAssertBody(t *testing.T) {
    apitest.New().
        HandlerFunc(handler).
        Get(&quot;/greeting&quot;).
        Expect(t).
        Body(`{&quot;message&quot;: &quot;hello&quot;}`).
        End()
}

func handler(w http.ResponseWriter, r *http.Request) {
    w.WriteHeader(http.StatusOK)
    w.Header().Set(&quot;Content-Type&quot;, &quot;application/json&quot;)
    _, _ = w.Write([]byte(`{&quot;message&quot;: &quot;hello&quot;}`))
}
</code></pre>

<h4 id="42-cookies">4.2. Cookies</h4>
<p>断言响应 cookie 的最简单方法是将 cookie 名称和值作为参数提供给 Cookie 方法。</p>
<pre class="codehilite"><code class="language-go">Cookie(&quot;name&quot;, &quot;value&quot;)
</code></pre>

<p>例子</p>
<pre class="codehilite"><code class="language-go">package main

import (
    &quot;net/http&quot;
    &quot;testing&quot;

    &quot;github.com/steinfletcher/apitest&quot;
)

func TestAssertCookies(t *testing.T) {
    apitest.New().
        HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            http.SetCookie(w, &amp;http.Cookie{Name: &quot;name&quot;, Value: &quot;value&quot;})
            w.WriteHeader(http.StatusOK)
        }).
        Get(&quot;/data&quot;).
        Expect(t).
        Cookie(&quot;name&quot;, &quot;value&quot;).
        End()
}
</code></pre>

<p><strong>Cookie Not Present</strong></p>
<p>这是与 CookiePresent 相反的行为，用于判断断言响应中不存在具有给定名称的 cookie。</p>
<pre class="codehilite"><code class="language-go">CookieNotPresent(&quot;Session-Token&quot;)
</code></pre>

<p>例子</p>
<pre class="codehilite"><code class="language-go">package main

import (
    &quot;net/http&quot;
    &quot;testing&quot;

    &quot;github.com/steinfletcher/apitest&quot;
)

func TestAssertCookies_NotPresent(t *testing.T) {
    apitest.New().
        HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            http.SetCookie(w, &amp;http.Cookie{Name: &quot;name&quot;, Value: &quot;value&quot;})
            w.WriteHeader(http.StatusOK)
        }).
        Get(&quot;/data&quot;).
        Expect(t).
        CookieNotPresent(&quot;token&quot;).
        End()
}
</code></pre>

<p><strong>Cookie Present</strong></p>
<p>有时，应用程序会生成一个具有动态值的 cookie。如果不需要断言值，可使用 CookiePresent 方法，它只会断言 cookie 已被设置为给定的键。</p>
<pre class="codehilite"><code class="language-go">CookiePresent(&quot;Session-Token&quot;)
</code></pre>

<p>apitest 会在内部保存 cookie，因此您可以多次调用此方法，对多个 cookie 进行断言。</p>
<p>例子</p>
<pre class="codehilite"><code class="language-go">package main

import (
    &quot;net/http&quot;
    &quot;testing&quot;

    &quot;github.com/steinfletcher/apitest&quot;
)

func TestAssertCookies_Present(t *testing.T) {
    apitest.New().
        HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            http.SetCookie(w, &amp;http.Cookie{Name: &quot;name&quot;, Value: &quot;value&quot;})
            w.WriteHeader(http.StatusOK)
        }).
        Get(&quot;/data&quot;).
        Expect(t).
        CookiePresent(&quot;name&quot;).
        End()
}
</code></pre>

<p><strong>Struct</strong></p>
<p>Cookies 是一个被用于获取已定义的不同数量的 cookie 的结构体。</p>
<pre class="codehilite"><code class="language-go">Cookies(apitest.NewCookie(&quot;name&quot;).
    Value(&quot;value&quot;).
    Path(&quot;/user&quot;).
    Domain(&quot;example.com&quot;))
</code></pre>

<p>该结构的底层字段都是指针类型。这样，断言库就可以忽略结构体中未定义的字段。</p>
<p>例子</p>
<pre class="codehilite"><code class="language-go">package main

import (
    &quot;net/http&quot;
    &quot;testing&quot;

    &quot;github.com/steinfletcher/apitest&quot;
)

func TestAssertCookies_Struct(t *testing.T) {
    apitest.New().
        HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            http.SetCookie(w, &amp;http.Cookie{Name: &quot;name1&quot;, Value: &quot;value1&quot;, Path: &quot;/path1&quot;, Secure: true})
            http.SetCookie(w, &amp;http.Cookie{Name: &quot;name2&quot;, Value: &quot;value2&quot;, Path: &quot;/path2&quot;, Secure: false})
            w.WriteHeader(http.StatusOK)
        }).
        Get(&quot;/data&quot;).
        Expect(t).
        Cookies(
            apitest.NewCookie(&quot;name1&quot;).Value(&quot;value1&quot;).Secure(true).Path(&quot;/path1&quot;),
            apitest.NewCookie(&quot;name2&quot;).Value(&quot;value2&quot;).Secure(false).Path(&quot;/path2&quot;),
        ).
        End()
}
</code></pre>

<h4 id="43">4.3. 自定义</h4>
<p>通过执行签名 <code>fn func(*http.Response, *http.Request) error</code>，提供自定义断言函数。</p>
<pre class="codehilite"><code class="language-go">Assert(func(res *http.Response, _ *http.Request) error {
    if res.StatusCode &gt;= 200 &amp;&amp; res.StatusCode &lt; 400 {
        return nil
    }
    return errors.New(&quot;unexpected status code&quot;)
}).
</code></pre>

<p>自定义断言函数可以是链式的。</p>
<pre class="codehilite"><code class="language-go">package body

import (
    &quot;errors&quot;
    &quot;net/http&quot;
    &quot;testing&quot;

    &quot;github.com/steinfletcher/apitest&quot;
)

func TestAssert_Custom(t *testing.T) {
    apitest.New().
        HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            w.WriteHeader(http.StatusCreated)
        }).
        Get(&quot;/data&quot;).
        Expect(t).
        Assert(isSuccess).
        End()
}

func isSuccess(res *http.Response, _ *http.Request) error {
    if res.StatusCode &gt;= 200 &amp;&amp; res.StatusCode &lt; 400 {
        return nil
    }
    return errors.New(&quot;unexpected status code&quot;)
}
</code></pre>

<h4 id="44-headers">4.4. Headers</h4>
<p>有两种方法可以指定 HTTP 响应头。以下方法可以连锁使用。</p>
<p><strong>Map</strong></p>
<pre class="codehilite"><code class="language-go">Headers(map[string]string{&quot;name1&quot;: &quot;value1&quot;, &quot;name2&quot;: &quot;value2&quot;})
</code></pre>

<p>头信息在 apitest 内部以规范形式存储。例如，"accept-encoding "的规范键是 "Accept-Encoding"。如果内容是 JSON，则使用 testify 的 assert.JSONEq 方法执行断言。如果内容不是 JSON，则使用 testify 的 assert.Equal 方法。</p>
<pre class="codehilite"><code class="language-go">package body

import (
    &quot;net/http&quot;
    &quot;testing&quot;

    &quot;github.com/steinfletcher/apitest&quot;
)

func TestAssertHeaders_Map(t *testing.T) {
    apitest.New().
        HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            w.Header().Set(&quot;name1&quot;, &quot;value1&quot;)
            w.Header().Set(&quot;name2&quot;, &quot;value2&quot;)
            w.WriteHeader(http.StatusOK)
        }).
        Get(&quot;/data&quot;).
        Expect(t).
        Headers(map[string]string{&quot;name1&quot;: &quot;value1&quot;, &quot;name2&quot;: &quot;value2&quot;}).
        End()
}
</code></pre>

<p><strong>Params</strong></p>
<pre class="codehilite"><code class="language-go">Header(&quot;name&quot;, &quot;value&quot;)
</code></pre>

<p>例子</p>
<pre class="codehilite"><code class="language-go">package body

import (
    &quot;net/http&quot;
    &quot;testing&quot;

    &quot;github.com/steinfletcher/apitest&quot;
)

func TestAssertHeaders_Params(t *testing.T) {
    apitest.New().
        HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            w.Header().Set(&quot;name&quot;, &quot;value&quot;)
            w.WriteHeader(http.StatusOK)
        }).
        Get(&quot;/data&quot;).
        Expect(t).
        Header(&quot;name&quot;, &quot;value&quot;).
        End()
}
</code></pre>

<h4 id="45-json-path">4.5. JSON Path</h4>
<p>您可以使用 JSONPath 来断言响应中的部分内容。当你只对响应中的特定字段感兴趣时，这就很有用了。首先要安装一个单独的模块来提供这些断言，如下：</p>
<p><code>get -u github.com/steinfletcher/apitest-jsonpath</code></p>
<p>例子</p>
<pre class="codehilite"><code class="language-go">package jsonpath

import (
    &quot;net/http&quot;
    &quot;testing&quot;

    &quot;github.com/steinfletcher/apitest&quot;
    &quot;github.com/steinfletcher/apitest-jsonpath&quot;
)

func TestJSONPath(t *testing.T) {
    handler := http.NewServeMux()
    handler.HandleFunc(&quot;/data&quot;, func(w http.ResponseWriter, r *http.Request) {
        w.WriteHeader(http.StatusOK)
        w.Header().Set(&quot;Content-Type&quot;, &quot;application/json&quot;)
        _, _ = w.Write([]byte(`{
          &quot;aValue&quot;: &quot;0&quot;,
          &quot;anObject&quot;: {&quot;a&quot;: &quot;1&quot;, &quot;b&quot;:  12345},
          &quot;matches&quot;: {
            &quot;anObject&quot;: {
              &quot;aString&quot;: &quot;tom&lt;3Beer&quot;,
              &quot;aNumber&quot;: 7.212,
              &quot;aBool&quot;: true
            },
            &quot;aString&quot;: &quot;tom&lt;3Beer&quot;,
            &quot;aNumber&quot;: 7,
            &quot;aNumberSlice&quot;: [7, 8, 9],
            &quot;aStringSlice&quot;: [&quot;7&quot;, &quot;8&quot;, &quot;9&quot;],
            &quot;anObjectSlice&quot;: [{&quot;key&quot;:  &quot;c&quot;, &quot;value&quot;: &quot;ABC&quot;}]
          }
        }`))
    })

    apitest.New().
        Handler(handler).
        Get(&quot;/data&quot;).
        Expect(t).
        Assert(jsonpath.Equal(&quot;aValue&quot;, &quot;0&quot;)).
        Assert(jsonpath.NotEqual(&quot;aValue&quot;, &quot;1&quot;)).
        Assert(jsonpath.Present(&quot;aValue&quot;)).
        Assert(jsonpath.NotPresent(&quot;x&quot;)).
        Assert(jsonpath.Equal(`$.anObject`, map[string]interface{}{&quot;a&quot;: &quot;1&quot;, &quot;b&quot;: float64(12345)})).
        Assert(jsonpath.Contains(`$.matches.anObjectSlice[? @.key==&quot;c&quot;].value`, &quot;ABC&quot;)).
        Assert(
            jsonpath.Root(&quot;matches&quot;).
                Matches(`aString`, `^[mot]{3}&lt;3[AB][re]{3}$`).
                Matches(`aNumber`, `^\d$`).
                Matches(`anObject.aNumber`, `^\d\.\d{3}$`).
                Matches(`aNumberSlice[1]`, `^[80]$`).
                Matches(`anObject.aBool`, `^true$`).
                End(),
        ).
        Assert(
            jsonpath.Chain().
                NotPresent(&quot;password&quot;).
                NotEqual(&quot;aValue&quot;, &quot;12&quot;).
                End(),
        ).
        End()
}
</code></pre>

<p>上面的项目需要用到如下依赖，如下：</p>
<pre class="codehilite"><code class="language-shell">go get github.com/steinfletcher/apitest-jsonpath
go get github.com/PaesslerAG/jsonpath
go get github.com/PaesslerAG/gval
go get github.com/shopspring/decimal
</code></pre>

<p><strong>Chain</strong></p>
<p>同时提供多种解决方案</p>
<pre class="codehilite"><code class="language-go">Assert(
    jsonpath.Chain().
        Equal(&quot;a&quot;, &quot;1&quot;).
        NotEqual(&quot;b&quot;, &quot;2&quot;).
        Present(&quot;c&quot;).
        End(),
).
</code></pre>

<p>例子</p>
<pre class="codehilite"><code class="language-go">package jsonpath

import (
    &quot;net/http&quot;
    &quot;testing&quot;

    &quot;github.com/steinfletcher/apitest&quot;
    &quot;github.com/steinfletcher/apitest-jsonpath&quot;
)

func TestJSONPath_Chain(t *testing.T) {
    apitest.New().
        HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            w.WriteHeader(http.StatusOK)
            w.Header().Set(&quot;Content-Type&quot;, &quot;application/json&quot;)
            _, _ = w.Write([]byte(`{&quot;a&quot;: &quot;1&quot;, &quot;b&quot;: &quot;3&quot;, &quot;c&quot;: &quot;4&quot;}`))
        }).
        Get(&quot;/data&quot;).
        Expect(t).
        Assert(jsonpath.Chain().
            Equal(&quot;a&quot;, &quot;1&quot;).
            NotEqual(&quot;b&quot;, &quot;2&quot;).
            Present(&quot;c&quot;).
            End()).
        End()
}
</code></pre>

<p><strong>Contains</strong></p>
<p>当选择器返回使用 <code>Contains</code> 的数组类型时，假设响应中的 JSON 主体为 {"id"： 12345, "items"： [{"available": true, "color": "red"}, {"available": false, "color": "blue"}]}, 我们可以选择所有在结果中可用于断言的颜色值。</p>
<pre class="codehilite"><code class="language-go">Assert(jsonpath.Contains(&quot;$.items[?@.available==true].color&quot;, &quot;red&quot;))
</code></pre>

<p>例子</p>
<pre class="codehilite"><code class="language-go">package jsonpath

import (
    &quot;net/http&quot;
    &quot;testing&quot;

    &quot;github.com/steinfletcher/apitest&quot;
    &quot;github.com/steinfletcher/apitest-jsonpath&quot;
)

func TestJSONPath_Contains(t *testing.T) {
    apitest.New().
        HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            w.WriteHeader(http.StatusOK)
            w.Header().Set(&quot;Content-Type&quot;, &quot;application/json&quot;)
            _, _ = w.Write([]byte(`{
              &quot;items&quot;: [
                {
                  &quot;available&quot;: true,
                  &quot;color&quot;: &quot;red&quot;
                },
                {
                  &quot;available&quot;: false,
                  &quot;color&quot;: &quot;blue&quot;
                }
              ]
            }`))
        }).
        Get(&quot;/data&quot;).
        Expect(t).
        Assert(jsonpath.Contains(&quot;$.items[?@.available==true].color&quot;, &quot;red&quot;)).
        End()
}
</code></pre>

<p><strong>Equal</strong></p>
<p>当选择器返回单个值时，使用 Equal。假设响应中的 JSON 主体为 {"id"： "12345"}</p>
<pre class="codehilite"><code class="language-go">Assert(jsonpath.Equal(&quot;$.id&quot;, &quot;12345&quot;))
</code></pre>

<p>例子</p>
<pre class="codehilite"><code class="language-go">package jsonpath

import (
    &quot;net/http&quot;
    &quot;testing&quot;

    &quot;github.com/steinfletcher/apitest&quot;
    &quot;github.com/steinfletcher/apitest-jsonpath&quot;
)

func TestJSONPath_Equal(t *testing.T) {
    apitest.New().
        HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            w.WriteHeader(http.StatusOK)
            w.Header().Set(&quot;Content-Type&quot;, &quot;application/json&quot;)
            _, _ = w.Write([]byte(`{&quot;message&quot;: &quot;hello&quot;}`))
        }).
        Get(&quot;/data&quot;).
        Expect(t).
        Assert(jsonpath.Equal(&quot;message&quot;, &quot;hello&quot;)).
        End()
}
</code></pre>

<p><strong>Greater Than</strong></p>
<p>使用 "大于 "对返回值执行最小长度限制。</p>
<pre class="codehilite"><code class="language-go">Assert(jsonpath.GreaterThan(&quot;$.items&quot;, 2))
</code></pre>

<p>例子</p>
<pre class="codehilite"><code class="language-go">package jsonpath

import (
    &quot;net/http&quot;
    &quot;testing&quot;

    &quot;github.com/steinfletcher/apitest&quot;
    &quot;github.com/steinfletcher/apitest-jsonpath&quot;
)

func TestJSONPath_GreaterThan_LessThan(t *testing.T) {
    apitest.New().
        HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            w.WriteHeader(http.StatusOK)
            w.Header().Set(&quot;Content-Type&quot;, &quot;application/json&quot;)
            _, _ = w.Write([]byte(`{&quot;items&quot;: [3, 4]}`))
        }).
        Get(&quot;/data&quot;).
        Expect(t).
        Assert(jsonpath.GreaterThan(&quot;items&quot;, 1)).
        Assert(jsonpath.LessThan(&quot;items&quot;, 3)).
        End()
}
</code></pre>

<p><strong>JWT Matchers</strong></p>
<p><code>JWTHeaderEqual</code> 和 <code>JWTPayloadEqual</code> 可用于断言响应中的 JWT 内容（不会验证 JWT）。</p>
<pre class="codehilite"><code class="language-go">func Test(t *testing.T) {
    apitest.New().
        HandlerFunc(myHandler).
        Post(&quot;/login&quot;).
        Expect(t).
        Assert(jsonpath.JWTPayloadEqual(fromAuthHeader, `$.sub`, &quot;1234567890&quot;)).
        Assert(jsonpath.JWTHeaderEqual(fromAuthHeader, `$.alg`, &quot;HS256&quot;)).
        End()
}

func fromAuthHeader(res *http.Response) (string, error) {
    return res.Header.Get(&quot;Authorization&quot;), nil
}
</code></pre>

<p>例子</p>
<pre class="codehilite"><code class="language-go">func Test(t *testing.T) {
    apitest.New().
        HandlerFunc(myHandler).
        Post(&quot;/login&quot;).
        Expect(t).
        Assert(jsonpath.JWTPayloadEqual(fromAuthHeader, `$.sub`, &quot;1234567890&quot;)).
        Assert(jsonpath.JWTHeaderEqual(fromAuthHeader, `$.alg`, &quot;HS256&quot;)).
        End()
}

func fromAuthHeader(res *http.Response) (string, error) {
    return res.Header.Get(&quot;Authorization&quot;), nil
}
</code></pre>

<p><strong>Len</strong></p>
<p>使用 <code>Len</code> 检查返回值的长度。如果响应是 {"items"： [1, 2, 3]}，我们可以这样断言项的长度</p>
<pre class="codehilite"><code class="language-go">Assert(jsonpath.Len(&quot;$.items&quot;, 3))
</code></pre>

<p>例子</p>
<pre class="codehilite"><code class="language-go">package jsonpath

import (
    &quot;net/http&quot;
    &quot;testing&quot;

    &quot;github.com/steinfletcher/apitest&quot;
    &quot;github.com/steinfletcher/apitest-jsonpath&quot;
)

func TestJSONPath_Len(t *testing.T) {
    apitest.New().
        HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            _, _ = w.Write([]byte(`{&quot;items&quot;: [1, 2, 3]}`))
            w.WriteHeader(http.StatusOK)
        }).
        Get(&quot;/hello&quot;).
        Expect(t).
        Assert(jsonpath.Len(`$.items`, 3)).
        End()
}
</code></pre>

<p><strong>Less Than</strong></p>
<p>使用 <code>LessThan</code> 对返回值执行最大长度限制。</p>
<pre class="codehilite"><code class="language-go">Assert(jsonpath.LessThan(&quot;$.items&quot;, 2))
</code></pre>

<p>例子</p>
<pre class="codehilite"><code class="language-go">package jsonpath

import (
    &quot;net/http&quot;
    &quot;testing&quot;

    &quot;github.com/steinfletcher/apitest&quot;
    &quot;github.com/steinfletcher/apitest-jsonpath&quot;
)

func TestJSONPath_GreaterThan_LessThan(t *testing.T) {
    apitest.New().
        HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            w.WriteHeader(http.StatusOK)
            w.Header().Set(&quot;Content-Type&quot;, &quot;application/json&quot;)
            _, _ = w.Write([]byte(`{&quot;items&quot;: [3, 4]}`))
        }).
        Get(&quot;/data&quot;).
        Expect(t).
        Assert(jsonpath.GreaterThan(&quot;items&quot;, 1)).
        Assert(jsonpath.LessThan(&quot;items&quot;, 3)).
        End()
}
</code></pre>

<p><strong>Matches</strong></p>
<p>使用 <code>Matches</code> 检查字符串、数字或布尔类型的单个路径元素是否与正则表达式匹配。</p>
<pre class="codehilite"><code class="language-go">Assert(jsonpath.Matches(&quot;$.a&quot;, &quot;^[abc]{1,3}$&quot;))
</code></pre>

<p>例子</p>
<pre class="codehilite"><code class="language-go">package jsonpath

import (
    &quot;net/http&quot;
    &quot;testing&quot;

    &quot;github.com/steinfletcher/apitest&quot;
    &quot;github.com/steinfletcher/apitest-jsonpath&quot;
)

func TestJSONPath_Matches(t *testing.T) {
    handler := http.NewServeMux()
    handler.HandleFunc(&quot;/data&quot;, func(w http.ResponseWriter, r *http.Request) {
        w.WriteHeader(http.StatusOK)
        w.Header().Set(&quot;Content-Type&quot;, &quot;application/json&quot;)
        _, _ = w.Write([]byte(`{
          &quot;matches&quot;: {
            &quot;anObject&quot;: {
              &quot;aString&quot;: &quot;tom&lt;3Beer&quot;,
              &quot;aNumber&quot;: 7.212,
              &quot;aBool&quot;: true
            },
            &quot;aString&quot;: &quot;tom&lt;3Beer&quot;,
            &quot;aNumber&quot;: 7,
            &quot;aNumberSlice&quot;: [7, 8, 9],
            &quot;aStringSlice&quot;: [&quot;7&quot;, &quot;8&quot;, &quot;9&quot;],
            &quot;anObjectSlice&quot;: [{&quot;key&quot;:  &quot;c&quot;, &quot;value&quot;: &quot;ABC&quot;}]
          }
        }`))
    })

    apitest.New().
        Handler(handler).
        Get(&quot;/data&quot;).
        Expect(t).
        Assert(
            jsonpath.Root(&quot;matches&quot;).
                Matches(`aString`, `^[mot]{3}&lt;3[AB][re]{3}$`).
                Matches(`aNumber`, `^\d$`).
                Matches(`anObject.aNumber`, `^\d\.\d{3}$`).
                Matches(`aNumberSlice[1]`, `^[80]$`).
                Matches(`anObject.aBool`, `^true$`).
                End(),
        ).
        End()
}
</code></pre>

<p><strong>Not Equal</strong></p>
<p><code>NotEqual</code> 检查 json 路径表达式值是否不等于给定值</p>
<pre class="codehilite"><code class="language-go">Assert(jsonpath.NotEqual(&quot;$.id&quot;, &quot;56789&quot;))
</code></pre>

<p>例子</p>
<pre class="codehilite"><code class="language-go">package jsonpath

import (
    &quot;net/http&quot;
    &quot;testing&quot;

    &quot;github.com/steinfletcher/apitest&quot;
    &quot;github.com/steinfletcher/apitest-jsonpath&quot;
)

func TestJSONPath_NotEqual(t *testing.T) {
    apitest.New().
        HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            w.WriteHeader(http.StatusOK)
            w.Header().Set(&quot;Content-Type&quot;, &quot;application/json&quot;)
            _, _ = w.Write([]byte(`{&quot;message&quot;: &quot;hello&quot;}`))
        }).
        Get(&quot;/data&quot;).
        Expect(t).
        Assert(jsonpath.NotEqual(&quot;message&quot;, &quot;hello1&quot;)).
        End()
}
</code></pre>

<p><strong>Not Present</strong></p>
<p>使用 <code>NotPresent</code> 来检查响应中是否缺少某个字段，而不对其值进行评估。</p>
<pre class="codehilite"><code class="language-go">Assert(jsonpath.NotPresent(&quot;password&quot;))
</code></pre>

<p>例子</p>
<pre class="codehilite"><code class="language-go">package jsonpath

import (
    &quot;net/http&quot;
    &quot;testing&quot;

    &quot;github.com/steinfletcher/apitest&quot;
    &quot;github.com/steinfletcher/apitest-jsonpath&quot;
)

func TestJSONPath_NotPresent(t *testing.T) {
    apitest.New().
        HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            w.WriteHeader(http.StatusOK)
            w.Header().Set(&quot;Content-Type&quot;, &quot;application/json&quot;)
            _, _ = w.Write([]byte(`{&quot;name&quot;: &quot;jan&quot;}`))
        }).
        Get(&quot;/user&quot;).
        Expect(t).
        Assert(jsonpath.NotPresent(&quot;password&quot;)).
        End()
}
</code></pre>

<p><strong>Present</strong></p>
<p>检查响应中是否存在字段，但不评估其值。</p>
<pre class="codehilite"><code class="language-go">Assert(jsonpath.Present(&quot;token&quot;))
</code></pre>

<p>例子</p>
<pre class="codehilite"><code class="language-go">package jsonpath

import (
    &quot;net/http&quot;
    &quot;testing&quot;

    &quot;github.com/steinfletcher/apitest&quot;
    &quot;github.com/steinfletcher/apitest-jsonpath&quot;
)

func TestJSONPath_Present(t *testing.T) {
    apitest.New().
        HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            w.WriteHeader(http.StatusOK)
            w.Header().Set(&quot;Content-Type&quot;, &quot;application/json&quot;)
            _, _ = w.Write([]byte(`{&quot;token&quot;: &quot;f9a5eb123c01de&quot;}`))
        }).
        Post(&quot;/login&quot;).
        Expect(t).
        Assert(jsonpath.Present(&quot;token&quot;)).
        End()
}
</code></pre>

<p><strong>Root</strong></p>
<p><code>Root</code> 用于避免在body中出现重复路径。如下：</p>
<pre class="codehilite"><code class="language-go">Assert(jsonpath.Equal(&quot;$.a.b.c.d&quot;, &quot;a&quot;)).
Assert(jsonpath.Equal(&quot;$.a.b.c.e&quot;, &quot;b&quot;)).
Assert(jsonpath.Equal(&quot;$.a.b.c.f&quot;, &quot;c&quot;)).
</code></pre>

<p>也可以这样定义 <code>Root</code> 路径</p>
<pre class="codehilite"><code class="language-go">Assert(
    jsonpath.Root(&quot;a.b.c&quot;).
        Equal(&quot;d&quot;, &quot;a&quot;).
        Equal(&quot;e&quot;, &quot;b&quot;).
        Equal(&quot;f&quot;, &quot;c&quot;).
        End(),
)
</code></pre>

<h4 id="46-status-code">4.6. Status code</h4>
<p>使用 <code>status</code> 方法匹配 http 状态代码。</p>
<pre class="codehilite"><code class="language-go">Expect(t).Status(http.StatusOK)
</code></pre>

<p>例子</p>
<pre class="codehilite"><code class="language-go">package jsonpath

import (
    &quot;net/http&quot;
    &quot;testing&quot;

    &quot;github.com/steinfletcher/apitest&quot;
)

func TestAssertions_StatusCode(t *testing.T) {
    apitest.New().
        HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            w.WriteHeader(http.StatusOK)
        }).
        Get(&quot;/ping&quot;).
        Expect(t).
        Status(http.StatusOK).
        End()
}
</code></pre>

<h3 id="5-mocks">5. MOCKS</h3>
<p><strong>我们为什么要用 <code>mocks</code>？</strong></p>
<p>应用程序与外部应用程序接口集成的情况非常普遍。在开发阶段运行测试时，最好有一个较短的反馈回路，而且测试必须是可重复和可再现的。与真正的外部应用程序接口集成会增加一些未知因素，这些因素往往会因为无法控制的原因而导致测试失败。</p>
<p>模拟外部调用可提高开发生命周期测试阶段的稳定性，帮助您更有信心地快速发布功能。这并不能取代集成测试。要不要进行mocks没有硬性规定，因项目而异。</p>
<p><strong>Mocks如何工作</strong></p>
<p>apitest 中的 mock 在很大程度上受到了 gock 的启发。模拟包劫持了默认的 HTTP 传输，并实现了一个自定义的 RoundTrip 方法。如果发出的 HTTP 请求与定义的模拟集合相匹配，模拟中定义的结果将返回给调用者。</p>
<h4 id="51-mocks">5.1. 定义Mocks</h4>
<p>调用 <code>apitest.NewMock()</code> 工厂方法可定义 mock。</p>
<pre class="codehilite"><code class="language-go">var mock = apitest.NewMock().
    Get(&quot;http://external.com/user/12345&quot;).
    RespondWith().
    Body(`{&quot;name&quot;: &quot;jon&quot;}`).
    Status(http.StatusOK).
    End()
</code></pre>

<p>在上例中，当 HTTP 客户向 http://example.com/user/12345 发送 GET 请求时，{"name"： "jon"} 会在响应体中以 HTTP 状态代码 200 返回。</p>
<p>然后就可以在 apitest 配置部分添加 mock，如下所示：</p>
<pre class="codehilite"><code class="language-go">apitest.New().
    Mocks(mock).
    Handler(httpHandler).
    Get(&quot;/user&quot;).
    Expect(t).
    Status(http.StatusOK).
    End()
</code></pre>

<p>例子</p>
<pre class="codehilite"><code class="language-go">package defining_mocks

import (
    &quot;encoding/json&quot;
    &quot;fmt&quot;
    &quot;io/ioutil&quot;
    &quot;net/http&quot;
    &quot;testing&quot;

    &quot;github.com/steinfletcher/apitest&quot;
)

func TestMocks(t *testing.T) {
    getUserMock := apitest.NewMock().
        Get(&quot;/user-api&quot;).
        RespondWith().
        Body(`{&quot;name&quot;: &quot;jon&quot;, &quot;id&quot;: &quot;1234&quot;}`).
        Status(http.StatusOK).
        End()

    getPreferencesMock := apitest.NewMock().
        Get(&quot;/preferences-api&quot;).
        RespondWith().
        Body(`{&quot;is_contactable&quot;: false}`).
        Status(http.StatusOK).
        End()

    apitest.New().
        Mocks(getUserMock, getPreferencesMock).
        Handler(myHandler()).
        Get(&quot;/user&quot;).
        Expect(t).
        Status(http.StatusOK).
        Body(`{&quot;name&quot;: &quot;jon&quot;, &quot;is_contactable&quot;: false}`).
        End()
}

func myHandler() *http.ServeMux {
    handler := http.NewServeMux()
    handler.HandleFunc(&quot;/user&quot;, func(w http.ResponseWriter, r *http.Request) {
        var user user
        if err := httpGet(&quot;/user-api&quot;, &amp;user); err != nil {
            w.WriteHeader(http.StatusInternalServerError)
            return
        }

        var contactPreferences contactPreferences
        if err := httpGet(&quot;/preferences-api&quot;, &amp;contactPreferences); err != nil {
            w.WriteHeader(http.StatusInternalServerError)
            return
        }

        response := userResponse{
            Name:          user.Name,
            IsContactable: contactPreferences.IsContactable,
        }

        bytes, _ := json.Marshal(response)
        _, err := w.Write(bytes)
        if err != nil {
            w.WriteHeader(http.StatusInternalServerError)
            return
        }

        w.WriteHeader(http.StatusOK)
    })
    return handler
}

type user struct {
    Name string `json:&quot;name&quot;`
    ID   string `json:&quot;id&quot;`
}

type contactPreferences struct {
    IsContactable bool `json:&quot;is_contactable&quot;`
}

type userResponse struct {
    Name          string `json:&quot;name&quot;`
    IsContactable bool   `json:&quot;is_contactable&quot;`
}

func httpGet(path string, response interface{}) error {
    res, err := http.DefaultClient.Get(fmt.Sprintf(&quot;http://localhost:8080%s&quot;, path))
    if err != nil {
        return err
    }

    bytes, err := ioutil.ReadAll(res.Body)
    if err != nil {
        return err
    }

    err = json.Unmarshal(bytes, response)
    if err != nil {
        return err
    }

    return nil
}
</code></pre>

<h4 id="52-matchers">5.2. Matchers</h4>
<p>您可以为header、cookie、url 查询参数和body添加匹配器。</p>
<p><strong>Body</strong></p>
<p>Body 允许您为请求报文添加匹配器。</p>
<pre class="codehilite"><code class="language-go">var getUserMock = apitest.NewMock().
    Post(&quot;http://example.com/user/12345&quot;).
    Body(`{&quot;username&quot;: &quot;John&quot;}`).
    RespondWith().
    Status(http.StatusOK).
    End()
</code></pre>

<p>如果要处理 URL 编码的表单正文，可以使用 <code>FormData</code> 来匹配键和值。正则表达式也可以作为值。</p>
<pre class="codehilite"><code class="language-go">FormData(&quot;name&quot;, &quot;Simon&quot;).
FormData(&quot;name&quot;, &quot;Jo([a-z]+)n&quot;).
</code></pre>

<p>您还可以要求表单体键存在（FormDataPresent）或不存在（FormDataNotPresent）。</p>
<pre class="codehilite"><code class="language-go">FormDataPresent(&quot;name&quot;).
FormDataNotPresent(&quot;pets&quot;).
</code></pre>

<p>JSONPath 扩展提供了一个自定义匹配器，支持在请求正文中进行匹配。这对部分匹配正文非常有用。</p>
<pre class="codehilite"><code class="language-go">apitest.NewMock().
    Post(&quot;/user-external&quot;).
    AddMatcher(mocks.Equal(&quot;$.name&quot;, &quot;jan&quot;)).
    RespondWith().
</code></pre>

<p>例子</p>
<pre class="codehilite"><code class="language-go">package matchers

import (
    &quot;bytes&quot;
    jsonpath &quot;github.com/steinfletcher/apitest-jsonpath/mocks&quot;
    &quot;io/ioutil&quot;
    &quot;net/http&quot;
    &quot;testing&quot;

    &quot;github.com/steinfletcher/apitest&quot;
)

func TestMocks(t *testing.T) {
    createUserMock := apitest.NewMock().
        Post(&quot;/user-external&quot;).
        AddMatcher(jsonpath.Equal(&quot;$.name&quot;, &quot;jan&quot;)).
        RespondWith().
        Status(http.StatusCreated).
        End()

    apitest.New().
        Mocks(createUserMock).
        Handler(myHandler()).
        Post(&quot;/user&quot;).
        JSON(map[string]string{&quot;name&quot;: &quot;jan&quot;}).
        Expect(t).
        Status(http.StatusCreated).
        End()
}

func myHandler() *http.ServeMux {
    handler := http.NewServeMux()
    handler.HandleFunc(&quot;/user&quot;, func(w http.ResponseWriter, r *http.Request) {
        reqBody, err := ioutil.ReadAll(r.Body)
        if err != nil {
            panic(err)
        }

        _, err = http.DefaultClient.Post(&quot;http://localhost:8080/user-external&quot;, &quot;application/json&quot;, bytes.NewReader(reqBody))
        if err != nil {
            panic(err)
        }

        w.WriteHeader(http.StatusCreated)
    })
    return handler
}
</code></pre>

<p><strong>Cookies</strong></p>
<p><code>Cookie</code> 允许您为 cookie 名称和值添加匹配器。</p>
<pre class="codehilite"><code class="language-go">var getUserMock = apitest.NewMock().
    Get(&quot;http://example.com/user/12345&quot;).
    Cookie(&quot;sessionid&quot;, &quot;1321&quot;).
    RespondWith().
    Body(`{&quot;name&quot;: &quot;jon&quot;}`).
    Status(http.StatusOK).
    End()
</code></pre>

<p>您还可以要求 cookie 名称存在（<code>CookiePresent</code>）或不存在（<code>CookieNotPresent</code>）。</p>
<pre class="codehilite"><code class="language-go">var getUserMock = apitest.NewMock().
    Get(&quot;http://example.com/user/12345&quot;).
    CookiePresent(&quot;trackingid&quot;).
    CookieNotPresent(&quot;analytics&quot;).
    RespondWith().
    Body(`{&quot;name&quot;: &quot;jon&quot;}`).
    Status(http.StatusOK).
    End()
</code></pre>

<p><strong>Custom matchers</strong></p>
<p>您可以使用 <code>AddMatcher</code> 编写自己的自定义匹配器。匹配器函数定义为 <code>func(*http.Request, *MockRequest) error</code>.</p>
<pre class="codehilite"><code class="language-go">var getUserMock = apitest.NewMock().
    Post(&quot;http://example.com/user/12345&quot;).
    AddMatcher(func(req *http.Request, mockReq *MockRequest) error {
        if req.Method == http.MethodPost {
            return nil
        }
        return errors.New(&quot;invalid http method&quot;)
    }).
    RespondWith().
    Status(http.StatusOK).
    End()
</code></pre>

<p><strong>Header</strong></p>
<p><code>Header</code> 允许为头信息键和值添加匹配器。正则表达式也可以作为值</p>
<pre class="codehilite"><code class="language-go">var getUserMock = apitest.NewMock().
    Get(&quot;http://example.com/user/12345&quot;).
    Header(&quot;foo&quot;, &quot;bar&quot;).
    Header(&quot;token&quot;, &quot;b([a-z]+)z&quot;).
    Headers(map[string]string{&quot;name&quot;: &quot;John&quot;})
    RespondWith().
    Body(`{&quot;name&quot;: &quot;jon&quot;}`).
    Status(http.StatusOK).
    End()
</code></pre>

<p>您也可以要求头必须存在（<code>HeaderPresent</code>）或不存在（<code>HeaderNotPresent</code>）。</p>
<pre class="codehilite"><code class="language-go">var getUserMock = apitest.NewMock().
    Get(&quot;http://example.com/user/12345&quot;).
    HeaderPresent(&quot;authtoken&quot;).
    HeaderNotPresent(&quot;requestid&quot;).
    RespondWith().
    Body(`{&quot;name&quot;: &quot;jon&quot;}`).
    Status(http.StatusOK).
    End()
</code></pre>

<p><strong>Query parameters</strong></p>
<p>通过 <code>Query</code>，您可以为 url 查询参数的键和值添加匹配器。正则表达式也可以作为值。</p>
<pre class="codehilite"><code class="language-go">var getUserMock = apitest.NewMock().
    Get(&quot;http://example.com/user/12345&quot;).
    Query(&quot;page&quot;, &quot;1&quot;).
    Query(&quot;name&quot;, &quot;Jo([a-z]+)n&quot;).
    QueryParams(map[string]string{&quot;orderBy&quot;: &quot;ASC&quot;}).
    RespondWith().
    Body(`{&quot;name&quot;: &quot;jon&quot;}`).
    Status(http.StatusOK).
    End()
</code></pre>

<p>您还可以要求查询参数存在（<code>QueryPresent</code>）或不存在（<code>QueryNotPresent</code>）。</p>
<pre class="codehilite"><code class="language-go">var getUserMock = apitest.NewMock().
    Get(&quot;http://example.com/user/12345&quot;).
    QueryPresent(&quot;page&quot;).
    QueryNotPresent(&quot;name&quot;).
    RespondWith().
    Body(`{&quot;name&quot;: &quot;jon&quot;}`).
    Status(http.StatusOK).
    End()
</code></pre>

<h4 id="53-standalone">5.3. Standalone</h4>
<p>通过使用 mock 生成器上的 <code>EndStandalone</code> 终止方法，可以在 API 测试之外使用 mock。这对于在 API 测试之外测试 http 客户端非常有用。</p>
<pre class="codehilite"><code class="language-go">func TestMocks_Standalone(t *testing.T) {
    cli := http.Client{Timeout: 5}
    defer NewMock().
        Post(&quot;http://localhost:8080/path&quot;).
        Body(`{&quot;a&quot;, 12345}`).
        RespondWith().
        Status(http.StatusCreated).
        EndStandalone()()

    resp, err := cli.Post(&quot;http://localhost:8080/path&quot;,
        &quot;application/json&quot;,
        strings.NewReader(`{&quot;a&quot;, 12345}`))

    assert.NoError(t, err)
    assert.Equal(t, http.StatusCreated, resp.StatusCode)
}
</code></pre>

<p><code>EndStandalone</code> 会返回一个函数，在测试运行后调用该函数可将 http 传输重置为默认配置。</p>
<p>如果想在一个测试中注册多个独立模拟，请使用 <code>apitest.NewStandaloneMocks()</code> 工厂方法。</p>
<pre class="codehilite"><code class="language-go">resetTransport := apitest.NewStandaloneMocks(
    apitest.NewMock().
        Post(&quot;http://localhost:8080/path&quot;).
        Body(`{&quot;a&quot;: 12345}`).
        RespondWith().
        Status(http.StatusCreated).
        End(),
    apitest.NewMock().
        Get(&quot;http://localhost:8080/path&quot;).
        RespondWith().
        Body(`{&quot;a&quot;: 12345}`).
        Status(http.StatusOK).
        End(),
).End()
defer resetTransport()
</code></pre>

<h3 id="6-integrations">6. INTEGRATIONS</h3>
<p><code>apitest</code> 有许多注入点，因此很容易与其他第三方工具和测试库集成。</p>
<h4 id="61-ginkgo">6.1. Ginkgo</h4>
<p><code>apitest</code> 通过接口接受 <code>*testing.T</code>。这样就可以与其他测试库（如 Ginkgo）集成。您可以通过 <a href="https://onsi.github.io/ginkgo/#using-other-matcher-libraries">GinkgoT()</a> 生成一个模仿 <code>*testing.T</code> 的对象，并直接与 Ginkgo 通信。请参阅完整示例 <a href="https://github.com/steinfletcher/apitest/tree/master/examples/ginkgo">此处</a>。</p>
<pre class="codehilite"><code class="language-go">var _ = Describe(&quot;Ginkgo/Server&quot;, func() {

    var (
        t      GinkgoTInterface
        router *mux.Router
    )

    BeforeEach(func() {
        t = GinkgoT()
        router = server.NewApp().Router
    })

    Context(&quot;Successful CookieMatching&quot;, func() {
        It(&quot;cookies should be set correctly&quot;, func() {
            apitest.New().
                Handler(router).
                Get(&quot;/user/1234&quot;).
                Expect(t).
                Cookies(apitest.NewCookie(&quot;TomsFavouriteDrink&quot;).
                    Value(&quot;Beer&quot;).
                    Path(&quot;/&quot;)).
                Status(http.StatusOK).
                End()
        })
    })
})
</code></pre>

<h3 id="7-reports">7. REPORTS</h3>
<p>apitest 包含一种报告机制，可以生成序列图，说明入站请求、最终响应、与模拟的任何交互，甚至数据库查询。您甚至可以实现自己的 "ReportFormatter "来消费报告数据，从而生成自己的报告。</p>
<p>报告支持的主要组成部分是：</p>
<ol>
<li><strong>Event</strong> 有两种类型的事件：HTTP 事件和自定义事件。HTTP 事件代表模拟交互、进入应用程序的请求和最终响应。自定义事件用于从任意来源生成数据。自定义事件包含标题和正文。我们在 apitest 中使用这种事件类型来记录数据库交互。</li>
<li><strong>Recorder</strong> 记录测试执行期间发生的事件，如模拟交互、数据库交互以及与被测应用程序的 HTTP 交互。如果输入自己的记录器，就可以添加自定义事件，然后通过实现 ReportFormatter 来处理这些事件。这对于记录从亚马逊 S3 客户端等来源生成的自定义事件可能很有用。</li>
<li><strong>ReportFormatter</strong> 用户可用于生成自定义报告的接口。接收报告记录器，该记录器会暴露事件。SequenceDiagramFormatter 是 apitest 中包含的此接口的实现，可根据事件数据渲染 HTML 序列图。</li>
</ol>
<h4 id="71-sequence-diagrams">7.1. Sequence diagrams</h4>
<p>配置报告程序以创建序列图，如下所示</p>
<pre class="codehilite"><code class="language-go">apitest.New().
    Report(apitest.SequenceDiagram()).
    Handler(handler).
    Get(&quot;/user&quot;).
    Expect(t).
    Status(http.StatusOK).
    End()
</code></pre>

<p>在这个 <a href="https://github.com/steinfletcher/apitest/tree/master/examples/sequence-diagrams">示例</a> 中，我们实现了一个 REST API，并生成了一个与 http 交互的序列图。</p>
<p>生成的下图说明了测试中协作者之间的交互。<code>sut</code> 块是被测系统。</p>
<p><img alt="sequence diagram report" src="https://apitest.dev/static/images/seq-diagram.png" /></p>
<p>对于每次交互，请求/响应的 http 线表示法都会呈现在图表下方的事件日志中</p>
<p><img alt="sequence diagram report" src="https://apitest.dev/static/images/seq-diag-log.png" /></p>
<h3 id="8">8. 例子</h3>
<p><code>apitest</code> 实例：<code>https://github.com/steinfletcher/apitest/tree/master/examples</code></p></div>
    </div>
    <input class="xswitch xonoff" type="checkbox" id="nvacatalog">
    <div class="nav">
      <ul>
        
        <li><a href="https://testpoo.github.io/关于我.html"><span><label style="color: #38b6fd"></label>&nbsp;关于我</span></a></li>
        
        <li><a href="https://testpoo.github.io/常用链接.html"><span><label style="color: #38b6fd"></label>&nbsp;常用链接</span></a></li>
        
        <li><a href="https://testpoo.github.io/问题解决.html"><span><label style="color: #38b6fd"></label>&nbsp;问题解决</span></a></li>
        
        <li><a href="https://testpoo.github.io/Arch通过archinstall安装过程.html"><span><label style="color: #38b6fd"></label>&nbsp;Arch通过archinstall安装过程</span></a></li>
        
        <li><a href="https://testpoo.github.io/Jinja2简介.html"><span><label style="color: #38b6fd"></label>&nbsp;Jinja2简介</span></a></li>
        
        <li><a href="https://testpoo.github.io/shell三剑客简介.html"><span><label style="color: #38b6fd"></label>&nbsp;shell三剑客简介</span></a></li>
        
        <li><a href="https://testpoo.github.io/Python造假数据神器Faker.html"><span><label style="color: #38b6fd"></label>&nbsp;Python造假数据神器Faker</span></a></li>
        
        <li><a href="https://testpoo.github.io/FastApi简析.html"><span><label style="color: #38b6fd"></label>&nbsp;FastApi简析</span></a></li>
        
        <li><a href="https://testpoo.github.io/go测试库apitest简介.html"><span><label style="color: #38b6fd"></label>&nbsp;go测试库apitest简介</span></a></li>
        
        <li><a href="https://testpoo.github.io/go入门.html"><span><label style="color: #38b6fd"></label>&nbsp;go入门</span></a></li>
        
        <li><a href="https://testpoo.github.io/Arch手动安装过程.html"><span><label style="color: #38b6fd"></label>&nbsp;Arch手动安装过程</span></a></li>
        
        <li><a href="https://testpoo.github.io/BeautifulSoup简介.html"><span><label style="color: #38b6fd"></label>&nbsp;BeautifulSoup简介</span></a></li>
        
        <li><a href="https://testpoo.github.io/tkinter教程.html"><span><label style="color: #38b6fd"></label>&nbsp;tkinter教程</span></a></li>
        
        <li><a href="https://testpoo.github.io/debian+openbox+tint2安装过程.html"><span><label style="color: #38b6fd"></label>&nbsp;debian+openbox+tint2安装过程</span></a></li>
        
        <li><a href="https://testpoo.github.io/面试问答.html"><span><label style="color: #38b6fd"></label>&nbsp;面试问答</span></a></li>
        
        <li><a href="https://testpoo.github.io/UI自动化测试神器-Cypress.html"><span><label style="color: #38b6fd"></label>&nbsp;UI自动化测试神器-Cypress</span></a></li>
        
        <li><a href="https://testpoo.github.io/如何用自动化测试搞垮团队.html"><span><label style="color: #38b6fd"></label>&nbsp;如何用自动化测试搞垮团队</span></a></li>
        
        <li><a href="https://testpoo.github.io/mysql函数汇总.html"><span><label style="color: #38b6fd"></label>&nbsp;mysql函数汇总</span></a></li>
        
        <li><a href="https://testpoo.github.io/shell简介.html"><span><label style="color: #38b6fd"></label>&nbsp;shell简介</span></a></li>
        
        <li><a href="https://testpoo.github.io/Docker入门教程.html"><span><label style="color: #38b6fd"></label>&nbsp;Docker入门教程</span></a></li>
        
        <li><a href="https://testpoo.github.io/性能监控各指令详解.html"><span><label style="color: #38b6fd"></label>&nbsp;性能监控各指令详解</span></a></li>
        
        <li><a href="https://testpoo.github.io/Python进阶.html"><span><label style="color: #38b6fd"></label>&nbsp;Python进阶</span></a></li>
        
        <li><a href="https://testpoo.github.io/Git简介.html"><span><label style="color: #38b6fd"></label>&nbsp;Git简介</span></a></li>
        
        <li><a href="https://testpoo.github.io/Python正则表达式.html"><span><label style="color: #38b6fd"></label>&nbsp;Python正则表达式</span></a></li>
        
        <li><a href="https://testpoo.github.io/nose简介.html"><span><label style="color: #38b6fd"></label>&nbsp;nose简介</span></a></li>
        
        <li><a href="https://testpoo.github.io/debian+kde设置.html"><span><label style="color: #38b6fd"></label>&nbsp;debian+kde设置</span></a></li>
        
        <li><a href="https://testpoo.github.io/debian+xfce设置.html"><span><label style="color: #38b6fd"></label>&nbsp;debian+xfce设置</span></a></li>
        
        <li><a href="https://testpoo.github.io/Python自动化之unittest.html"><span><label style="color: #38b6fd"></label>&nbsp;Python自动化之unittest</span></a></li>
        
        <li><a href="https://testpoo.github.io/debian+gnome设置.html"><span><label style="color: #38b6fd"></label>&nbsp;debian+gnome设置</span></a></li>
        
        <li><a href="https://testpoo.github.io/debian+i3安装过程.html"><span><label style="color: #38b6fd"></label>&nbsp;debian+i3安装过程</span></a></li>
        
        <li><a href="https://testpoo.github.io/mysql的安装.html"><span><label style="color: #38b6fd"></label>&nbsp;mysql的安装</span></a></li>
        
        <li><a href="https://testpoo.github.io/分分种学会python3.html"><span><label style="color: #38b6fd"></label>&nbsp;分分种学会python3</span></a></li>
        
        <li><a href="https://testpoo.github.io/Markdown笔记.html"><span><label style="color: #38b6fd"></label>&nbsp;Markdown笔记</span></a></li>
        
        <li><a href="https://testpoo.github.io/Linux下SVN服务器的搭建.html"><span><label style="color: #38b6fd"></label>&nbsp;Linux下SVN服务器的搭建</span></a></li>
        
        <li><a href="https://testpoo.github.io/Debain通用设置.html"><span><label style="color: #38b6fd"></label>&nbsp;Debain通用设置</span></a></li>
        
        <li><a href="https://testpoo.github.io/mysql笔记.html"><span><label style="color: #38b6fd"></label>&nbsp;mysql笔记</span></a></li>
        
        <li><a href="https://testpoo.github.io/python标准异常.html"><span><label style="color: #38b6fd"></label>&nbsp;python标准异常</span></a></li>
        
        <li><a href="https://testpoo.github.io/svn命令全解.html"><span><label style="color: #38b6fd"></label>&nbsp;svn命令全解</span></a></li>
        
        <li><a href="https://testpoo.github.io/debian命令apt和dpkg用法.html"><span><label style="color: #38b6fd"></label>&nbsp;debian命令apt和dpkg用法</span></a></li>
        
      </ul>
    </div>
  </body>

  </html>