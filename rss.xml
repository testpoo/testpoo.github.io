<?xml version="1.0" encoding="utf-8"?>

<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">  
  <channel> 
    <title></title>  
    <description>减少幻想，减少欲望，多读书，多实践</description>  
    <link></link>  
    <atom:link href="测试铺/feed.xml" rel="self" type="application/rss+xml"/>  
    <pubDate>2025-10-09 17:54:40</pubDate>  
    <lastBuildDate>2025-10-09 17:54:40</lastBuildDate>  
    <generator>PyBlog v0.0.1</generator> 
    
    <item> 
      <title>关于我</title>  
      <description>&lt;div class=&#34;toc&#34;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#_1&#34;&gt; 关于我&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_2&#34;&gt; 网站情况&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_3&#34;&gt; 个人情况&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_4&#34;&gt; 联系我&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h3 id=&#34;_1&#34;&gt; 关于我&lt;/h3&gt;
&lt;p&gt;一个85后老人，专注测试领域。我喜欢新鲜事务，时刻摆弄着新诞生的东西；我也是一个怀旧的人，总是不自觉的回忆着过去的点点滴滴。新鲜事物带来的刺激以及快感很快就会悄然而去，最终变成怀旧的一部分。&lt;/p&gt;
&lt;p&gt;我喜欢思考人生，反复琢磨着过去和未来，曾今和现在；沉浸在轮回的苦难中，无法自拔。过去也许都是美好的，面对现实的生活，总会感到无助，但从未被现实所打倒，每一次的崛起都是未来成功的基石。&lt;/p&gt;
&lt;p&gt;我喜欢听音乐，常常把一些情感加到音乐里，这样，即使忘记了，听听那些从前的歌曲，就会多少想起些什么。&lt;/p&gt;
&lt;p&gt;我不喜欢太复杂的事情，不喜欢太多的颜色，一切都简简单单就好。绿色、蓝色，是我喜欢的颜色，绿色代表健康美好，蓝色代表沉稳冷静；也许这就是自己所期望的自己吧！&lt;/p&gt;
&lt;p&gt;我喜欢春天，那是因为时常会想起躺在自家门前大树下妈妈的怀中，微风拂过，那种温馨的感觉。&lt;/p&gt;
&lt;p&gt;我不知道该怎么来写自己，介绍自己，因为我认为自己是善变的。我有时喜欢温柔的钢琴曲，有时又会喜欢一些很High的吉他音，有时沉稳、理智，有时暴躁、愤怒。或许这就是我吧，一个不定怎样的人。&lt;/p&gt;
&lt;p&gt;或许在以后的以后，我会记录下我是怎样的一个人~！&lt;/p&gt;
&lt;h3 id=&#34;_2&#34;&gt; 网站情况&lt;/h3&gt;
&lt;p&gt;网址：&lt;a href=&#34;https://testpoo.github.io/&#34;&gt;https://testpoo.github.io/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;托管：&lt;a href=&#34;https://github.com/testpoo/testpoo.github.io/&#34;&gt;GitHub Pages&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;程序：&lt;a href=&#34;https://github.com/testpoo/PyBlog&#34;&gt;https://github.com/testpoo/PyBlog&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;_3&#34;&gt; 个人情况&lt;/h3&gt;
&lt;p&gt;网名：畄月寒&lt;/p&gt;
&lt;p&gt;籍贯：陕西&lt;/p&gt;
&lt;p&gt;现居：西安&lt;/p&gt;
&lt;p&gt;职业：&amp;lt;/&amp;gt;&lt;/p&gt;
&lt;p&gt;喜欢的音乐人：Beyond 许巍 李健&lt;/p&gt;
&lt;h3 id=&#34;_4&#34;&gt; 联系我&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Github: &lt;a href=&#34;https://github.com/testpoo&#34;&gt;https://github.com/testpoo&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;邮箱：&lt;a href=&#34;&amp;#109;&amp;#97;&amp;#105;&amp;#108;&amp;#116;&amp;#111;&amp;#58;&amp;#112;&amp;#117;&amp;#95;&amp;#121;&amp;#97;&amp;#119;&amp;#101;&amp;#105;&amp;#64;&amp;#113;&amp;#113;&amp;#46;&amp;#99;&amp;#111;&amp;#109;&#34;&gt;&amp;#112;&amp;#117;&amp;#95;&amp;#121;&amp;#97;&amp;#119;&amp;#101;&amp;#105;&amp;#64;&amp;#113;&amp;#113;&amp;#46;&amp;#99;&amp;#111;&amp;#109;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;微信：puyaweis&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</description>  
      <pubDate>2025-10-09 17:54:40</pubDate>  
      <link>https://testpoo.github.io/关于我.html</link>  
      <guid isPermaLink="true">https://testpoo.github.io/关于我.html</guid>
       
      <category>关于我</category> 
      
    </item>
    
    <item> 
      <title>网址集</title>  
      <description>&lt;div class=&#34;toc&#34;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#_1&#34;&gt; 工具&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_2&#34;&gt; 搜索&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_3&#34;&gt; 教程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_4&#34;&gt; 测开&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_5&#34;&gt; 音乐&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#linux&#34;&gt; Linux&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_6&#34;&gt; 缴费查询&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h3 id=&#34;_1&#34;&gt; 工具&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://wannianrili.bmcx.com/&#34; target=&#34;_blank&#34; title=&#34;万年日历查询&#34;&gt;万年历&lt;/a&gt; | &lt;a href=&#34;https://fontawesome.com.cn/v4/cheatsheet&#34; target=&#34;_blank&#34; title=&#34;Fontawesome中文版webfont,是一款基于css框架的网页字体图标库，它完全免费&#34;&gt;Fontawesome中文网&lt;/a&gt; | &lt;a href=&#34;https://c.runoob.com/&#34; target=&#34;_blank&#34; title=&#34;菜鸟工具，为开发设计人员提供在线工具&#34;&gt;菜鸟工具&lt;/a&gt; | &lt;a href=&#34;https://www.maoken.com/&#34; target=&#34;_blank&#34; title=&#34;最新最全的可免费商用中文字体下载网站&#34;&gt;猫啃网&lt;/a&gt; | &lt;a href=&#34;https://www.cnblogs.com/facingscreen/p/18103217&#34; target=&#34;_blank&#34; title=&#34;符号大全-特殊符号-特殊符号大全&#34;&gt;符号大全&lt;/a&gt; | &lt;a href=&#34;https://33tool.com/&#34; target=&#34;_blank&#34; title=&#34;蜻蜓工具是一个在线工具网站，包含开发工具，转换工具，图片工具，视频工具，办公辅助，站长工具等，为大家提供免费的在线工具服务。&#34;&gt;蜻蜓工具&lt;/a&gt; | &lt;a href=&#34;https://www.deepl.com/zh/translator&#34; target=&#34;_blank&#34; title=&#34;DeepL翻译：全世界最准确的翻译&#34;&gt;DeepL&lt;/a&gt; | &lt;a href=&#34;https://www.pytk.net/&#34; target=&#34;_blank&#34; title=&#34;一款在线设计仅需拖拽就能生成Tkinter布局的小工具&#34;&gt;Tkinter布局助手&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;_2&#34;&gt; 搜索&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.baidu.com&#34; target=&#34;_blank&#34; title=&#34;百度一下，你就知道&#34;&gt;百度&lt;/a&gt; | &lt;a href=&#34;https://www.bing.com&#34; target=&#34;_blank&#34; title=&#34;必应可帮助你将理论付诸实践，使得搜索更加方便快捷，从而达到事半功倍的效果&#34;&gt;必应&lt;/a&gt; | &lt;a href=&#34;https://www.sogou.com/&#34; target=&#34;_blank&#34;&gt;搜狗搜索&lt;/a&gt; | 
&lt;a href=&#34;https://www.so.com/&#34; target=&#34;_blank&#34;&gt;360搜索&lt;/a&gt; | &lt;a href=&#34;https://yandex.com/&#34; target=&#34;_blank&#34;&gt;yandex&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;_3&#34;&gt; 教程&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://git-scm.com/book/zh/v2&#34; target=&#34;_blank&#34;&gt;Git中文教程&lt;/a&gt; | &lt;a href=&#34;https://docs.python.org/zh-cn/3/&#34; target=&#34;_blank&#34;&gt;Python3官方中文文档&lt;/a&gt; | &lt;a href=&#34;https://www.liaoxuefeng.com/&#34; target=&#34;_blank&#34; title=&#34;廖雪峰的官方网站 (liaoxuefeng.com) 研究互联网产品和技术，提供原创中文精品教程&#34;&gt;廖雪峰的官方网站&lt;/a&gt; | &lt;a href=&#34;http://markdown.p2hp.com/basic-syntax/&#34; target=&#34;_blank&#34; title=&#34;The Markdown elements outlined in John Gruber&#39;s design document.&#34;&gt;Markdown基本语法&lt;/a&gt; | &lt;a href=&#34;https://tkdocs.com/shipman/index-2.html&#34; target=&#34;_blank&#34; title=&#34;Tkinter 8.5 reference: a GUI for Python&#34;&gt;TkDocs&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;_4&#34;&gt; 测开&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;http://testerhome.com/&#34; target=&#34;_blank&#34; title=&#34;测试人的家园&#34;&gt;测试之家&lt;/a&gt; | &lt;a href=&#34;https://www.github.com&#34; target=&#34;_blank&#34;&gt;Github&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;_5&#34;&gt; 音乐&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://buguyy.top/&#34; target=&#34;_blank&#34; title=&#34;布谷音乐网-在线音乐-无损音乐免费下载&#34;&gt;布谷音乐&lt;/a&gt; | &lt;a href=&#34;https://jgwav.cc/&#34; target=&#34;_blank&#34; title=&#34;极光无损音乐免费下载-无损音乐下载mp3歌曲免费下载-jgwav.com&#34;&gt;极光无损&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;linux&#34;&gt; Linux&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.xfce.org/&#34; target=&#34;_blank&#34; title=&#34;Xfce 是类 UNIX 操作系统的轻量级桌面环境&#34;&gt;XFCE官网&lt;/a&gt; | &lt;a href=&#34;https://www.debian.org&#34; target=&#34;_blank&#34; title=&#34;Debian GNU/Linux 是一个操作系统及自由软件的发行版，它是由一群自愿付出时间和精力的用户来维护并更新的。&#34;&gt;Debian官网&lt;/a&gt; | &lt;a href=&#34;https://alternativeto.net/platform/linux/&#34; target=&#34;_blank&#34; title=&#34;All Linux Software on AlternativeTo&#34;&gt;Linux Software&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;_6&#34;&gt; 缴费查询&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://ggfw.xars12333.cn/#/personalServices&#34; target=&#34;_blank&#34;&gt;西安市人力资源和社会保障局-公共服务平台&lt;/a&gt; | &lt;a href=&#34;https://zwfw.shaanxi.gov.cn/ggfw/hallEnter/#/personLogin&#34; target=&#34;_blank&#34;&gt;陕西医保网上大厅&lt;/a&gt;&lt;/p&gt;</description>  
      <pubDate>2025-10-09 17:54:40</pubDate>  
      <link>https://testpoo.github.io/网址集.html</link>  
      <guid isPermaLink="true">https://testpoo.github.io/网址集.html</guid>
       
      <category>网址集</category> 
      
    </item>
    
    <item> 
      <title>小技巧</title>  
      <description>&lt;div class=&#34;toc&#34;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#wps&#34;&gt; WPS不登录无法编辑&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#linuxzip&#34;&gt; linux下解压zip乱码问题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#deb&#34;&gt; deb重新打包&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#win11-ltsc-2024-&#34;&gt; WIN11-LTSC-2024-激活&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ssh-key&#34;&gt; 创建一个 SSH key&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#m&#34;&gt; 去除^M&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#winpythonpid&#34;&gt; Win下查找python进程PID&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h3 id=&#34;wps&#34;&gt; WPS不登录无法编辑&lt;/h3&gt;
&lt;p&gt;WPS不登录无法编辑，可将下列代码保存为reg格式，然后执行，即可编辑&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;Windows Registry Editor Version 5.00

[HKEY_CURRENT_USER\Software\kingsoft\Office\6.0\plugins\officespace\flogin]
&amp;quot;enableForceLoginForFirstInstallDevice&amp;quot;=&amp;quot;false&amp;quot;
&amp;quot;enableForceLoginStyle_202111&amp;quot;=&amp;quot;false&amp;quot;
&amp;quot;isForceLoginNewDevice202111&amp;quot;=&amp;quot;false&amp;quot;
&amp;quot;lastSkipVistorModeTime&amp;quot;=dword:ffffffff
&amp;quot;lastSkipGuideLoginTime&amp;quot;=hex(b):ff,ff,ff,ff,ff,ff,ff,6f
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;
&lt;h3 id=&#34;linuxzip&#34;&gt; linux下解压zip乱码问题&lt;/h3&gt;
&lt;p&gt;如遇win下zip包在linux下解压文件名乱码，可复制..\Python313\Lib\zipfile__init__.py，并修改其名为zipfile。然后找到文件中的cp437，将其修改为cp936。然后执行以下代码：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;# coding=utf-8

import zipfile

def unzip_file(src_path, dest_path):
    with zipfile.ZipFile(src_path, &#39;r&#39;) as zip_ref:
        zip_ref.extractall(dest_path)

# 使用方法
unzip_file(&#39;/home/poo/temp.zip&#39;, &#39;/home/poo/temp/&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;
&lt;h3 id=&#34;deb&#34;&gt; deb重新打包&lt;/h3&gt;
&lt;p&gt;deb重新打包&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;准备工作&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;mkdir extract
mkdir extract/DEBIAN
mkdir build
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;解包命令&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;# 解压包中的文件到extract目录下
dpkg -X xfce4-docklike-plugin_0.4.2_amd64.deb extract/
# 解压包中的控制信息到extract/DEBIAN下
dpkg -e xfce4-docklike-plugin_0.4.2_amd64.deb extract/DEBIAN
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;替换内容&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对修改后的内容重新进行打包，生成deb包&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;dpkg-deb -b extract/ build/
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;
&lt;h3 id=&#34;win11-ltsc-2024-&#34;&gt; WIN11-LTSC-2024-激活&lt;/h3&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;slmgr -ipk M7XTQ-FN8P6-TTKYV-9D4CC-J462D
slmgr -skms kms.03k.org
slmgr -ato
slmgr -dlv
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;
&lt;h3 id=&#34;ssh-key&#34;&gt; 创建一个 SSH key&lt;/h3&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;ssh-keygen -t rsa -C &amp;quot;your_email@example.com&amp;quot;

默认生成地址~/.ssh/id_rsa.pub
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;
&lt;h3 id=&#34;m&#34;&gt; 去除^M&lt;/h3&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;vi下 :%s/^M//g 或者 :1,$s/^M//g 均可

补充一点：^M是使用 CTRL-V CTRL-M 而不是字面上的 ^M
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;
&lt;h3 id=&#34;winpythonpid&#34;&gt; Win下查找python进程PID&lt;/h3&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;wmic process where name=&amp;quot;python.exe&amp;quot; list full
&lt;/code&gt;&lt;/pre&gt;</description>  
      <pubDate>2025-10-09 17:54:40</pubDate>  
      <link>https://testpoo.github.io/小技巧.html</link>  
      <guid isPermaLink="true">https://testpoo.github.io/小技巧.html</guid>
       
      <category>小技巧</category> 
      
    </item>
    
    <item> 
      <title>Arch通过archinstall安装过程</title>  
      <description>&lt;div class=&#34;toc&#34;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1&#34;&gt;1.连接网络&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2archinstall&#34;&gt;2.archinstall安装&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3aur&#34;&gt;3.安装aur软件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4arch-linux-cn&#34;&gt;4.添加Arch Linux CN 软件仓库源&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5pacman&#34;&gt;5.pacman命令&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#51&#34;&gt;5.1.更新系统&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#52&#34;&gt;5.2.安装包&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#53&#34;&gt;5.3.删除包&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#54&#34;&gt;5.4.搜索包&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#55&#34;&gt;5.5.其他用法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#6kde&#34;&gt;6.安装KDE&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#7-sway&#34;&gt;7. 安装Sway&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#71-sway&#34;&gt;7.1. 安装Sway及相关软件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#72&#34;&gt;7.2. 输入法环境变量设置&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#73-sway&#34;&gt;7.3. 启动Sway&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#74-sway&#34;&gt;7.4. 配置sway&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#75-foot&#34;&gt;7.5. 设置终端(foot)字体大小&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#76arch-linux-cn&#34;&gt;7.6.添加Arch Linux CN 软件仓库源&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h3 id=&#34;1&#34;&gt;1.连接网络&lt;/h3&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;#iwctl
[iwd]# device list
[iwd]# station [device] scan
[iwd]# station [device] get-networks
[iwd]# station [device] connect [SSID]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2archinstall&#34;&gt;2.archinstall安装&lt;/h3&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;# 根据提示安装系统
archinstall
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;3aur&#34;&gt;3.安装aur软件&lt;/h3&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;aur地址：https://aur.archlinux.org/packages

git clone [package URL]
cd [package name]
makepkg -si
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;4arch-linux-cn&#34;&gt;4.添加Arch Linux CN 软件仓库源&lt;/h3&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;# 在/etc/pacman.conf文件最后面添加
[archlinuxcn]
Server = https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$arch

# 然后安装archlinuxcn-keyring
pacman -Sy archlinuxcn-keyring
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;5pacman&#34;&gt;5.pacman命令&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;pacman&lt;/code&gt; 是 &lt;code&gt;Arch Linux&lt;/code&gt; 的包管理器。它将一个简单的二进制包格式和易用的构建系统结合了起来。不管软件包是来自官方的 &lt;code&gt;Arch&lt;/code&gt; 库还是用户自己创建，&lt;code&gt;pacman&lt;/code&gt; 都能方便得管理。&lt;/p&gt;
&lt;h4 id=&#34;51&#34;&gt;5.1.更新系统&lt;/h4&gt;
&lt;p&gt;在 &lt;code&gt;Archlinux&lt;/code&gt; 中，使用一条命令即可对整个系统进行更新：&lt;code&gt;pacman -Syu&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如果你已经使用 &lt;code&gt;pacman -Sy&lt;/code&gt; 将本地的包数据库与远程的仓库进行了同步，也可以只执行：&lt;code&gt;pacman -Su&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;52&#34;&gt;5.2.安装包&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;pacman -S&lt;/code&gt; 包名：例如，执行 &lt;code&gt;pacman -S firefox&lt;/code&gt; 将安装 &lt;code&gt;Firefox&lt;/code&gt;。你也可以同时安装多个包，只需以空格分隔包名即可。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pacman -Sy&lt;/code&gt; 包名：与上面命令不同的是，该命令将在同步包数据库后再执行安装。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pacman -Sv&lt;/code&gt; 包名：在显示一些操作信息后执行安装。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pacman -U&lt;/code&gt; 包名：安装本地包，其扩展名为 pkg.tar.gz。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pacman -U http://www.example.com/repo/example.pkg.tar.xz&lt;/code&gt; 安装一个远程包（不在 &lt;code&gt;pacman&lt;/code&gt; 配置的源里面）&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;53&#34;&gt;5.3.删除包&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;pacman -R&lt;/code&gt; 包名：该命令将只删除包，保留其全部已经安装的依赖关系&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pacman -Rs&lt;/code&gt; 包名：在删除包的同时，删除其所有没有被其他已安装软件包使用的依赖关系&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pacman -Rsc&lt;/code&gt; 包名：在删除包的同时，删除所有依赖这个软件包的程序&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pacman -Rd&lt;/code&gt; 包名：在删除包时不检查依赖。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;54&#34;&gt;5.4.搜索包&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;pacman -Ss&lt;/code&gt; 关键字：在仓库中搜索含关键字的包。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pacman -Qs&lt;/code&gt; 关键字： 搜索已安装的包。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pacman -Qi&lt;/code&gt; 包名：查看有关包的详尽信息。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pacman -Ql&lt;/code&gt; 包名：列出该包的文件。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;55&#34;&gt;5.5.其他用法&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;pacman -Sw&lt;/code&gt; 包名：只下载包，不安装。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pacman -Sc&lt;/code&gt;：清理未安装的包文件，包文件位于 &lt;code&gt;/var/cache/pacman/pkg/&lt;/code&gt; 目录。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pacman -Scc&lt;/code&gt;：清理所有的缓存文件。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;6kde&#34;&gt;6.安装KDE&lt;/h3&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;# 安装的软件
pacman -S fcitx5-im fcitx5-rime rime-wubi git firefox packagekit-qt6 sweeper gwenview spectacle firefox-ublock-origin fuse2 speech-dispatcher wqy-zenhei

# 向日葵启动前执行
systemctl start runsunloginclient.service
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;7-sway&#34;&gt;7. 安装Sway&lt;/h3&gt;
&lt;h4 id=&#34;71-sway&#34;&gt;7.1. 安装Sway及相关软件&lt;/h4&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;# 通过arch安装sway

sudo pacman -S thunar chromium gvfs fcitx5 fcitx5-rime xarchiver git upower blueman thunar-archive-plugin wl-clipboard rime-wubi ristretto libreoffice man-db 7zip xfce4-appfinder libreoffice-fresh-zh-cn

sudo pacman -Rns lightdm lightdm-gtk-greeter htop smartmontools vim waybar wget wireless_tools wpa_supplicant pavucontrol wmenu
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;72&#34;&gt;7.2. 输入法环境变量设置&lt;/h4&gt;
&lt;p&gt;启用fcitx输入需要配置环境变量：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;nano /etc/environment

XIM=&amp;quot;fcitx&amp;quot;
#GTK_IM_MODULE=fcitx
QT_IM_MODULE=fcitx
XMODIFIERS=&amp;quot;@im=fcitx&amp;quot;
INPUT_METHOD=fcitx
SDL_IM_MODULE=fcitx
GLFW_IM_MODULE=fcitx
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;73-sway&#34;&gt;7.3. 启动Sway&lt;/h4&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;# 编辑 ~/.bash_profile加入以下内容即可：

[ &amp;quot;$(tty)&amp;quot; = &amp;quot;/dev/tty1&amp;quot; ] &amp;amp;&amp;amp; exec sway
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;74-sway&#34;&gt;7.4. 配置sway&lt;/h4&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;mkdir -p ~/.config/sway
cp /etc/sway/config ~/.config/sway/

# 编辑~/.config/sway
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;75-foot&#34;&gt;7.5. 设置终端(foot)字体大小&lt;/h4&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;cp -r /etc/foot/ ~/.config/foot/
vi ~/.config/foot/foot.ini

font=FreeMono:size=12
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;76arch-linux-cn&#34;&gt;7.6.添加Arch Linux CN 软件仓库源&lt;/h3&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;# 在/etc/pacman.conf文件最后面添加
[archlinuxcn]
Server = https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$arch

# 然后安装archlinuxcn-keyring
pacman -Sy archlinuxcn-keyring
&lt;/code&gt;&lt;/pre&gt;</description>  
      <pubDate>2025-10-09 17:54:40</pubDate>  
      <link>https://testpoo.github.io/Arch通过archinstall安装过程.html</link>  
      <guid isPermaLink="true">https://testpoo.github.io/Arch通过archinstall安装过程.html</guid>
       
      <category>系统安装</category> 
      
    </item>
    
    <item> 
      <title>debian安装设置</title>  
      <description>&lt;div class=&#34;toc&#34;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1&#34;&gt;1. 下载特殊版本链接&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-u&#34;&gt;2. 制作自启动U盘&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3-sudo&#34;&gt;3. 将当前用户加入sudo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4-debain5&#34;&gt;4. 去掉debain开机启动项停留的5秒和电池的问题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5&#34;&gt;5. 修改源&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#6-gnome&#34;&gt;6. Gnome桌面设置&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#61&#34;&gt;6.1 安装软件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#62&#34;&gt;6.2. 删除不需要软件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#63&#34;&gt;6.3. 删除多余的扩展&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#7-xfce&#34;&gt;7. xfce桌面设置&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#71&#34;&gt;7.1. 删除软件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#72&#34;&gt;7.2. 安装软件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#73&#34;&gt;7.3. 设置&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#74&#34;&gt;7.4. 添加触摸板关启脚本&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#75-lightdm&#34;&gt;7.5. lightdm设置&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#76-gtk&#34;&gt;7.6. 启动gtk编辑器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#77&#34;&gt;7.7. 添加右键&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#78&#34;&gt;7.8. 启动花屏&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#79-gtkcss&#34;&gt;7.9. 添加gtk.css&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#8-kde&#34;&gt;8. kde桌面设置&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#81&#34;&gt;8.1. 安装软件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#82&#34;&gt;8.2. 删除不需要软件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#83&#34;&gt;8.3. 安装图标主题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#84&#34;&gt;8.4. 安装窗口装饰&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#85-sddm&#34;&gt;8.5. 安装SDDM主题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#86&#34;&gt;8.6. 解决无法更换头像&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#87&#34;&gt;8.7. 修改设置&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#9-sway&#34;&gt;9. Sway窗口管理器设置&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#91-sway&#34;&gt;9.1. 安装Sway及相关软件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#92-sway&#34;&gt;9.2. 启动Sway&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#93-sway&#34;&gt;9.3. 配置sway&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#94-foot&#34;&gt;9.4. 设置终端(foot)字体大小&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#10-labwc&#34;&gt;10. labwc窗口管理器设置&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#101-labwc&#34;&gt;10.1. 安装labwc及相关软件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#102-labwc&#34;&gt;10.2. 启动labwc&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#103-labwc&#34;&gt;10.3. 添加labwc配置文件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#104&#34;&gt;10.4. 输入法环境变量设置&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#105-rcxml&#34;&gt;10.5. 添加快捷键rc.xml&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#106&#34;&gt;10.6 开机启动设置&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#107-foot&#34;&gt;10.7. 设置终端(foot)字体大小&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#108-kanshi&#34;&gt;10.8. 设置kanshi&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#11-wayfire&#34;&gt;11. wayfire窗口管理器设置&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#111-wayfire&#34;&gt;11.1. 安装wayfire及相关软件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#112-wayfire&#34;&gt;11.2. 启动wayfire&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#113-wayfire&#34;&gt;11.3. wayfire&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#114&#34;&gt;11.4. 输入法环境变量设置&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#115-foot&#34;&gt;11.5. 设置终端(foot)字体大小&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#12-rime&#34;&gt;12. rime输入法设置&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h3 id=&#34;1&#34;&gt;1. 下载特殊版本链接&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;2023 年 6 月 10 日： 从 Debian 12 (Bookworm) 开始，固件已包含在正常的 Debian 安装程序镜像中，用户无需再在此查找特殊版本。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://cdimage.debian.org/debian-cd/current/amd64/iso-cd/&#34;&gt;稳定版：https://cdimage.debian.org/debian-cd/current/amd64/iso-cd/&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://cdimage.debian.org/cdimage/weekly-builds/amd64/iso-cd/&#34;&gt;测试版：https://cdimage.debian.org/cdimage/weekly-builds/amd64/iso-cd/&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-u&#34;&gt;2. 制作自启动U盘&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;dd if=xxx.iso of=/dev/disk&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;3-sudo&#34;&gt;3. 将当前用户加入sudo&lt;/h3&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;# 方法一
su root
nano /etc/sudoers添加 username ALL=(ALL:ALL) ALL

# 方法二
useradd -a -G sudo username
reboot
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;4-debain5&#34;&gt;4. 去掉debain开机启动项停留的5秒和电池的问题&lt;/h3&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;nano /etc/default/grub
修改GRUB_TIMEOUT=5改为GRUB_TIMEOUT=0
修改GRUB_CMDLINE_LINUX_DEFAULT=&amp;quot;quiet&amp;quot; 加acpi=force
sudo update-grub，该命令将刚才的修改更新至 /boot/grub/grub.cfg 文件中
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;5&#34;&gt;5. 修改源&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://mirrors.tuna.tsinghua.edu.cn/help/debian/&#34;&gt;https://mirrors.tuna.tsinghua.edu.cn/help/debian/&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;# 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释
deb https://mirrors.tuna.tsinghua.edu.cn/debian/ testing main contrib non-free non-free-firmware
# deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ testing main contrib non-free non-free-firmware
deb https://mirrors.tuna.tsinghua.edu.cn/debian/ testing-updates main contrib non-free non-free-firmware
# deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ testing-updates main contrib non-free non-free-firmware
deb https://mirrors.tuna.tsinghua.edu.cn/debian/ testing-backports main contrib non-free non-free-firmware
# deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ testing-backports main contrib non-free non-free-firmware
deb https://mirrors.tuna.tsinghua.edu.cn/debian-security testing-security main contrib non-free non-free-firmware
# deb-src https://mirrors.tuna.tsinghua.edu.cn/debian-security testing-security main contrib non-free non-free-firmware
# deb https://security.debian.org/debian-security testing-security main contrib non-free non-free-firmware
# # deb-src https://security.debian.org/debian-security testing-security main contrib non-free non-free-firmware
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;6-gnome&#34;&gt;6. Gnome桌面设置&lt;/h3&gt;
&lt;h4 id=&#34;61&#34;&gt;6.1 安装软件&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;sudo apt install intel-microcode fonts-noto-cjk git ibus-rime rime-data-wubi&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;62&#34;&gt;6.2. 删除不需要软件&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;apt autoremove --purge evolution libreoffice* gnome-calendar cheese gnome-chess gnome-clocks gnome-contacts evolution five-or-more four-in-a-row hitori gnome-klotski lightsoff gnome-mahjongg gnome-maps gnome-mines gnome-music gnome-nibbles quadrapassel gnome-robots gnome-sudoku swell-foop tali gnome-taquin gnome-tetravex gnome-todo totem gnome-2048 gnome-weather goldendict rhythmbox shotwell simple-scan synaptic termit transmission-gtk yelp zhcon aisleriot iagno gnome-sound-recorder fcitx5*&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;63&#34;&gt;6.3. 删除多余的扩展&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;删除/usr/share/gnome-shell/extensions下除user-theme以外的所有扩展&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;7-xfce&#34;&gt;7. xfce桌面设置&lt;/h3&gt;
&lt;h4 id=&#34;71&#34;&gt;7.1. 删除软件&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;sudo apt autoremove libreoffice* exfalso parole quodlibet synaptic xfburn xterm xfce4-whiskermenu-plugin xfce4-weather-plugin xfce4-wavelan-plugin xfce4-verve-plugin xfce4-timer-plugin xfce4-smartbookmark-plugin xfce4-cpufreq-plugin xfce4-cpugraph-plugin xfce4-diskperf-plugin xfce4-battery-plugin xfce4-sensors-plugin xfce4-systemload-plugin xfce4-xkb-plugin xfce4-netload-plugin xfce4-mailwatch-plugin xfce4-clipman-plugin xfce4-fsguard-plugin atril xfce4-genmon-plugin xsane --purge&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;72&#34;&gt;7.2. 安装软件&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;sudo apt install ibus git ibus-rime rime-data-wubi gvfs-backends blueman yaru-theme-gtk fonts-noto-cjk webext-ublock-origin-firefox ristretto xfce4-screenshooter xfce4-taskmanager xfce4-docklike-plugin pkexec pipewire-audio firefox-esr-l10n-zh-cn&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;可选图标 &lt;code&gt;https://github.com/vinceliuice/McMojave-circle&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;73&#34;&gt;7.3. 设置&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;快捷键设置:设置--&amp;gt;键盘--&amp;gt;应用程度快捷键&lt;/li&gt;
&lt;li&gt;窗口样式设置：设置--&amp;gt;窗口管理器--&amp;gt;样式+按钮布局&lt;/li&gt;
&lt;li&gt;窗口管理器微调：设置--&amp;gt;窗口管理器微调--&amp;gt;辅助功能  最大化窗口时隐藏标题&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;窗口管理器微调：设置--&amp;gt;窗口管理器微调--&amp;gt;合成器  在dock窗口下显示阴影&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;主题/字体设置：外观--&amp;gt;样式+字体&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;设置时钟格式：%A %F %H:%M 第%V周 | %F%n%H:%M | %H:%M%n%Y/%m/%d&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;74&#34;&gt;7.4. 添加触摸板关启脚本&lt;/h4&gt;
&lt;p&gt;本机快捷键Fn+F8==Super+Ctrl_L&lt;/p&gt;
&lt;p&gt;直接在键盘中设置该命令，直接打开关闭触摸板工具&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;xfce4-mouse-settings --device=&amp;quot;SYNA3602:00 093A:0255 Touchpad&amp;quot;
xfce4-mouse-settings -d &amp;quot;SYNA3602:00 093A:0255 Touchpad&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;75-lightdm&#34;&gt;7.5. lightdm设置&lt;/h4&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;/etc/lightdm/lightdm-gtk-greeter.conf
[greeter]
theme-name = Yaru
icon-theme-name = Qogir-icon
font-name = Noto Sans Mono 10
default-user-image = #distributor-logo
clock-format = %A %F %H:%M 第%V周
background = /usr/share/backgrounds/background.png
xft-dpi = 120
indicators = ~host;~spacer;~clock;~spacer;~a11y;~session;~power
#hide-user-image = true

/etc/lightdm/lightdm.conf
greeter-hide-users=false 前的#去掉
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;76-gtk&#34;&gt;7.6. 启动gtk编辑器&lt;/h4&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;xfce4-panel -q &amp;amp;&amp;amp; GTK_DEBUG=interactive xfce4-panel
重启xfce-panel:xfce4-panel -r
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;77&#34;&gt;7.7. 添加右键&lt;/h4&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;ln -s %f &#39;Link to %n&#39;
Create a Link
创建链接
Create a symbolic link for each selected item
给每个选择的项目创建一个链接

pkexec thunar %F
Open as Root
管理员打开
Open the folder with administration
管理员打开文件夹

catfish %f
Search
搜索
Search for Files
搜索文件
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;78&#34;&gt;7.8. 启动花屏&lt;/h4&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;xfwm4--&amp;gt;vblank_mode=off
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;79-gtkcss&#34;&gt;7.9. 添加gtk.css&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;路径&lt;code&gt;~/config/gtk3.0/gtk.css&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;#pulseaudio-button image,#xfce4-power-manager-plugin image,#xfce4-notification-plugin image{
            -gtk-icon-transform: scale(0.4);
}

#clock-button {font-size: 14px;}

#indicator-button* { -gtk-icon-transform: scale(1.2); }

#whiskermenu-window {
   background-color: #ffbba4;
   background-image: linear-gradient(#e66465, #9198e5);
   color: #ffffff; }

calendar.highlight { color: #e95420; }
calendar {padding: 0 5px; font-weight: bold;border-radius: 5px;font-size: 14px;border: none;}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;8-kde&#34;&gt;8. kde桌面设置&lt;/h3&gt;
&lt;h4 id=&#34;81&#34;&gt;8.1. 安装软件&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;sudo apt install fonts-noto-cjk git fcitx5-rime rime-data-wubi plasma-calendar-addons&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;82&#34;&gt;8.2. 删除不需要软件&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;apt autoremove --purge kmail kaddressbook korganizer okular akregator konqueror kwalletmanager k3b juk dragonplayer gimp imagemagick* kontrast kmenuedit qt5-style-kvantum kdeconnect* kmouth kmousetool kmag xterm&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;83&#34;&gt;8.3. 安装图标主题&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;通过&lt;code&gt;https://github.com/yeyushengfan258/Win11-icon-theme&lt;/code&gt;下载&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;进入&lt;code&gt;Win11-icon-theme&lt;/code&gt;目录，执行&lt;code&gt;./install.sh -a&lt;/code&gt;命令&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;84&#34;&gt;8.4. 安装窗口装饰&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;通过&lt;code&gt;https://github.com/vinceliuice/Colloid-kde/&lt;/code&gt;下载&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安装窗口装饰元素&lt;code&gt;Colloid-light-round&lt;/code&gt;到&lt;code&gt;~/.local/share/aurorae/themes/&lt;/code&gt;下&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;85-sddm&#34;&gt;8.5. 安装SDDM主题&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;通过&lt;code&gt;https://github.com/MarianArlt/kde-plasma-chili&lt;/code&gt;下载&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;进入&lt;code&gt;kde-plasma-chili&lt;/code&gt;目录，执行&lt;code&gt;cp -r kde-plasma-chili /usr/share/sddm/themes&lt;/code&gt;命令&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;86&#34;&gt;8.6. 解决无法更换头像&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;这是账号服务的一个缺陷: 打开&lt;code&gt;sudo nano /usr/lib/systemd/system/accounts-daemon.service&lt;/code&gt;文件，修改&lt;code&gt;PrivateTmp=true&lt;/code&gt;为&lt;code&gt;PrivateTmp=false&lt;/code&gt;，然后重启即可解决问题，这个问题已经不存在。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;87&#34;&gt;8.7. 修改设置&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;桌面背景修改：设置--&amp;gt;更改壁纸--&amp;gt;壁纸类型：每日一图--&amp;gt;提供：必应&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;双击打开文件：设置--&amp;gt;点击文件或文件夹时--&amp;gt;选中他们&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;去掉程序特效：设置--&amp;gt;外观--&amp;gt;光标--&amp;gt;配置程序启动动效，沟选“无动效”，沟去“启动动效”。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;去掉欢迎屏幕：设置--&amp;gt;外观--&amp;gt;欢迎屏幕选无。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;锁屏背景修改：设置--&amp;gt;工作区行为--&amp;gt;锁屏--&amp;gt;配置--&amp;gt;壁纸类型：每日一图--&amp;gt;提供：必应&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改登录画面：设置--&amp;gt;开机与关机--&amp;gt;登录屏幕(SDDM)--&amp;gt;选择安装的新画面&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改用户头像：设置--&amp;gt;用户--&amp;gt;修改用户头像&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;触摸板设置：设置--&amp;gt;输入设备--&amp;gt;触摸板--&amp;gt;手指轻触&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;绽放设置：设置--&amp;gt;显示器配置--&amp;gt;全局缩放率：125% &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;9-sway&#34;&gt;9. Sway窗口管理器设置&lt;/h3&gt;
&lt;h4 id=&#34;91-sway&#34;&gt;9.1. 安装Sway及相关软件&lt;/h4&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;sudo apt install fcitx5 fcitx5-rime rime-data-wubi thunar xarchiver pipewire-audio blueman thunar-archive-plugin fonts-noto-cjk sway swaybg swayidle swaylock foot wofi seatd xwayland grim git brightnessctl wl-clipboard slurp upower
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;92-sway&#34;&gt;9.2. 启动Sway&lt;/h4&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;# 编辑 ~/.profile加入以下内容即可：

if [ -z &amp;quot;$DISPLAY&amp;quot; ] &amp;amp;&amp;amp; [ &amp;quot;$(tty)&amp;quot; = &amp;quot;/dev/tty1&amp;quot; ]; then
  exec sway
fi
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;93-sway&#34;&gt;9.3. 配置sway&lt;/h4&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;mkdir -p ~/.config/sway
cp /etc/sway/config ~/.config/sway/

# 编辑~/.config/sway
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;94-foot&#34;&gt;9.4. 设置终端(foot)字体大小&lt;/h4&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;cp -r /etc/foot/ ~/.config/foot/
vi ~/.config/foot/foot.ini

font=monospace:size=12
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;10-labwc&#34;&gt;10. labwc窗口管理器设置&lt;/h3&gt;
&lt;h4 id=&#34;101-labwc&#34;&gt;10.1. 安装labwc及相关软件&lt;/h4&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;sudo apt install labwc swaybg swayidle swaylock kanshi fcitx5 fcitx5-rime rime-data-wubi thunar xarchiver pipewire-audio blueman thunar-archive-plugin fonts-noto-cjk foot wofi seatd xwayland git brightnessctl firefox-esr wlopm mako-notifier
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;102-labwc&#34;&gt;10.2. 启动labwc&lt;/h4&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;# 编辑 ~/.profile加入以下内容即可：

if [ -z &amp;quot;$DISPLAY&amp;quot; ] &amp;amp;&amp;amp; [ &amp;quot;$(tty)&amp;quot; = &amp;quot;/dev/tty1&amp;quot; ]; then
  exec labwc
fi
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;103-labwc&#34;&gt;10.3. 添加labwc配置文件&lt;/h4&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;mkdir -p ~/.config/labwc
cp /usr/share/doc/labwc/* ~/.config/labwc/
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;104&#34;&gt;10.4. 输入法环境变量设置&lt;/h4&gt;
&lt;p&gt;启用fcitx输入需要配置环境变量：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;nano ~/.config/labwc/environment

XIM=&amp;quot;fcitx&amp;quot;
#GTK_IM_MODULE=fcitx
QT_IM_MODULE=fcitx
XMODIFIERS=&amp;quot;@im=fcitx&amp;quot;
INPUT_METHOD=fcitx
SDL_IM_MODULE=fcitx
GLFW_IM_MODULE=fcitx
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;105-rcxml&#34;&gt;10.5. 添加快捷键rc.xml&lt;/h4&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;    &amp;lt;!--自定义--&amp;gt;
    &amp;lt;keybind key=&amp;quot;W-s&amp;quot;&amp;gt;
      &amp;lt;action name=&amp;quot;Execute&amp;quot; command=&amp;quot;wofi --show=drun --lines=6 --allow-images --prompt=&#39;请输入软件名称&#39;&amp;quot; /&amp;gt;
    &amp;lt;/keybind&amp;gt;
    &amp;lt;keybind key=&amp;quot;XF86AudioRaiseVolume&amp;quot;&amp;gt;
      &amp;lt;action name=&amp;quot;Execute&amp;quot; command=&amp;quot;pactl set-sink-volume @DEFAULT_SINK@ +5%&amp;quot; /&amp;gt;
    &amp;lt;/keybind&amp;gt;
    &amp;lt;keybind key=&amp;quot;XF86AudioLowerVolume&amp;quot;&amp;gt;
      &amp;lt;action name=&amp;quot;Execute&amp;quot; command=&amp;quot;pactl set-sink-volume @DEFAULT_SINK@ -5%&amp;quot; /&amp;gt;
    &amp;lt;/keybind&amp;gt;
    &amp;lt;keybind key=&amp;quot;XF86AudioMute&amp;quot;&amp;gt;
      &amp;lt;action name=&amp;quot;Execute&amp;quot; command=&amp;quot;pactl set-sink-mute @DEFAULT_SINK@ toggle&amp;quot; /&amp;gt;
    &amp;lt;/keybind&amp;gt;
    &amp;lt;keybind key=&amp;quot;XF86AudioMicMute&amp;quot;&amp;gt;
      &amp;lt;action name=&amp;quot;Execute&amp;quot; command=&amp;quot;pactl set-source-mute @DEFAULT_SOURCE@ toggle&amp;quot; /&amp;gt;
    &amp;lt;/keybind&amp;gt;
    &amp;lt;keybind key=&amp;quot;XF86MonBrightnessDown&amp;quot;&amp;gt;
      &amp;lt;action name=&amp;quot;Execute&amp;quot; command=&amp;quot;brightnessctl set 5%-&amp;quot; /&amp;gt;
    &amp;lt;/keybind&amp;gt;
    &amp;lt;keybind key=&amp;quot;XF86MonBrightnessUp&amp;quot;&amp;gt;
      &amp;lt;action name=&amp;quot;Execute&amp;quot; command=&amp;quot;brightnessctl set 5%+&amp;quot; /&amp;gt;
    &amp;lt;/keybind&amp;gt;
    &amp;lt;keybind key=&amp;quot;W-s&amp;quot;&amp;gt;
      &amp;lt;action name=&amp;quot;Execute&amp;quot; command=&amp;quot;wofi --show=drun -I --gtk-dark -x 0 -y 324 -W 300 -H 600 -p &#39;请输入软件名称&#39;&amp;quot; /&amp;gt;
    &amp;lt;/keybind&amp;gt;
    &amp;lt;keybind key=&amp;quot;W-q&amp;quot;&amp;gt;
      &amp;lt;action name=&amp;quot;Execute&amp;quot; command=&amp;quot;firefox-esr&amp;quot; /&amp;gt;
    &amp;lt;/keybind&amp;gt;
    &amp;lt;keybind key=&amp;quot;W-e&amp;quot;&amp;gt;
      &amp;lt;action name=&amp;quot;Execute&amp;quot; command=&amp;quot;thunar&amp;quot; /&amp;gt;
    &amp;lt;/keybind&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;106&#34;&gt;10.6 开机启动设置&lt;/h4&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;nano autostart

# 背景设置
swaybg -i &#39;/home/poo/图片/3.jpg&#39; &amp;gt;/dev/null 2&amp;gt;&amp;amp;1 &amp;amp;

fcitx5 &amp;gt;/dev/null 2&amp;gt;&amp;amp;1 &amp;amp;
blueman-applet &amp;gt;/dev/null 2&amp;gt;&amp;amp;1 &amp;amp;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;107-foot&#34;&gt;10.7. 设置终端(foot)字体大小&lt;/h4&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;cp -r /etc/foot/ ~/.config/foot/
vi ~/.config/foot/foot.ini

font=monospace:size=12
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;108-kanshi&#34;&gt;10.8. 设置kanshi&lt;/h4&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;mkdir -p ~/.config/kanshi
nano config

# 缩放1.25
profile nomad {
    output eDP-1 enable scale 1.25
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;11-wayfire&#34;&gt;11. wayfire窗口管理器设置&lt;/h3&gt;
&lt;h4 id=&#34;111-wayfire&#34;&gt;11.1. 安装wayfire及相关软件&lt;/h4&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;sudo apt install wayfire swaybg swayidle swaylock fcitx5 fcitx5-rime rime-data-wubi thunar xarchiver pipewire-audio blueman thunar-archive-plugin fonts-noto-cjk xfce4-terminal xfce4-appfinder seatd xwayland git brightnessctl firefox-esr mako-notifier
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;112-wayfire&#34;&gt;11.2. 启动wayfire&lt;/h4&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;# 编辑 ~/.profile加入以下内容即可：

if [ -z &amp;quot;$DISPLAY&amp;quot; ] &amp;amp;&amp;amp; [ &amp;quot;$(tty)&amp;quot; = &amp;quot;/dev/tty1&amp;quot; ]; then
  exec wayfire
fi
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;113-wayfire&#34;&gt;11.3. wayfire&lt;/h4&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;cp /usr/share/wayfire/examples/wayfire.ini ~/.config/wayfire.ini
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;114&#34;&gt;11.4. 输入法环境变量设置&lt;/h3&gt;
&lt;p&gt;启用fcitx输入需要配置环境变量：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;nano /etc/environment

XIM=&amp;quot;fcitx&amp;quot;
#GTK_IM_MODULE=fcitx
QT_IM_MODULE=fcitx
XMODIFIERS=&amp;quot;@im=fcitx&amp;quot;
INPUT_METHOD=fcitx
SDL_IM_MODULE=fcitx
GLFW_IM_MODULE=fcitx
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;115-foot&#34;&gt;11.5. 设置终端(foot)字体大小&lt;/h3&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;cp -r /etc/foot/ ~/.config/foot/
vi ~/.config/foot/foot.ini

# 也可以直接在/etc/foot/foot.ini中修改
font=monospace:size=12
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;12-rime&#34;&gt;12. rime输入法设置&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;fcitx5-rime&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;sudo apt install fcitx5-rime rime-data-wubi
nano ~/.local/share/fcitx5/rime/default.custom.yaml
patch:
  schema_list:
    - schema: wubi_pinyin
    - schema: luna_pinyin_simp
    - schema: wubi86
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;ibus-rime&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;sudo apt install ibus-rime rime-data-wubi
nano ~/.config/ibus/rime/default.custom.yaml
patch:
  schema_list:
    - schema: wubi_pinyin
    - schema: luna_pinyin_simp
    - schema: wubi86

nano ~/.config/ibus/rime/build/ibus_rime.yaml

# 修改ibus_rime.yaml中horizontal为true

style:
   horizontal: true
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;wayland下xwayland程序fcitx输入法支持，需要配置环境变量：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;nano /etc/environment

XIM=&amp;quot;fcitx&amp;quot;
#GTK_IM_MODULE=fcitx
QT_IM_MODULE=fcitx
XMODIFIERS=&amp;quot;@im=fcitx&amp;quot;
INPUT_METHOD=fcitx
SDL_IM_MODULE=fcitx
GLFW_IM_MODULE=fcitx
&lt;/code&gt;&lt;/pre&gt;</description>  
      <pubDate>2025-10-09 17:54:40</pubDate>  
      <link>https://testpoo.github.io/debian安装设置.html</link>  
      <guid isPermaLink="true">https://testpoo.github.io/debian安装设置.html</guid>
       
      <category>系统安装</category> 
      
    </item>
    
    <item> 
      <title>意义完全相反的名言谚语</title>  
      <description>&lt;blockquote&gt;
&lt;p&gt;来源于网络搜集&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;俗话说：兔子不吃窝边草；可俗话又说：近水楼台先得月!&lt;/li&gt;
&lt;li&gt;俗话说：宰相肚里能撑船；可俗话又说：有仇不报非君子!&lt;/li&gt;
&lt;li&gt;俗话说：人不犯我，我不犯人；可俗话又说：先下手为强，后下手遭殃!&lt;/li&gt;
&lt;li&gt;俗话说：男子汉大丈夫，宁死不屈；可俗话又说：男子汉大丈夫，能屈能伸!&lt;/li&gt;
&lt;li&gt;俗话说：打狗还得看主人；可俗话又说：杀鸡给猴看!&lt;/li&gt;
&lt;li&gt;俗话说：知无不言，言无不尽；可俗话又说：交浅勿言深，沉默是金!&lt;/li&gt;
&lt;li&gt;俗话说：车到山前必有路；可俗话又说：不撞南墙不回头!&lt;/li&gt;
&lt;li&gt;俗话说：条条大路通罗马；可俗话又说：一条道走到黑!&lt;/li&gt;
&lt;li&gt;俗话说：礼轻情谊重；可俗话又说：礼多人不怪!&lt;/li&gt;
&lt;li&gt;俗话说：人多力量大；可俗话又说：人多嘴杂!&lt;/li&gt;
&lt;li&gt;俗话说：买卖不成仁义在；可俗话又说：亲兄弟，明算帐!&lt;/li&gt;
&lt;li&gt;俗话说：一个好汉三个帮；可俗话又说：靠人不如靠己!&lt;/li&gt;
&lt;li&gt;俗话说：人往高处走；可俗话又说：爬得高，摔得重!&lt;/li&gt;
&lt;li&gt;俗话说：一口唾沫一个钉；可俗话又说：人嘴两张皮，咋说咋有理!&lt;/li&gt;
&lt;li&gt;俗话说：知识要有产权；俗话又说：不分享心里不安!&lt;/li&gt;
&lt;li&gt;俗话说：亡羊补牢，未为迟也；可俗话又说：亡羊补牢，为时已晚！&lt;/li&gt;
&lt;li&gt;俗话说：瘦死的骆驼比马大；可俗话又说：拔了毛的凤凰不如鸡！&lt;/li&gt;
&lt;li&gt;俗话说：宁可玉碎，不能瓦全；可俗话又说：留得青山在，不怕没柴烧！&lt;/li&gt;
&lt;li&gt;俗话说：人不可貌相，海水不可斗量；可俗话又说：人靠衣裳马靠鞍！&lt;/li&gt;
&lt;li&gt;俗话说：浪子回头金不换；可俗话又说：狗改不了吃屎！&lt;/li&gt;
&lt;li&gt;俗话说：苦海无边，回头是岸；可俗话又说：开弓没有回头箭！&lt;/li&gt;
&lt;li&gt;俗话说：退一步海阔天空；可俗话又说：狭路相逢勇者胜！&lt;/li&gt;
&lt;li&gt;俗话说：三百六十行，行行出状元；可俗话又说：万般皆下品，唯有读书高！&lt;/li&gt;
&lt;li&gt;俗话说：书到用时方恨少；可俗话又说：百无一用是书生！&lt;/li&gt;
&lt;li&gt;俗话说：金钱不是万能的；可俗话又说：有钱能使鬼推磨！ &lt;/li&gt;
&lt;li&gt;俗话说：天无绝人之路；可俗话又说：天网恢恢，疏而不漏！&lt;/li&gt;
&lt;li&gt;俗话说：出淤泥而不染；可俗话又说：近朱者赤，近墨者黑！ &lt;/li&gt;
&lt;li&gt;俗话说：捉贼捉赃，捉奸捉双；可俗话又说：欲加之罪，何患无辞！&lt;/li&gt;
&lt;li&gt;俗话说：贫贱不能移！可俗话又说：人贫志短，马瘦毛长！&lt;/li&gt;
&lt;li&gt;俗话说：青取之于蓝而胜于蓝；可俗话又说：姜还是老的辣！&lt;/li&gt;
&lt;li&gt;俗话说：后生可畏；可俗话又说：嘴上无毛、办事不牢！&lt;/li&gt;
&lt;li&gt;俗话说：有缘千里来相会；可俗话又说：不是冤家不聚头！&lt;/li&gt;
&lt;li&gt;俗话说：在天愿作比翼鸟，在地愿为连理枝；可俗话又说：夫妻本是同林鸟，大难来时各自飞！&lt;/li&gt;
&lt;li&gt;俗话说：得饶人处且饶人；可俗话又说：纵虎归山，后患无穷！&lt;/li&gt;
&lt;li&gt;俗话说：善有善报，恶有恶报；话又说：人善被人欺，马善被人骑！&lt;/li&gt;
&lt;li&gt;俗话说：一分耕耘、一分收获；可俗话又说：人无横财不富、马无夜草不肥！&lt;/li&gt;
&lt;li&gt;俗话说：小心驶得万年船；可俗话又说：撑死胆大的，饿死胆小的！&lt;/li&gt;
&lt;li&gt;俗话说：量小非君子；可俗话又说：无毒不丈夫！&lt;/li&gt;
&lt;li&gt;俗话说：一寸光阴一寸金；可俗话又说：寸金难买寸光阴！&lt;/li&gt;
&lt;li&gt;俗话说：日久见人心；可俗话又说：人心隔肚皮！&lt;/li&gt;
&lt;li&gt;俗话说：光阴似箭；可俗话又说：度日如年！&lt;/li&gt;
&lt;li&gt;俗话说：己所不欲，勿施于人；可俗话又说：顺我者昌，逆我者亡！&lt;/li&gt;
&lt;li&gt;俗话说：邪不压正；可俗话又说：道高一尺，魔高一丈！&lt;/li&gt;
&lt;li&gt;俗话说：小不忍则乱大谋；可俗话又说：不蒸馒头蒸(争)口气！&lt;/li&gt;
&lt;li&gt;俗话说：人人为我，我为人人；可俗话又说：人不为己，天诛地灭！&lt;/li&gt;
&lt;li&gt;俗话说：不怕人不敬，就怕己不正；可俗话又说：众口烁金，积毁销骨！&lt;/li&gt;
&lt;li&gt;俗话说：三个臭皮匠，胜过诸葛亮；可俗话又说：一个和尚挑水喝，两个和尚抬水喝，三个和尚没水喝！&lt;/li&gt;
&lt;li&gt;俗话说：不入虎穴，焉得虎子；可俗话又说：老虎屁股摸不得！&lt;/li&gt;
&lt;li&gt;俗话说：百事孝为先；可俗话又说：忠孝不能两全！&lt;/li&gt;
&lt;li&gt;俗话说：人无远虑，必有近忧；可俗话又说：今朝有酒今朝醉！&lt;/li&gt;
&lt;li&gt;俗话说：家事国事天下事，事事关心；可俗话又说：老婆孩子热炕头！&lt;/li&gt;
&lt;li&gt;俗话说：人定胜天；可俗话又说：天意难违！&lt;/li&gt;
&lt;li&gt;俗话说：愚公移山；可俗话又说：胳膊拧不过大腿！&lt;/li&gt;
&lt;li&gt;俗话说：哪里跌倒哪里爬起；可俗话又说：一失足成千古恨！&lt;/li&gt;
&lt;li&gt;俗话说：路不平有人铲，事不平有人管；可俗话又说：自家扫取门前雪，莫管他人屋上霜！ &lt;/li&gt;
&lt;li&gt;俗话说：滴水之恩当涌泉相报！可俗话又说：过河拆桥、卸磨杀驴、兔死狗烹、鸟尽弓藏！&lt;/li&gt;
&lt;li&gt;俗话说：双喜临门；可俗话又说：福无双进，祸不单行！&lt;/li&gt;
&lt;li&gt;俗话说：人挪活，树挪死；可俗话又说：滚石不生苔，转业不生财！&lt;/li&gt;
&lt;li&gt;俗话说：嫁鸡随鸡，嫁狗随狗；可俗话又说：男怕选错行，女怕嫁错郎！&lt;/li&gt;
&lt;li&gt;俗话说：明人不做暗事；可俗话又说：兵不厌诈！&lt;/li&gt;
&lt;/ol&gt;</description>  
      <pubDate>2025-10-09 17:54:40</pubDate>  
      <link>https://testpoo.github.io/意义完全相反的名言谚语.html</link>  
      <guid isPermaLink="true">https://testpoo.github.io/意义完全相反的名言谚语.html</guid>
       
      <category>摘录</category> 
      
    </item>
    
    <item> 
      <title>英耀赋</title>  
      <description>&lt;blockquote&gt;
&lt;p&gt;来源于网络搜集&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;入门先观来意，既开言切莫踌躇，天来问追欲追贵，追来问天为天忧。 八问七，喜者欲凭子贵，怨者实为生孙近古。 叠叠问此件，定然此件缺，频频问原因，其中定有因。 一片真诚，百说慕名求教，此人乃是一哥，笑问看我贱相如何？此人若非火底就是畜生。&lt;/p&gt;
&lt;p&gt;砂砾丛中辨金石，衣冠队内别鱼龙，僧道纵清高不忘利欲，庙廊之士志在山林，初贵者志极高超，久困者志无远大，聪明之子家业常寒，百拙之夫财终不匮。眉精眼锐，白手兴家之人，碌碌无能，终生工水之辈。破落户穷极不离鞋袜，初发家初起好炫金饰。神暗额光，不是孤孀亦弃妇，妖婆媚笑，倘非花底定宠姬。满口好对好，久居高位，连声是是是，出身卑微。&lt;/p&gt;
&lt;p&gt;面带笑容，而心神不定，家有祸争，招子闪烁，而故作安祥，祸发自身。好勇斗狠，多遭横祸。怯懦无能，常受人欺。志大才疏，终生咄咄空抱恨。才偏性执，不遭大祸亦奇穷。治世重文学之臣，乱世发草莽英雄。通商大邑竞工商，穷乡僻壤争林田。
急打慢千，轻敲响卖，隆卖齐施，敲打审千并用，十千九响，十隆十成，敲其天，而推其比，审其一而知其三，一敲即应，不妨打蛇随棍上，再敲不吐，何仿拨草寻蛇，先千后隆，无往不利，有千无隆，帝寿之材，故曰无千不响，无隆不成，学者可执其端，而理其绪，举一隅而知三隅，随机应变，鬼神莫测，分寸己定，任意纵横，慎重传人，不出帝寿，斯篇玩熟，定教四海扬名。&lt;/p&gt;
&lt;p&gt;入门先观来意，出言先要拿心。先千后隆，乃兵家之妙法。轻敲响卖，是江湖之秘宗。有问不可迟答，无言切勿先声。谈男命，先千后隆，谈女命，先隆后千。人人后运好，个个子孙贤。三五成群，须防有假。嘻呵成，必定无心。来意殷勤，前运必非好景。言词高傲，近来必定佳途。&lt;/p&gt;
&lt;p&gt;言不可多，言多必败。千不可极，千极必隆。父年高而母年细，定必偏生庶出。己年细妻年高，当然苟合私逃。子年与妻年仿佛，非填房定偏室坐正。父年与己年相等，不是过继定螟蛉。老年问子，虽多亦寡，忧愁可断。少年问子，虽有亦女，立即分清。早娶妻之人，父业可卜。迟立室者，祖业凋零。当家早，父必先丧。当家迟，父命延长。少年问亲娘，有病在牙床。老父问娇儿，定必子孙稀。&lt;/p&gt;
&lt;p&gt;来意神清，定必无心谈事。出言心乱，定当有意问灾凶。少年过于奢华，其人必然浪子。老人过于朴实，此辈定是愚人。年嫩志诚，千金可托之肖子。老来白霍，万事无成之鄙夫。男儿问娼女，此乃终日谈烟花之俗子。妇人问翁姑，其人固念病体忧愁之贤女。男人身配独锁匙，未断有室。妇人襟头常带乳，不是无儿。&lt;/p&gt;
&lt;p&gt;气滞神枯，斯人现困境，谋事十谋九凶。色润声高，此子近处吉祥，十成九就。入门两目流连，必多心而无专一。身摇浪定，定小相而带轻浮。衣服朴而洁，铜匙坠带，生意场中之能人，可卜权衡早创。履华而整，银圆满袋，游乐场上之浪子，当决家业将倾。田园近有，定卜先贫而后富。家业变尽，必然先富后贫。&lt;/p&gt;
&lt;p&gt;少年赞他寿长，老人许加福泽。恶人勿言恶，只许傍借而此，隆千齐下。善人当言善，反正而说福寿同施。中年发业兴家，此人善营善作。老来一筹莫展，是老失运失时。远客异方，祖宗每多富贵。近营内地，可断兄弟贫穷。&lt;/p&gt;
&lt;p&gt;小人宜以正直义气隆他，万无一失。君子当以诚谨俭让临之，百次皆同。得英切勿尽吐，该防真里有假。失英最忌即兜，留心实内藏虚。见水切宜用意，不可露轻视鄙贱之心。过火理当谨慎，最好看定方向开言。刚柔并用，拷夹齐施，有千有隆。携琴祖宗有隆有千，火响连天。坐立顶正大，言语要庄严，军马不可尽出，声气定要相连。淡定吞吐，得意不宜再往。言词锋利、失之不可复言。声响视正君子相，目横语乱小人形。&lt;/p&gt;
&lt;p&gt;男女同来，分清老少亲戚方可断。单身再问，审定方向形势始能言。寡妇询去留，定思重配。老媪多叹息，受屈难言。病询自身，虽佑亦宜慢泄。老询寿元，未可即断死亡。有子而寡，宜劝守节，将来必有好景。无儿问去，当要著其别栖为高。&lt;/p&gt;
&lt;p&gt;此乃看其人之年岁为立言。童儿身上，反复追寻，前儿难养。老大问自身，查寿元，现有病符。瞻前顾后，必当高声唱问，以定其身。拉衣牵裙，定要暗里藏讥，以求其实。&lt;/p&gt;
&lt;p&gt;十六七之少女问男，春情己动，异性亦然。五六十之老翁问女，冬雪既降，同偶何嫌。因人情而谈世故，忖心理以顺开言。俏遇硬鼻高头，千中带夹。&lt;/p&gt;
&lt;p&gt;不受则隆。隆而吐则可，不吐连消带打，高声呼喝。千他古运将来，使其惊心动魄，言语要真诚。若逢低首浅笑，隆中带打，不声则千。千而吐则可，不吐要逐路微拷。低语讲话，隆其苦尽甘来，使其扬眉喜气，言语要温柔。&lt;/p&gt;
&lt;p&gt;男子入门，志气轩昂，袒胸露臂，高谈雄辩，非军政之徒定是捞家之辈。每要留心讲解，恐失言以招灾。女子进来，言柔步淡，低头羞答，非闺秀之人，定名门之女，为势必听。我军马须从容，旁敲侧引。视同来而眨眼，恐非有意寻求。对自己作疏言，未必无心试探。非得真英，不可落军马。须防马失前蹄。&lt;/p&gt;
&lt;p&gt;眼观四面，耳听八方，坐立必要端方。军马出须坚定，切忌浮言乱言，又忌俗语虚言。先用人品涤荡一番，英耀未到，军马单刀直入，自然马到功成。&lt;/p&gt;
&lt;p&gt;但论叩经叩策之法，如官府升堂审案，必要寻根寻鸿。一层一层，至紧深究根底。祸福此法，如入大座高楼，由浅入深，由轻至重。大概论之。至紧问自身日后，次开谋望新花，次家宅占病，亦宜挨入自身可决。&lt;/p&gt;
&lt;p&gt;断自身之法，人生品行，一世好运丑运，可为议论。亦要在自身入脉，可能知得内里因由。大约之法，如行兵调将，务要随机应变，仔细留心，不能一概而论。真乃变化无穷也。&lt;/p&gt;
&lt;p&gt;古人云，出人头地，须用苦心。工夫后学必要常常念熟，自有进步。书云，学而不思则妄，思而不学则怠。凡间更新守旧，必定夹定男女。&lt;/p&gt;
&lt;p&gt;若男问必生意打工求财。若女问恐入八复飞。必要一一夹清。见生意，启军马，必须镇定。&lt;/p&gt;
&lt;p&gt;贪者必贪，君子引为大戒，佛门亦为五戒之首，故做阿宝者的罪过，咎不在相而在一。&lt;/p&gt;
&lt;p&gt;贪官者，民贼也，好商者，民橐也，豪强者，民之虎狼也，其或以知欺愚，恃强凌弱，欺人孤寡，谋人财产，此皆不义之财也，不义之财理无久享，不报自身，亦报儿孙，不义之财，人人皆得而取之，故曰做阿宝者，非千也，愿天之罚而已。&lt;/p&gt;
&lt;p&gt;凡做阿宝，博观而取之，慎始更慎终，未算其利，先防其弊，未置梗媒，先放生媒，故善为相者，取之不竭其力，不伤其根，上顺天理，下怏人心，并使之有所畏怯而不敢言。不善相者，竭一之力，伤之一内，取非不义之财，上违天理，下招人怨，非吾徒也，小子鸣鼓而攻之可也！&lt;/p&gt;
&lt;p&gt;凡一皆可札飞也，君子敬鬼神而远之，小人畏神鬼而陷之，或求妻财子禄，或畏疾病灾祸，非有所惧，即有所求，察其所惧，观其所求，而善用军马，则一无不唯命是从，故曰：“我求他，不能他求我。”&lt;/p&gt;
&lt;p&gt;札飞之术，贵在多方，幻其真耶，神化莫测，小验然后大响，众信而后大成，鬼神无凭，唯人是依。一犬吠形，百犬吠声，众口烁金，曾参杀人，虽明智之士齐所疑惑，何况一哉。善为相者，莫不善用甲媒，故曰：“无媒不响，无媒不成。&lt;/p&gt;</description>  
      <pubDate>2025-10-09 17:54:40</pubDate>  
      <link>https://testpoo.github.io/英耀赋.html</link>  
      <guid isPermaLink="true">https://testpoo.github.io/英耀赋.html</guid>
       
      <category>摘录</category> 
      
    </item>
    
    <item> 
      <title>使用tar包安装mysql</title>  
      <description>&lt;div class=&#34;toc&#34;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1mysql&#34;&gt;1.官网下载mysql&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2&#34;&gt;2. 添加用户&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3&#34;&gt;3.上传到服务器解压&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4&#34;&gt;4.创建数据目录并赋予权限&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5&#34;&gt;5.修改配置文件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#6&#34;&gt;6. 初始化&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#7mysql&#34;&gt;7.启动mysql&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#8&#34;&gt;8.查看密码&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#9&#34;&gt;9.修改密码&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#10&#34;&gt;10.报错&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;p&gt;文章来源：&lt;a href=&#34;https://blog.csdn.net/wang20010104/article/details/142485238&#34;&gt;https://blog.csdn.net/wang20010104/article/details/142485238&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;1mysql&#34;&gt;1.官网下载mysql&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://downloads.mysql.com/archives/community/&#34;&gt;https://downloads.mysql.com/archives/community/&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;2&#34;&gt;2. 添加用户&lt;/h3&gt;
&lt;p&gt;先检查是否有mysql用户组和mysql用户,没有就添加有就忽略：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;groups mysql
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;nbsp;添加用户组和用户&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;groupadd mysql &amp;amp;&amp;amp; useradd -r -g mysql mysql
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;3&#34;&gt;3.上传到服务器解压&lt;/h3&gt;
&lt;p&gt;解压tar包&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;tar -zxvf mysql-5.7.44-linux-glibc2.12-x86_64.tar.gz
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将解压后的包改名为mysql，这样更加简易（也可不改）&lt;/p&gt;
&lt;p&gt;将mysql目录包移动到/usr/local/，并赋予mysql用户权限&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;chown mysql:mysql -R mysql
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;4&#34;&gt;4.创建数据目录并赋予权限&lt;/h3&gt;
&lt;p&gt;此为mysql存放数据地方，可设置内存较多的磁盘&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;mkdir -p /data/mysql
chown mysql:mysql -R /data/mysql
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;5&#34;&gt;5.修改配置文件&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;vim /etc/my.cnf&lt;/code&gt;（没有就新建）&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-XML&#34;&gt;[mysqld]
#skip-grant-tables
lower_case_table_names=1
bind-address = 0.0.0.0
port=3306
basedir=/usr/local/mysql
datadir=/data/mysql
socket=/tmp/mysql.sock
log-error=/data/mysql/mysql.err
pid-file=/data/mysql/mysql.pid
symbolic-links=0
character_set_server=utf8mb4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个MySQL配置文件通常位于&lt;code&gt;my.cnf&lt;/code&gt;或&lt;code&gt;my.ini&lt;/code&gt;文件中，具体取决于操作系统。包含了多个关键的设置，用于控制MySQL服务器的行为。下面是对这些设置的解释：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;#skip-grant-tables&lt;/code&gt;&lt;/strong&gt;: 这一行被注释掉了（因为它前面有一个&lt;code&gt;#&lt;/code&gt;号），意味着这个选项没有被启用。&lt;code&gt;skip-grant-tables&lt;/code&gt;选项通常用于紧急情况，允许任何用户无需密码即可连接到MySQL服务器，但这会禁用所有的权限检查。由于安全风险，通常不建议在生产环境中使用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;lower_case_table_names=1&lt;/code&gt;&lt;/strong&gt;: 这个设置指定了MySQL在存储表名时应如何区分大小写。设置为&lt;code&gt;1&lt;/code&gt;时，MySQL在Linux系统上也会将表名以小写形式存储在磁盘上，并且查询时不区分大小写。这对于跨平台的数据库迁移非常有用，因为Windows系统默认不区分大小写，而Linux系统默认区分。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;bind-address = 0.0.0.0&lt;/code&gt;&lt;/strong&gt;: 这个设置允许MySQL服务器监听所有IPv4地址上的连接。这意呀着MySQL可以接受来自任何IP地址的连接请求，这在需要将MySQL服务器设置为可从远程访问时非常有用。但请注意，出于安全考虑，应确保通过防火墙规则或MySQL的&lt;code&gt;user&lt;/code&gt;表中的权限设置来限制哪些IP地址可以访问MySQL服务器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;port=3306&lt;/code&gt;&lt;/strong&gt;: 这个设置指定了MySQL服务器监听的端口号。默认情况下，MySQL服务器使用3306端口。如果需要更改此端口号，可以在这里进行设置。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;basedir=/usr/local/mysql&lt;/code&gt;&lt;/strong&gt;: 这个设置指定了MySQL安装的基础目录。MySQL服务器会从这个目录加载其可执行文件和库文件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;datadir=/data/mysql&lt;/code&gt;&lt;/strong&gt;: 这个设置指定了MySQL数据文件的存储目录。所有的数据库、表和其他相关数据都将存储在这个目录下。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;socket=/tmp/mysql.sock&lt;/code&gt;&lt;/strong&gt;: 当MySQL客户端和服务器在同一台机器上运行时，它们可以通过UNIX域套接字进行通信，而不是通过网络套接字。这个设置指定了套接字的路径。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;log-error=/data/mysql/mysql.err&lt;/code&gt;&lt;/strong&gt;: 这个设置指定了MySQL服务器错误日志文件的路径。如果服务器在运行时遇到错误，错误信息将被写入这个文件中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;pid-file=/data/mysql/mysql.pid&lt;/code&gt;&lt;/strong&gt;: 这个设置指定了MySQL服务器进程ID（PID）文件的路径。该文件包含了MySQL服务器主进程的ID，可以用来监控或杀死MySQL服务器进程。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;symbolic-links=0&lt;/code&gt;&lt;/strong&gt;: 这个设置禁用了MySQL服务器中的符号链接。由于安全原因，通常不建议使用符号链接。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;character_set_server=utf8mb4&lt;/code&gt;&lt;/strong&gt;: 这个设置指定了MySQL服务器的默认字符集为&lt;code&gt;utf8mb4&lt;/code&gt;。&lt;code&gt;utf8mb4&lt;/code&gt;是&lt;code&gt;utf8&lt;/code&gt;的超集，支持更多的Unicode字符，包括一些特殊的表情符号（emoji）。使用&lt;code&gt;utf8mb4&lt;/code&gt;可以确保数据库能够存储和处理更广泛的字符集。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;6&#34;&gt;6. 初始化&lt;/h3&gt;
&lt;p&gt;解压后的mysql-5.7.44-linux-glibc2.12-x86_64移动到/usr/local/mysql （文件夹名称修改为mysql不带版本号信息）&lt;/p&gt;
&lt;p&gt;移动后初始化mysql&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;cd /usr/local/mysql/bin/
&lt;/code&gt;&lt;/pre&gt;

&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;./mysqld --defaults-file=/etc/my.cnf --basedir=/usr/local/mysql/ --datadir=/data/mysql/ --user=mysql --initialize
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;7mysql&#34;&gt;7.启动mysql&lt;/h3&gt;
&lt;p&gt;进入到启动mysql的目录下&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;cd /usr/local/mysql/support-files/
&lt;/code&gt;&lt;/pre&gt;

&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;./mysql.server start
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;8&#34;&gt;8.查看密码&lt;/h3&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;cat /data/mysql/mysql.err
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里可以看到临时密码&lt;/p&gt;
&lt;h3 id=&#34;9&#34;&gt;9.修改密码&lt;/h3&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;./mysql -u root -p
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输入临时密码登录登录，修改密码为1234&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;1234&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;刷新&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;FLUSH PRIVILEGES;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看发现只有本地可访问，修改可访问的主机为所有&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;update mysql.user set host = &#39;%&#39; where user =&#39;root&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再次查看发现修改成功，同时刷新&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;FLUSH PRIVILEGES;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;10&#34;&gt;10.报错&lt;/h3&gt;
&lt;p&gt;如果连接mysql报错，以使用命令查看错误，可见有的为空&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;ldd /usr/local/mysql/bin/mysql
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;缺少什么安装什么即可&lt;/p&gt;</description>  
      <pubDate>2025-10-09 17:54:40</pubDate>  
      <link>https://testpoo.github.io/使用tar包安装mysql.html</link>  
      <guid isPermaLink="true">https://testpoo.github.io/使用tar包安装mysql.html</guid>
       
      <category>技术</category> 
      
    </item>
    
    <item> 
      <title>安装docker-swarm</title>  
      <description>&lt;div class=&#34;toc&#34;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1debiandocker&#34;&gt;1.Debian下安装docker依赖&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2dockerubuntu&#34;&gt;2.安装证书，docker官网访问不了，用ubuntu的，网络不行，多试几次&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3docker&#34;&gt;3.添加docker清华源&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4docker&#34;&gt;4.安装docker&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5-docker-swarm&#34;&gt;5.初始化 Docker Swarm 集群&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#51-swarm&#34;&gt;5.1 选择一台主机作为管理节点，在该主机上执行以下命令初始化 Swarm 集群：&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#52&#34;&gt;5.2 添加工作节点&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#53-swarm&#34;&gt;5.3 验证 Swarm 集群&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#6mysql&#34;&gt;6.安装mysql服务&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#61-mysql&#34;&gt;6.1 拉取 MySQL 镜像&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#62-overlay&#34;&gt;6.2 创建网络(overlay)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#63-mysql&#34;&gt;6.3 创建 MySQL 服务&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#64&#34;&gt;6.4 验证服务是否正常运行&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#7mysql&#34;&gt;7.安装mysql客户端&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#71-mysql&#34;&gt;7.1 拉取 MySQL 镜像&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#72-overlay&#34;&gt;7.2 创建网络(overlay)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#73-mysql-client&#34;&gt;7.3 创建 MySQL Client 服务&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#8-docker-swarm&#34;&gt;8. Docker Swarm 集群环境删除服务&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#9-docker&#34;&gt;9. 进入docker&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h3 id=&#34;1debiandocker&#34;&gt;1.Debian下安装docker依赖&lt;/h3&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;apt install apt-transport-https ca-certificates curl gnupg2 software-properties-common -y
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2dockerubuntu&#34;&gt;2.安装证书，docker官网访问不了，用ubuntu的，网络不行，多试几次&lt;/h3&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;gpg --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys 7EA0A9C3F273FCD8
gpg --export 7EA0A9C3F273FCD8 | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;3docker&#34;&gt;3.添加docker清华源&lt;/h3&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;echo &amp;quot;deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/debian $(lsb_release -cs) stable&amp;quot; | sudo tee /etc/apt/sources.list.d/docker.list &amp;gt; /dev/null
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;4docker&#34;&gt;4.安装docker&lt;/h3&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;apt install docker-ce docker-ce-cli containerd.io -y
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;5-docker-swarm&#34;&gt;5.初始化 Docker Swarm 集群&lt;/h3&gt;
&lt;h4 id=&#34;51-swarm&#34;&gt;5.1 选择一台主机作为管理节点，在该主机上执行以下命令初始化 Swarm 集群：&lt;/h4&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;docker swarm init --advertise-addr 192.168.214.34
===============================================================================
Swarm initialized: current node (************************) is now a manager.

To add a worker to this swarm, run the following command:

    docker swarm join --token SWMTKN-1-************************************************ 192.168.214.34:2377

To add a manager to this swarm, run &#39;docker swarm join-token manager&#39; and follow the instructions.
===============================================================================
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;52&#34;&gt;5.2 添加工作节点&lt;/h4&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;docker swarm join --token SWMTKN-1-************************************************ 192.168.214.34:2377

重新加入swarm
docker swarm join-token manager # 管理节点
docker swarm join-token worker  # 工作节点
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;53-swarm&#34;&gt;5.3 验证 Swarm 集群&lt;/h4&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;docker node ls
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;6mysql&#34;&gt;6.安装mysql服务&lt;/h3&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;# 添加清华源
sudo nano /etc/docker/daemon.json

{
    &amp;quot;registry-mirrors&amp;quot;: [&amp;quot;https://docker.mirrors.tuna.tsinghua.edu.cn&amp;quot;]
}

systemctl restart docker
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;61-mysql&#34;&gt;6.1 拉取 MySQL 镜像&lt;/h4&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;docker pull mysql:8.0  # 直接拉取镜像

docker pull docker.mirrors.tuna.tsinghua.edu.cn/library/mysql:8.0  # 通过清华源拉取镜像

docker save -o xvlan-mysql.tar sicap-repo.com/library/mysql:5.7.43  # 从SiCAP导出一个  # 从别的地方导出一个镜像
docker load -i /home/poo/xvlan-mysql.tar  # 导入镜像
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;62-overlay&#34;&gt;6.2 创建网络(overlay)&lt;/h4&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;# 在管理节点上执行以下命令来创建一个网络
docker network create -d overlay mysql-net

# 参数说明：-d overlay：指定网络驱动为 overlay，这是 Docker Swarm 用于跨节点通信的网络类型。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;63-mysql&#34;&gt;6.3 创建 MySQL 服务&lt;/h4&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;docker service create \
  --name mysql-service \
  --network mysql-net \
  -e MYSQL_ROOT_PASSWORD=123456 \
  -p 3306:3306 \
  --mount type=volume,source=mysql-data,target=/var/lib/mysql \
sicap-repo.com/library/mysql:5.7.43

# 参数说明：
# --name mysql-service：为服务指定名称，这里是 mysql-service。
# --network mysql-net：将服务连接到之前创建的 mysql-net 网络。
# -e MYSQL_ROOT_PASSWORD=your_password：设置 MySQL 的 root 用户密码，你需要将 your_password 替换为实际密码。
# -p 3306:3306：将容器内的 3306 端口映射到宿主机的 3306 端口，以便外部可以访问 MySQL 服务。
# --mount type=volume,source=mysql-data,target=/var/lib/mysql：使用 Docker 卷 mysql-data 进行数据持久化，将其挂载到容器内的 /var/lib/mysql 目录，该目录是 MySQL 存储数据的默认位置。
# mysql:8.0：指定使用的 MySQL 镜像版本。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;64&#34;&gt;6.4 验证服务是否正常运行&lt;/h4&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;docker service ls
docker service ps mysql-service
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;7mysql&#34;&gt;7.安装mysql客户端&lt;/h3&gt;
&lt;h4 id=&#34;71-mysql&#34;&gt;7.1 拉取 MySQL 镜像&lt;/h4&gt;
&lt;p&gt;同6.1&lt;/p&gt;
&lt;h4 id=&#34;72-overlay&#34;&gt;7.2 创建网络(overlay)&lt;/h4&gt;
&lt;p&gt;同6.2&lt;/p&gt;
&lt;h4 id=&#34;73-mysql-client&#34;&gt;7.3 创建 MySQL Client 服务&lt;/h4&gt;
&lt;p&gt;在管理节点上执行以下命令来创建一个临时的 MySQL Client 服务，以连接到 MySQL 数据库：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;docker service create \
    --name mysql-client-service \
    --network mysql-net \
    --mode replicated \
    --replicas 1 \
    --constraint &amp;quot;node.role==worker&amp;quot; \
    sicap-repo.com/library/mysql:5.7.43 \
    mysql -h 192.168.214.34 -P 3306 -u root -p123456

docker service create \
    --name mysql-client-service \
    --network mysql-net \
    sicap-repo.com/library/mysql:5.7.43 \
    mysql -h 192.168.214.35 -P 3306 -u root -p123456

# 参数解释：
# --name mysql-client-service：为服务指定名称，便于后续管理。
# --network mysql-net：将服务连接到之前创建的 Overlay 网络。
# --mode replicated：指定服务模式为副本模式，即创建多个相同的副本。
# --replicas 1：设置副本数量为 1，即只创建一个 MySQL Client 实例。
# --constraint &amp;quot;node.role==worker&amp;quot;：约束服务只能在工作节点上运行。
# mysql:8.0：使用的 MySQL 镜像版本。
# mysql -h &amp;lt;MySQL 服务主机地址&amp;gt; -P &amp;lt;端口&amp;gt; -u &amp;lt;用户名&amp;gt; -p&amp;lt;密码&amp;gt;：容器启动后执行的命令，用于连接到 MySQL 服务。请将 &amp;lt;MySQL 服务主机地址&amp;gt;、&amp;lt;端口&amp;gt;、&amp;lt;用户名&amp;gt; 和 &amp;lt;密码&amp;gt; 替换为实际的值。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;8-docker-swarm&#34;&gt;8. Docker Swarm 集群环境删除服务&lt;/h3&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;docker service ls
docker service rm &amp;lt;服务 ID 或名称&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;9-docker&#34;&gt;9. 进入docker&lt;/h3&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;docker exec -it &amp;lt;窗口 ID&amp;gt; bash
&lt;/code&gt;&lt;/pre&gt;</description>  
      <pubDate>2025-10-09 17:54:40</pubDate>  
      <link>https://testpoo.github.io/安装docker-swarm.html</link>  
      <guid isPermaLink="true">https://testpoo.github.io/安装docker-swarm.html</guid>
       
      <category>技术</category> 
      
    </item>
    
    <item> 
      <title>人生的最高境界</title>  
      <description>&lt;blockquote&gt;
&lt;p&gt;来源于网络搜集&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果你熬到了，一个人喝茶，一个人跑步，一个人旅行，一个人看书，没有电话，没有邀约，没有聚会，没有所谓的些社交。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;早睡早起，善待自己，无欲无求，云淡风轻，不在乎别人的评价。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;那么恭喜你，你已经达到了人生的最高境界。&lt;/p&gt;</description>  
      <pubDate>2025-10-09 17:54:40</pubDate>  
      <link>https://testpoo.github.io/人生的最高境界.html</link>  
      <guid isPermaLink="true">https://testpoo.github.io/人生的最高境界.html</guid>
       
      <category>摘录</category> 
      
    </item>
    
    <item> 
      <title>中国朝代顺序口诀</title>  
      <description>&lt;div class=&#34;toc&#34;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#_1&#34;&gt;大陆版本&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_2&#34;&gt;香港版本&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;来源于网络搜集&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;_1&#34;&gt;大陆版本&lt;/h3&gt;
&lt;p&gt;三皇五帝始；尧舜禹相传；&lt;br /&gt;
夏商与西周；东周分两段；&lt;br /&gt;
春秋和战国；一统秦两汉；&lt;br /&gt;
三分魏蜀吴；两晋前后延；&lt;br /&gt;
南北朝并立；隋唐五代传；&lt;br /&gt;
宋元明清后；皇朝至此完。&lt;/p&gt;
&lt;h3 id=&#34;_2&#34;&gt;香港版本&lt;/h3&gt;
&lt;p&gt;炎黄虞夏商，周到战国亡，秦朝并六国，赢政称始皇，&lt;br /&gt;
楚汉鸿沟界，最后属刘邦，西汉孕新莽，东汉迁洛阳，&lt;br /&gt;
末年黄巾出，三国各称王，西晋变东晋，迁都到建康，&lt;br /&gt;
拓跋入中原，国分南北方，北朝十六国，南朝宋齐梁，&lt;br /&gt;
南陈被隋灭，杨广输李唐，大唐曾改周，武后则天皇，&lt;br /&gt;
残皇有五代，伶官舞后庄，华歆分十国，北宋火南唐，&lt;br /&gt;
金国俘二帝，南宋到苏杭，蒙主称大汗，最后被明亡，&lt;br /&gt;
明到崇帧帝，大顺立闯王，金田太平国，时适清道光，&lt;br /&gt;
九传至光绪，维新有康梁，换位至宣统，民国废末皇，&lt;br /&gt;
五四风雨骤，建国存新纲，抗日反内战，五星红旗扬。&lt;/p&gt;</description>  
      <pubDate>2025-10-09 17:54:40</pubDate>  
      <link>https://testpoo.github.io/中国朝代顺序口诀.html</link>  
      <guid isPermaLink="true">https://testpoo.github.io/中国朝代顺序口诀.html</guid>
       
      <category>摘录</category> 
      
    </item>
    
    <item> 
      <title>国际象棋棋子代号</title>  
      <description>&lt;blockquote&gt;
&lt;p&gt;来源于网络搜集&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在国际象棋中，每个棋子都有其特定的代号这些代号用大写字母表示，以便于记录棋子的移动。具体来说:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;王(King): 代号为K。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;后(Queen): 代号为Q。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;车(Rook): 代号为R。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;象(Bishop): 代号为B。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;马(Knight): 代号为N。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</description>  
      <pubDate>2025-10-09 17:54:40</pubDate>  
      <link>https://testpoo.github.io/国际象棋棋子代号.html</link>  
      <guid isPermaLink="true">https://testpoo.github.io/国际象棋棋子代号.html</guid>
       
      <category>摘录</category> 
      
    </item>
    
    <item> 
      <title>CSS代码小抄</title>  
      <description>&lt;div class=&#34;toc&#34;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#css-div&#34;&gt; CSS 计算 div 的宽度和高度&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#hr&#34;&gt; 好看的 hr&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h3 id=&#34;css-div&#34;&gt; &lt;code&gt;CSS&lt;/code&gt; 计算 &lt;code&gt;div&lt;/code&gt; 的宽度和高度&lt;/h3&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;# calc + vw 计算宽度
width: 800px; /* fallback for b*/
width: -moz-calc(100vw - (2 * 10)px);
width: -webkit-calc(100vw -(2 * 10)px);
width: calc(100vw - (2 * 10)px);

# calc + vh 计算高度
height: 800px;
height: -moz-calc(100vh - (2 * 10)px);
height: -webkit-calc(100vh - (2 * 10)px);
height: calc(100vh - (2 * 10)px);
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;
&lt;h3 id=&#34;hr&#34;&gt; 好看的 &lt;code&gt;hr&lt;/code&gt;&lt;/h3&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;hr {
    border: 0;
    padding: 3px;
    background: linear-gradient(135deg, red, orange,green, blue, purple);
    --mask-image: repeating-linear-gradient(135deg, #000 0px, #000 1px, transparent 1px, transparent 6px);
    -webkit-mask-image: var(--mask-image);
    mask-image: var(--mask-image);
}
&lt;/code&gt;&lt;/pre&gt;</description>  
      <pubDate>2025-10-09 17:54:40</pubDate>  
      <link>https://testpoo.github.io/CSS代码小抄.html</link>  
      <guid isPermaLink="true">https://testpoo.github.io/CSS代码小抄.html</guid>
       
      <category>代码小抄</category> 
      
    </item>
    
    <item> 
      <title>婚书两则</title>  
      <description>&lt;div class=&#34;toc&#34;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#_1&#34;&gt;道家婚书&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_2&#34;&gt;民国婚书&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;来源于网络搜集&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;_1&#34;&gt;道家婚书&lt;/h3&gt;
&lt;p&gt;一纸婚书，上表天庭，&lt;br /&gt;
下鸣地府，&lt;br /&gt;
当上奏九霄，&lt;br /&gt;
诸天祖师见证。&lt;br /&gt;
若负佳人，便是欺天，&lt;br /&gt;
欺天之罪，身死道消。&lt;br /&gt;
佳人负卿，&lt;br /&gt;
那便是有意三界除名，&lt;br /&gt;
永无轮回。&lt;/p&gt;
&lt;h3 id=&#34;_2&#34;&gt;民国婚书&lt;/h3&gt;
&lt;p&gt;两姓联姻，一堂缔约，&lt;br /&gt;
良缘永结，匹配同称。&lt;br /&gt;
看此日桃花灼灼，&lt;br /&gt;
宜室宜家。&lt;br /&gt;
卜他年瓜瓞绵绵，&lt;br /&gt;
尔昌尔炽。&lt;br /&gt;
递以白头之约，&lt;br /&gt;
书向鸿笺好将红叶之盟，&lt;br /&gt;
载明鸳谱。&lt;/p&gt;</description>  
      <pubDate>2025-10-09 17:54:40</pubDate>  
      <link>https://testpoo.github.io/婚书两则.html</link>  
      <guid isPermaLink="true">https://testpoo.github.io/婚书两则.html</guid>
       
      <category>摘录</category> 
      
    </item>
    
    <item> 
      <title>javascript代码小抄</title>  
      <description>&lt;div class=&#34;toc&#34;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#_1&#34;&gt; 获取工作日&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h3 id=&#34;_1&#34;&gt; 获取工作日&lt;/h3&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;function getWorkdays() {
    const startDate = new Date(document.querySelector(&amp;quot;[name=&#39;startime&#39;]&amp;quot;).value);
    const endDate = new Date(document.querySelector(&amp;quot;[name=&#39;endtime&#39;]&amp;quot;).value);
    const holidays = {{ holidays|safe if holidays else [] }}; //节假日
    const extradays = {{ extradays|safe if extradays else [] }}; //补班
    let days = 0;
    let currentDate = startDate;

    // 确保结束日期在开始日期之后
    if (currentDate &amp;gt; endDate) {
        [startDate, endDate] = [endDate, startDate];
    }

    while (currentDate &amp;lt;= endDate) {
        const temp = currentDate.getFullYear().toString() + &#39;-&#39; + (currentDate.getMonth() + 1).toString() + &#39;-&#39; + currentDate.getDate().toString();
        if (![0, 6].includes(currentDate.getDay()) &amp;amp;&amp;amp; !holidays.includes(temp) || extradays.includes(temp)) {
            days++;
        }
        currentDate.setDate(currentDate.getDate() + 1);
    }
    document.querySelector(&amp;quot;[name=&#39;spentime&#39;]&amp;quot;).value = days;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;</description>  
      <pubDate>2025-10-09 17:54:40</pubDate>  
      <link>https://testpoo.github.io/javascript代码小抄.html</link>  
      <guid isPermaLink="true">https://testpoo.github.io/javascript代码小抄.html</guid>
       
      <category>代码小抄</category> 
      
    </item>
    
    <item> 
      <title>python代码小抄</title>  
      <description>&lt;div class=&#34;toc&#34;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#linux&#34;&gt; 获取Linux程序名称/命令/图标/分类&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#linux_1&#34;&gt; 获取Linux程序图标&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#tkinter&#34;&gt; 如何确定在tkinter中单击了哪个按钮&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#python&#34;&gt; python定时任务&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#jinja2&#34;&gt; JinJa2代码&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#mysql&#34;&gt; MySQL数据库连接&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_1&#34;&gt; 清空文件夹&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_2&#34;&gt; 获取任意周的周一和周五&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_3&#34;&gt; 获取工作日&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h3 id=&#34;linux&#34;&gt; 获取Linux程序名称/命令/图标/分类&lt;/h3&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;path = &amp;quot;/usr/share/applications/&amp;quot;
lists = [list for list in os.listdir(path) if len(list.split(&amp;quot;.&amp;quot;))&amp;gt;1 and list.split(&amp;quot;.&amp;quot;)[1] == &amp;quot;desktop&amp;quot;]
apps = []
for list in lists:
    lines = open(path + list,&amp;quot;r&amp;quot;).readlines()
    dicts = {}
    for line in lines:
        if line.startswith(&amp;quot;Name=&amp;quot;):
            dicts[&#39;Name&#39;] = re.split(&amp;quot;=|\n&amp;quot;,line)[1]
        elif line.startswith(&amp;quot;Name[zh_CN]=&amp;quot;):
            dicts[&#39;NameCN&#39;] = re.split(&amp;quot;=|\n&amp;quot;,line)[1]
        elif line.startswith(&amp;quot;Exec=&amp;quot;):
            dicts[&#39;Exec&#39;] = re.sub(&amp;quot; %U| %F| %f| %u&amp;quot;,&amp;quot;&amp;quot;,re.split(&amp;quot;=|\n&amp;quot;,line)[1])
        elif line.startswith(&amp;quot;Icon=&amp;quot;):
            dicts[&#39;Icon&#39;] = re.split(&amp;quot;=|\n&amp;quot;,line)[1]
        elif line.startswith(&amp;quot;Categories=&amp;quot;):
            dicts[&#39;Categories&#39;] = re.split(&amp;quot;=|\n&amp;quot;,line)[1]
        elif line.startswith(&amp;quot;[Desktop Action&amp;quot;):
            break
    if &#39;NameCN&#39; in dicts:
        dicts[&#39;Name&#39;] = dicts[&#39;NameCN&#39;]
        dicts.pop(&#39;NameCN&#39;)
    if dicts != {} and &#39;Icon&#39; in dicts:
        apps.append(dicts)
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;
&lt;h3 id=&#34;linux_1&#34;&gt; 获取Linux程序图标&lt;/h3&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;# directries第一个元素是当前图标
directries = [&amp;quot;/usr/share/icons/Yaru/48x48/&amp;quot;,&amp;quot;/usr/share/icons/gnome/48x48/&amp;quot;,&amp;quot;/usr/share/pixmaps/&amp;quot;,&amp;quot;/usr/share/icons/hicolor/scalable/&amp;quot;,&amp;quot;/usr/share/icons/hicolor/48x48/&amp;quot;,&amp;quot;/opt/&amp;quot;]

def find_images_glob(self,directries,event=None):
    image_paths={}
    for directry in directries:
        for dirpath, dirnames, filenames in os.walk(directry):
            for app in apps:
                if app[&#39;Icon&#39;]+&amp;quot;.png&amp;quot; in filenames:
                    if app[&#39;Icon&#39;]+&amp;quot;.png&amp;quot; not in image_paths:
                        image_paths[app[&#39;Icon&#39;]] = dirpath + &amp;quot;/&amp;quot; + app[&#39;Icon&#39;]+&amp;quot;.png&amp;quot;
                elif app[&#39;Icon&#39;]+&amp;quot;.svg&amp;quot; in filenames:
                    if app[&#39;Icon&#39;]+&amp;quot;.svg&amp;quot; not in image_paths:
                        image_paths[app[&#39;Icon&#39;]] = dirpath + &amp;quot;/&amp;quot; + app[&#39;Icon&#39;]+&amp;quot;.svg&amp;quot;
                elif len(app[&#39;Icon&#39;].split(&amp;quot;/&amp;quot;))&amp;gt;1:
                    if app[&#39;Icon&#39;].split(&amp;quot;/&amp;quot;)[-1] not in image_paths:
                        image_paths[app[&#39;Icon&#39;].split(&amp;quot;/&amp;quot;)[-1].split(&#39;.&#39;)[0]] = app[&#39;Icon&#39;]
    return image_paths
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;
&lt;h3 id=&#34;tkinter&#34;&gt; 如何确定在tkinter中单击了哪个按钮&lt;/h3&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;方法1：
from functools import partial

for i in range(10):
    btn = Button(frame,text=&amp;quot;Button&amp;quot;,command=partial(click, i))

方法2：
for i in range(10):
    btn = Button(frame,text=&amp;quot;Button&amp;quot;,command=lambda i=i: click(i))
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;
&lt;h3 id=&#34;python&#34;&gt; python定时任务&lt;/h3&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;#!/usr/bin/env python
import time

while True:
    time_now = time.strftime(&amp;quot;%H:%M:%S&amp;quot;, time.localtime()) # 刷新
    if time_now == &amp;quot;09:39:00&amp;quot;: 
        print(time.strftime(&amp;quot;%Y-%m-%d %H:%M:%S&amp;quot;, time.localtime()))  
        time.sleep(2) # 因为以秒定时，所以暂停2秒，使之不会在1秒内执行多次
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;
&lt;h3 id=&#34;jinja2&#34;&gt; JinJa2代码&lt;/h3&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;# 注册过滤器
env = app.jinja_env
env.filters[&amp;quot;sum_car_food_by_category&amp;quot;] = sum_car_food_by_category

# 全局变量设置
@app.context_processor
def getSiteUrl():
    return dict(SITEURL=SITEURL)

# app执行前执行
@app.before_request
def authority():
    path = request.path
    if not session.get(&#39;logged_in&#39;):
        if path not in (&#39;/&#39;, &#39;/login&#39;) and not path.startswith(&#39;/static&#39;):
            return redirect(url_for(&#39;login&#39;))
    elif session.get(&#39;logged_in&#39;):
        if &#39;&#39;.join([&#39;/&#39;,path.split(&amp;quot;/&amp;quot;)[1]]) not in auths(session[&#39;username&#39;]):
            return redirect(url_for(&#39;unPlan&#39;))
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;
&lt;h3 id=&#34;mysql&#34;&gt; MySQL数据库连接&lt;/h3&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;import pymysql

dblink = {&amp;quot;url&amp;quot;: &amp;quot;127.0.0.1&amp;quot;, &amp;quot;username&amp;quot;: &amp;quot;test&amp;quot;, &amp;quot;password&amp;quot;: &amp;quot;11111111&amp;quot;, &amp;quot;database&amp;quot;: &amp;quot;test&amp;quot;}
def selectOne(sql, info=[]):
    try:
        # 连接MySQL数据库
        db = pymysql.connect(host=dblink[&#39;url&#39;], user=dblink[&#39;username&#39;], password=dblink[&#39;password&#39;],db=dblink[&#39;database&#39;], charset=&#39;utf8&#39;)
        # 使用cursor()方法获取操作游标
        cursor = db.cursor()
        # 使用execute()方法执行sql语句
        cursor.execute(sql, info)
        # 使用fetchone()方法获取所有数据
        results = cursor.fetchall()
        return results
    except Exception as err:
        logUtility.logger.debug(&amp;quot;事务处理失败: {}&amp;quot;.format(str(err)))
        return &#39;事务处理失败&#39;
    else:
        LogUtility.logger.debug(&amp;quot;事务处理成功&amp;quot;)
    # 关闭数据库
    finally:
        db.close()
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;
&lt;h3 id=&#34;_1&#34;&gt; 清空文件夹&lt;/h3&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;def delFile(path):
    paths = os.listdir(path)
    if paths != []:
        for f in paths:
            filepath = os.path.join(path, f)
            os.remove(filepath)
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;
&lt;h3 id=&#34;_2&#34;&gt; 获取任意周的周一和周五&lt;/h3&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;def get_which_week_monday_and_firday_by_date(move_days):
    needTime = datetime.strptime(time.strftime(&amp;quot;%Y-%m-%d&amp;quot;, time.localtime()) + &amp;quot; 00:00:00&amp;quot;, &amp;quot;%Y-%m-%d %H:%M:%S&amp;quot;)
    weekStartTime = needTime - timedelta(days=needTime.weekday() + move_days, hours=needTime.hour, minutes=needTime.minute, seconds=needTime.second, microseconds=needTime.microsecond)
    weekEndTime = weekStartTime + timedelta(days=4, hours=23, minutes=59, seconds=59)
    weekStartTime = weekStartTime.strftime(&amp;quot;%Y-%m-%d&amp;quot;)
    weekEndTime = weekEndTime.strftime(&amp;quot;%Y-%m-%d&amp;quot;)
    return weekStartTime, weekEndTime
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;
&lt;h3 id=&#34;_3&#34;&gt; 获取工作日&lt;/h3&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;def calculate_workdays(start_date, end_date):
    start_date = datetime.strptime(start_date,&#39;%Y-%m-%d&#39;)
    end_date = datetime.strptime(end_date,&#39;%Y-%m-%d&#39;)
    # 法定假期
    holi_days = [datetime.strptime(holiday,&#39;%Y-%m-%d&#39;) for holiday in holidays]
    # 补班
    extra_days = [datetime.strptime(extraday,&#39;%Y-%m-%d&#39;) for extraday in extradays]
    current_date = start_date
    workdays = 0
    while current_date &amp;lt;= end_date:
        if current_date.weekday() not in [5, 6] and current_date not in holi_days or current_date in extra_days:
            workdays += 1
        current_date += timedelta(days=1)
    return workdays
&lt;/code&gt;&lt;/pre&gt;</description>  
      <pubDate>2025-10-09 17:54:40</pubDate>  
      <link>https://testpoo.github.io/python代码小抄.html</link>  
      <guid isPermaLink="true">https://testpoo.github.io/python代码小抄.html</guid>
       
      <category>代码小抄</category> 
      
    </item>
    
    <item> 
      <title>只有一个读音的九篇古文</title>  
      <description>&lt;div class=&#34;toc&#34;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#_1&#34;&gt;羿裔熠邑彝&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_2&#34;&gt;饥鸡集矶记&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_3&#34;&gt;季姬击鸡记&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_4&#34;&gt;施氏食狮史&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_5&#34;&gt;熙戏犀&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_6&#34;&gt;于瑜欲渔&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_7&#34;&gt;吏李立莅&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_8&#34;&gt;遗镒疑医&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_9&#34;&gt;易姨医胰&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_10&#34;&gt;对联一则&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;来源于网络搜集&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;_1&#34;&gt;羿裔熠邑彝&lt;/h3&gt;
&lt;p&gt;羿裔熠，邑彝，义医，艺诣。熠姨遗一裔伊，伊仪迤，衣旖，异奕矣。熠意伊矣，易衣以贻伊，伊遗衣，衣异衣以意异熠，熠抑矣。伊驿邑，弋一翳 ，弈毅。毅仪奕，诣弈，衣异，意逸。毅诣伊，益伊，伊怡，已臆毅矣，毅亦怡伊。翌，伊亦弈毅。毅以蜴贻伊，伊亦贻衣以毅。伊疫，呓毅， 癔异矣，倚椅咿咿，毅亦咿咿。毅诣熠，意以熠，议熠医伊，熠懿毅，意役毅逸。毅以熠宜伊，翼逸。熠驿邑以医伊，疑伊胰痍，以蚁医伊，伊遗异，溢，伊咦。熠移伊，刈薏以医，伊益矣。伊忆毅，亦呓毅矣，熠意伊毅已逸，熠意役伊。伊异，噫，缢。熠癔，亦缢。&lt;/p&gt;
&lt;h3 id=&#34;_2&#34;&gt;饥鸡集矶记&lt;/h3&gt;
&lt;p&gt;唧唧鸡，鸡唧唧。几鸡挤挤集矶脊。机极疾，鸡饥极，鸡冀已技击及鲫。机既济蓟畿，鸡计疾机激几鲫。机疾极，鲫极悸，急急挤集矶级际。继即鲫迹极寂寂，继即几鸡既饥，即唧唧。&lt;/p&gt;
&lt;h3 id=&#34;_3&#34;&gt;季姬击鸡记&lt;/h3&gt;
&lt;p&gt;季姬寂，集鸡，鸡即棘鸡。棘鸡饥叽，季姬及箕稷济鸡。鸡既济，跻姬笈，季姬忌，急咭鸡，鸡急，继圾几，季姬急，即籍箕击鸡，箕疾击几伎，即齑，鸡叽集几基，季姬急极屐击鸡，鸡既殛，季姬激，即记《季姬击鸡记》。&lt;/p&gt;
&lt;h3 id=&#34;_4&#34;&gt;施氏食狮史&lt;/h3&gt;
&lt;p&gt;石室诗士施氏，嗜狮，誓食十狮。适施氏时时适市视狮。十时，适十狮适市。是时，适施氏适市。氏视是十狮，恃矢势，使是十狮逝世。氏拾是十狮尸，适石室。石室湿，氏使侍拭石室。石室拭，氏始试食是十狮尸。食时，始识是十狮尸，实十石狮尸。试释是事。&lt;/p&gt;
&lt;h3 id=&#34;_5&#34;&gt;熙戏犀&lt;/h3&gt;
&lt;p&gt;西溪犀，喜嬉戏。席熙夕夕携犀徙，席熙细细习洗犀。犀吸溪，戏袭熙。席熙嘻嘻希息戏。惜犀嘶嘶喜袭熙。&lt;/p&gt;
&lt;h3 id=&#34;_6&#34;&gt;于瑜欲渔&lt;/h3&gt;
&lt;p&gt;于瑜欲渔，遇余于寓。语余：“余欲渔于渝淤，与余渔渝欤？”余语于瑜：“余欲鬻玉，俞禹欲玉，余欲遇俞于俞寓。”余与于瑜遇俞于俞寓，逾俞隅，欲鬻玉与俞，遇雨，雨逾俞宇。余语于俞：“余欲渔于渝淤，遇雨俞宇，欲渔欤？鬻玉欤？”于瑜与余御雨于俞寓，俞鬻玉与余禹，雨愈，余与于瑜踽踽逾逾俞宇，渔于渝淤。&lt;/p&gt;
&lt;h3 id=&#34;_7&#34;&gt;吏李立莅&lt;/h3&gt;
&lt;p&gt;吏李立莅，赲逦屴岦峛沥俚黎，立艃漓里叕鲤礼黎，罹沴厉离，俚黎蛎鹂历呖。&lt;/p&gt;
&lt;h3 id=&#34;_8&#34;&gt;遗镒疑医&lt;/h3&gt;
&lt;p&gt;伊姨殪，遗亿镒。伊诣邑，意医姨疫。一医医伊姨。翌，亿镒遗，疑医，以议医。医以伊疑，缢，以移伊疑。伊倚椅以忆，忆以亿镒遗，以议伊医，亦缢。噫，亦异矣！&lt;/p&gt;
&lt;h3 id=&#34;_9&#34;&gt;易姨医胰&lt;/h3&gt;
&lt;p&gt;易姨悒悒，依议诣夷医。医疑胰疫，遗意易姨倚椅，以异仪移姨胰，弋异蚁一亿，胰液溢，蚁殪，胰以医。易胰怡怡，贻医一夷衣。医衣夷衣，怡怡奕奕。噫！以蚁医胰，异矣！以夷衣贻夷医亦宜矣！&lt;/p&gt;
&lt;h3 id=&#34;_10&#34;&gt;对联一则&lt;/h3&gt;
&lt;p&gt;上联：
齐妻起棋，齐欺妻气，妻弃七棋。
下联：
伊姨移椅，伊倚姨疑，姨遗一椅。&lt;/p&gt;</description>  
      <pubDate>2025-10-09 17:54:40</pubDate>  
      <link>https://testpoo.github.io/只有一个读音的九篇古文.html</link>  
      <guid isPermaLink="true">https://testpoo.github.io/只有一个读音的九篇古文.html</guid>
       
      <category>摘录</category> 
      
    </item>
    
    <item> 
      <title>独孤羊放妻春条书</title>  
      <description>&lt;blockquote&gt;
&lt;p&gt;来源于网剧《唐朝诡事录之西行》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;盖闻一日夫妻，有百日恩情，独孤何人竟遇娘子。一舟共渡需十年修得，同床邀梦则是三世之缘。独孤与娘子本欲花下携手，共事炊烟，造伉俪之深情，成他人之艳羡。&lt;/p&gt;
&lt;p&gt;然独孤生于仵作之家，向为世人所轻，又无通达性情，难令娘子欢颜。虽有雕虫小技，造泥俑以营生，挡盗贼于墓穴，亦不为世人所重。&lt;/p&gt;
&lt;p&gt;悠悠七载，间隙既生，怨忿难平，已为深谷。独孤内欲改性情，然朝夕难至，独孤外欲弃仵作，怎奈年久生情。独孤苍苍而娘子青青，若以此拖宕竟困娘子，独孤不为。&lt;/p&gt;
&lt;p&gt;今放春条，欢喜各生。伏愿娘子，觅得良家，对镜展眉，育女生儿，六亲皆欢。独孤无憾，为留后凭，雍州拾阳县独孤羊谨立。&lt;/p&gt;</description>  
      <pubDate>2025-10-09 17:54:40</pubDate>  
      <link>https://testpoo.github.io/独孤羊放妻春条书.html</link>  
      <guid isPermaLink="true">https://testpoo.github.io/独孤羊放妻春条书.html</guid>
       
      <category>摘录</category> 
      
    </item>
    
    <item> 
      <title>Jinja2简介</title>  
      <description>&lt;div class=&#34;toc&#34;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1&#34;&gt;1. 简介&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2&#34;&gt;2. 安装&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#21&#34;&gt;2.1 依赖项&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#22&#34;&gt;2.2 可选依赖项&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#23-api&#34;&gt;2.3 基本API使用&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3-api&#34;&gt;3 API&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#31&#34;&gt;3.1 基础知识&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#32-api&#34;&gt;3.2 高级API&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4&#34;&gt;4 模板&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5&#34;&gt;5 集成&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#51-flask&#34;&gt;5.1 Flask&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#52-django&#34;&gt;5.2 Django&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#6&#34;&gt;6 实例&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h3 id=&#34;1&#34;&gt;1. 简介&lt;/h3&gt;
&lt;p&gt;Jinja 是一个快速、表现力强、可扩展的模板引擎。模板中的特殊占位符允许编写类似 Python 语法的代码。然后将数据传递给模板，以渲染最终文档。&lt;/p&gt;
&lt;p&gt;特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;模板继承；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可在模板中定义和导入宏；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;HTML 模板可使用自动换码功能，防止来自不受信任用户输入的 XSS；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;沙箱环境可安全地呈现不受信任的模板；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;支持异步，可生成无需额外语法即可自动处理同步和异步函数的模板；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过 &lt;code&gt;Babel&lt;/code&gt; 支持 I18N；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;模板会及时编译为优化的 Python 代码并缓存，也可以提前编译；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;精确展示模板中的异常行，使调试更容易；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可扩展过滤器、测试、函数甚至语法。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2&#34;&gt;2. 安装&lt;/h3&gt;
&lt;p&gt;建议使用最新版本的 Python。Jinja 支持 Python 3.7 及更新版本。建议使用虚拟环境，以便将项目依赖关系与其他项目和系统隔离。&lt;/p&gt;
&lt;p&gt;使用 pip 安装最新版本的 Jinja：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-Shell&#34;&gt;$ pip install Jinja2
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;21&#34;&gt;2.1 依赖项&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;安装 Jinja 时会自动安装这些依赖项。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;MarkupSafe&lt;/code&gt; 会在渲染模板时转义不信任的输入，以避免注入攻击。&lt;/p&gt;
&lt;h4 id=&#34;22&#34;&gt;2.2 可选依赖项&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;安装 Jinja 时不会自动安装。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Babel&lt;/code&gt; 在模板中提供翻译支持。&lt;/p&gt;
&lt;h4 id=&#34;23-api&#34;&gt;2.3 基本API使用&lt;/h4&gt;
&lt;p&gt;最基本的方式就是通过 &lt;code&gt;Template&lt;/code&gt; 创建一个模板并渲染它。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-Shell&#34;&gt;&amp;gt;&amp;gt;&amp;gt; from jinja2 import Template
&amp;gt;&amp;gt;&amp;gt; template = Template(&#39;Hello {{ name }}!&#39;)
&amp;gt;&amp;gt;&amp;gt; template.render(name=&#39;test poo&#39;)
&#39;Hello test poo!&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;3-api&#34;&gt;3 API&lt;/h3&gt;
&lt;h4 id=&#34;31&#34;&gt;3.1 基础知识&lt;/h4&gt;
&lt;p&gt;Jinja 使用一个名为 &#34;模板环境 &#34;的中心对象。该类的实例用于存储配置和全局对象，并用于从文件系统或其他位置加载模板。即使您使用模板类的构造函数从字符串创建模板，也会自动创建一个环境。&lt;/p&gt;
&lt;p&gt;配置 &lt;code&gt;Jinja&lt;/code&gt; 为应用程序加载模板的最简单方法是使用 &lt;code&gt;PackageLoader&lt;/code&gt;。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-Python&#34;&gt;from jinja2 import Environment, PackageLoader, select_autoescape
env = Environment(
    loader=PackageLoader(&amp;quot;yourapp&amp;quot;)
    autoescape=select_autoescape()
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这将创建一个带有加载器的模板环境，加载器会在 yourapp Python 软件包内的模板文件夹中查找模板。它还会启用 HTML 文件的自动换码功能。该加载器只要求 yourapp 是可导入的，它会为你找出文件夹的绝对路径。&lt;/p&gt;
&lt;p&gt;不同的加载器可用于以其他方式或从其他位置加载模板。它们都列在下面的加载器部分。如果你想从更适合你的项目的来源加载模板，也可以自己编写。&lt;/p&gt;
&lt;p&gt;要从该环境加载模板，请使用 get_template() 方法，它会返回已加载的模板。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-Python&#34;&gt;template = env.get_template(&amp;quot;mytemplate.html&amp;quot;) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;调用 &lt;code&gt;render()&lt;/code&gt; 方法用一些变量渲染模板。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;print(template.render(the=&amp;quot;variables&amp;quot;, go=&amp;quot;here&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用模板加载器而不是向 Template 或 Environment.from_string() 传递字符串有很多好处。除了更容易使用外，它还能实现模板继承。&lt;/p&gt;
&lt;h4 id=&#34;32-api&#34;&gt;3.2 高级API&lt;/h4&gt;
&lt;p&gt;高级应用程序接口（High Level API）是您将在应用程序中使用的应用程序接口，用于加载和呈现 Jinja 模板。而低级应用程序接口（Low Level API）只有在你想深入研究 Jinja或开发扩展时才有用。&lt;/p&gt;
&lt;p&gt;详见：&lt;a href=&#34;https://jinja.palletsprojects.com/en/3.1.x/api/#high-level-api&#34;&gt;https://jinja.palletsprojects.com/en/3.1.x/api/#high-level-api&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;4&#34;&gt;4 模板&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;简介&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Jinja 模板是一个简单的文本文件。Jinja 可以生成任何基于文本的格式（HTML、XML、CSV、LaTeX 等）。Jinja 模板不需要特定的扩展名：.html、.xml 或任何其他扩展名都可以。&lt;/p&gt;
&lt;p&gt;一个模板包含变量和/或表达式，当模板被渲染时，这些变量和/或表达式将被替换为值；还包含标签，用于控制模板的逻辑。&lt;/p&gt;
&lt;p&gt;下面是一个模板示例：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-HTML&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;My Webpage&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;ul id=&amp;quot;navigation&amp;quot;&amp;gt;
    {% for item in navigation %}
        &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;{{ item.href }}&amp;quot;&amp;gt;{{ item.caption }}&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
    {% endfor %}
    &amp;lt;/ul&amp;gt;

    &amp;lt;h1&amp;gt;My Webpage&amp;lt;/h1&amp;gt;
    {{ a_variable }}

    {# a comment #}
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的示例显示了默认配置设置。应用程序开发人员可以将语法配置从 &lt;code&gt;{% foo %}&lt;/code&gt; 更改为 &lt;code&gt;&amp;lt;% foo %&amp;gt;&lt;/code&gt; 或类似内容。&lt;/p&gt;
&lt;p&gt;有几种分隔符。Jinja 的默认分隔符配置如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;{% ... %} 用于语句&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;{{ ... }} 用于要打印到模板输出的表达式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;{# ... #} 表示不包含在模板输出中的注释&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;行语句和注释也可以使用，但它们没有默认的前缀字符。要使用它们，请在创建环境时设置 &lt;code&gt;line_statement_prefix&lt;/code&gt; 和 &lt;code&gt;line_comment_prefix&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;详见：&lt;a href=&#34;https://jinja.palletsprojects.com/en/3.1.x/templates/&#34;&gt;https://jinja.palletsprojects.com/en/3.1.x/templates/&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;5&#34;&gt;5 集成&lt;/h3&gt;
&lt;h4 id=&#34;51-flask&#34;&gt;5.1 Flask&lt;/h4&gt;
&lt;p&gt;Flask 框架默认使用 Jinja 模板。Flask 会设置一个 Jinja 环境和模板加载器，并提供从视图函数轻松呈现模板的功能。&lt;/p&gt;
&lt;h4 id=&#34;52-django&#34;&gt;5.2 Django&lt;/h4&gt;
&lt;p&gt;Django 支持使用 Jinja 作为模板引擎，请参见 &lt;a href=&#34;https://docs.djangoproject.com/en/stable/topics/templates/#support-for-template-engines。&#34;&gt;https://docs.djangoproject.com/en/stable/topics/templates/#support-for-template-engines。&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可集成的还有 &lt;a href=&#34;https://jinja.palletsprojects.com/en/3.1.x/integration/#babel&#34;&gt;Babel&lt;/a&gt; 和 &lt;a href=&#34;https://jinja.palletsprojects.com/en/3.1.x/integration/#pylons&#34;&gt;Pylons&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;6&#34;&gt;6 实例&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;渲染模板&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在这个模板中，&lt;code&gt;{{ title }}&lt;/code&gt;、&lt;code&gt;{{ heading }}&lt;/code&gt; 和 &lt;code&gt;{{ name }}&lt;/code&gt; 是变量，将在渲染时被替换。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-Python&#34;&gt;from jinja2 import Template

# 模板字符串
template_string = &amp;quot;&amp;quot;&amp;quot;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;{{ title }}&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;h1&amp;gt;{{ heading }}&amp;lt;/h1&amp;gt;
    &amp;lt;p&amp;gt;嗨, {{ name }}!&amp;lt;/p&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&amp;quot;&amp;quot;&amp;quot;

# 创建模板对象
template = Template(template_string)

# 渲染模板
print(template.render(title=&amp;quot;测试一下&amp;quot;, heading=&amp;quot;欢迎一下&amp;quot;, name=&amp;quot;初学者&amp;quot;)) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;运行结果：&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;测试一下&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;h1&amp;gt;欢迎一下&amp;lt;/h1&amp;gt;
    &amp;lt;p&amp;gt;嗨, 初学者!&amp;lt;/p&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;控制结构&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Jinja2支持常见的控制结构，例如条件判断和循环。下面是一个使用循环的例子：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;&amp;lt;ul&amp;gt;
{% for item in item_list %}
    &amp;lt;li&amp;gt;{{ item }}&amp;lt;/li&amp;gt;
{% endfor %}
&amp;lt;/ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在Python代码中，提供一个列表来渲染这个模板：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;print(template.render(item_list=[&amp;quot;苹果&amp;quot;, &amp;quot;香蕉&amp;quot;, &amp;quot;橘子&amp;quot;]))
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;模板继承&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;模板继承是Jinja2的一个强大功能。你可以创建一个基础模板，然后在其他模板中继承和扩展它。例如：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;基础模板（base.html）:&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;{% block title %}{% endblock %}&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    {% block body %}
    {% endblock %}
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;子模板（child.html）:&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;{% extends &amp;quot;base.html&amp;quot; %}

{% block title %}子页面标题{% endblock %}

{% block body %}
    &amp;lt;p&amp;gt;这是子页面的内容。&amp;lt;/p&amp;gt;
{% endblock %}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;过滤器&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Jinja2还提供了多种过滤器，用于转换变量。例如，使用 &lt;code&gt;capitalize&lt;/code&gt; 过滤器将字符串的首字母大写：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;&amp;lt;p&amp;gt;{{ &amp;quot;hello world&amp;quot; | capitalize }}&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;过滤器是可以自己定义的，详见：&lt;a href=&#34;https://jinja.palletsprojects.com/en/3.1.x/api/#custom-filters&#34;&gt;https://jinja.palletsprojects.com/en/3.1.x/api/#custom-filters&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;集成 flask&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;安装 flask&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;pip install flask
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;项目结构&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;flaskr/
│
├── templates/
│   └── index.html
│
└── flaskr.py
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;创建Jinja2模板&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;templates&lt;/code&gt; 目录下创建一个 &lt;code&gt;index.html&lt;/code&gt; 文件，作为我们的 &lt;code&gt;Jinja2&lt;/code&gt; 模板。这个模板将简单地展示一个传入的变量。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-HTML&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;Flask with Jinja2&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;h1&amp;gt;Welcome to Flask with Jinja2&amp;lt;/h1&amp;gt;
    &amp;lt;p&amp;gt;Hello, {{ name }}!&amp;lt;/p&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Flask集成Jinja2&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;flaskr.py&lt;/code&gt; 文件中，我们将创建一个FastAPI应用，并配置Jinja2环境。然后，我们将创建一个路由来渲染上面的模板。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-Python&#34;&gt;from flask import Flask, render_template

# 创建我们的小程序 :)
app = Flask(__name__)

# 登陆页面
@app.route(&#39;/&#39;, methods=[&#39;GET&#39;, &#39;POST&#39;])
def test():
    return render_template(&#39;index.html&#39;,name=&amp;quot;test poo!&amp;quot;)

if __name__ == &#39;__main__&#39;:
    app.run()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;运行应用&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;python flaskr.py
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;打开浏览器，访问 &lt;code&gt;http://localhost:5000&lt;/code&gt;，你将看到由 &lt;code&gt;Jinja2&lt;/code&gt; 模板渲染的页面，其中包含了从 &lt;code&gt;Flask&lt;/code&gt; 路由传递的变量。&lt;/p&gt;</description>  
      <pubDate>2025-10-09 17:54:40</pubDate>  
      <link>https://testpoo.github.io/Jinja2简介.html</link>  
      <guid isPermaLink="true">https://testpoo.github.io/Jinja2简介.html</guid>
       
      <category>技术</category> 
      
    </item>
    
    <item> 
      <title>shell三剑客简介</title>  
      <description>&lt;div class=&#34;toc&#34;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-shell&#34;&gt;1. shell三剑客简介&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-grep&#34;&gt;2. 三剑客之grep&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#21&#34;&gt;2.1. 常用参数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#22&#34;&gt;2.2. 示例&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3-sed&#34;&gt;3. 三剑客之sed&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#31&#34;&gt;3.1 常用参数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#32&#34;&gt;3.2. 示例&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4-awk&#34;&gt;4. 三剑客之awk&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#41&#34;&gt;4.1. 常用参数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#42&#34;&gt;4.2. 示例&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#43-beginend&#34;&gt;4.3. BEGIN和END&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#44&#34;&gt;4.4. 内置变量&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#45&#34;&gt;4.5. 运算符&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h3 id=&#34;1-shell&#34;&gt;1. shell三剑客简介&lt;/h3&gt;
&lt;p&gt;awk、grep、sed是linux操作文本的三大利器，合称文本三剑客，也是必须掌握的linux命令之一。三者的功能都是处理文本，但侧重点各不相同，其中属awk功能最强大，但也最复杂。grep更适合单纯的查找或匹配文本，sed更适合编辑匹配到的文本，awk更适合格式化文本，对文本进行较复杂格式处理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三剑客的特点:&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align: left;&#34;&gt;&lt;strong&gt;命令&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&#34;text-align: left;&#34;&gt;&lt;strong&gt;特点&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&#34;text-align: left;&#34;&gt;&lt;strong&gt;使用场景&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: left;&#34;&gt;grep&lt;/td&gt;
&lt;td style=&#34;text-align: left;&#34;&gt;擅长查找过滤&lt;/td&gt;
&lt;td style=&#34;text-align: left;&#34;&gt;快速查找过滤&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: left;&#34;&gt;sed&lt;/td&gt;
&lt;td style=&#34;text-align: left;&#34;&gt;擅长取行和替换&lt;/td&gt;
&lt;td style=&#34;text-align: left;&#34;&gt;需要快速进行替换/修改文件内容&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: left;&#34;&gt;awk&lt;/td&gt;
&lt;td style=&#34;text-align: left;&#34;&gt;擅长取列、统计计算&lt;/td&gt;
&lt;td style=&#34;text-align: left;&#34;&gt;文件取列、数据切片、对比/比较和统计&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;2-grep&#34;&gt;2. 三剑客之grep&lt;/h3&gt;
&lt;p&gt;grep 命令是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。grep全称是 Global Regular Expression Print，表示全局正则表达式版本，它的使用权限是所有用户。&lt;/p&gt;
&lt;p&gt;grep是文本查找或搜索工具，用于查找内容包含指定的范本样式的文本。它会一行一行循环匹配，匹配到相应的值时会先输出，然后换行继续匹配再换行直到所有的内容都匹配完。&lt;/p&gt;
&lt;p&gt;命令格式：&lt;code&gt;grep [option] pattern file&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;大家熟悉的命令：&lt;code&gt;ps -ef|grep xxxx&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;21&#34;&gt;2.1. 常用参数&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;-n：显示行号；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;-i：忽略大小写；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;-o：精准匹配；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;-f：从文件每一行获取匹配模式；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;-c：统计匹配的行数；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;-E：使用扩展正则表达式，相当于egrep；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;-v：反转查找，即输出与查找条件不相符合的行；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;-A：后面可加数字，为 after 的意思，除了列出该行外，后续的 n 行也列出来；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;-B：后面可加数字，为 before 的意思，除了列出该行外，前面的 n 行也列出来；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;-C：后面可加数字，为context 的意思，除了列出该行外，前后的n行也列出来。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;22&#34;&gt;2.2. 示例&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;1.&lt;/strong&gt; 查找多个文件中相同的内容&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-Shell&#34;&gt;$ grep &amp;quot;我们&amp;quot; one two

one:我们下午没有课
two:我们是祖国的花朵
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;2.&lt;/strong&gt; 输出two文件和one文件中相同的行&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;$ grep -n -f one two

3:心情挺好的
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;3.&lt;/strong&gt; 输出在two文件中不在one文件中的行&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;$ grep -v -f one two

我们是祖国的花朵
每天好开心啊
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;4.&lt;/strong&gt; 输出正则匹配到的内容&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;$ echo &amp;quot;this is a test shell!&amp;quot; |grep -oE &amp;quot;[a-z]+&amp;quot;

this
is
a
test
shell
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;5.&lt;/strong&gt; 只显示匹配的字符串&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;$ echo &amp;quot;this is a test&amp;quot; |grep -o &amp;quot;is&amp;quot;

is
is
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;6.&lt;/strong&gt; 匹配显示所有IP&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;$ ip a |grep -oE -0 &amp;quot;[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}&amp;quot;
127.0.0.1
--
192.168.214.2
192.168.214.255
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;3-sed&#34;&gt;3. 三剑客之sed&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;sed&lt;/code&gt; 是一种流编辑器，是非常好用的文本处理工具，配合正则使用更加强大。处理时，把当前处理的行存储在临时的缓冲区中，称为“模式空间”，接着 &lt;code&gt;sed&lt;/code&gt; 命令处理缓冲区的内容，完成后输出到屏幕，接着处理下一行。文件内容没有改变，除非使用 &lt;code&gt;-i&lt;/code&gt; 选项。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sed&lt;/code&gt; 主要用来编辑一个或多个文件，简化对文件的反复操作或者用来编写转换程序等。还有一个空间叫保持空间，又称暂存空间，可以暂时存放一些处理的数据，但不能直接输出，只能放到模式空间输出。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;语法格式：&lt;/strong&gt;&lt;code&gt;sed [选项] [地址] [命令] file&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;31&#34;&gt;3.1 常用参数&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;1.&lt;/strong&gt; 选项描述&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;-n：不打印模式空间；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;-e：执行脚本、表达式来处理；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;-f：执行动作从文件读取执行；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;-i：修改原文件；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;-r：使用扩展正则表达式。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;2.&lt;/strong&gt; 地址描述&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;first~step：步长，每step行，从第first开始；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$：匹配最后一行；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;/regexp/：正则表达式匹配行；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;number：只匹配指定行；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;addr1,addr2：开始匹配addr1行开始，直接addr2行结束；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;addr1,+N：从addr1行开始，向后的N行；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;addr1,~N：从addr1行开始，到N行结束。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;3.&lt;/strong&gt; 地址描述&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;s/regexp/replacement/：替换字符串；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;p：打印当前模式空间；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;P：打印模式空间的第一行；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;d：删除模式空间，开始下一个循环；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;D：删除模式空间的第一行，开始下一个循环；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;=：打印当前行号；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;a：当前行下面追加文本；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;i：当前行上面插入文本；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;c：所选行替换新文本；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;q：立即退出sed脚本；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;r：追加文本来自文件；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;: label：label为b和t命令；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;b label：分支到脚本中带有标签的位置，如果分支不存在则分支到脚本的末尾；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;t label：如果s///是一个成功的替换，才跳转到标签；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;h H：复制/追加模式空间到保持空间；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;g G：复制/追加保持空间到模式空间；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;x：交换模式空间和保持空间内容；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;y：把一个字符翻译为另外的字符；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;l：打印模式空间的行，并显示控制字符\$；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;n N：读取/追加下一行输入到模式空间；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;w filename：写入当前模式空间到文件；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;!：取反、否定；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&amp;amp;：引用已匹配字符串。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;32&#34;&gt;3.2. 示例&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;1.&lt;/strong&gt; 从第一个空格开始全局替换成 &lt;code&gt;-&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;$ echo &amp;quot;hello world&amp;quot; | sed &#39;s/ /-/g&#39;

hello-world
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;2.&lt;/strong&gt; 匹配替换字符串&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;$ echo &amp;quot;hello world&amp;quot; | sed &#39;s/world/[&amp;amp;]/&#39;

hello [world]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;3.&lt;/strong&gt; 打印指定行的内容&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;$ cat -n one
     1  今天天气不错
     2  挺风和日丽的
     3  我们下午没有课
     4  心情挺好的

$ sed -n &#39;2,4p&#39; one

挺风和日丽的
我们下午没有课
心情挺好的
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;4.&lt;/strong&gt; 读取一个文件的内容到另一个文件的匹配位置显示&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;# 把one的内容插入从three文件中通过&amp;quot;测试&amp;quot;匹配的“测试一下”后面，并打印出来
$ cat one
今天天气不错
挺风和日丽的
我们下午没有课
心情挺好的

$ cat three
测试一下

$ sed &amp;quot;/测试/r one&amp;quot; three
测试一下
今天天气不错
挺风和日丽的
我们下午没有课
心情挺好的
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;5.&lt;/strong&gt; 匹配一个文件的内容写入到另一个文件&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;# 把从one中通过“今天”匹配的“今天天气不错”写入four
$ sed &amp;quot;/今天/w four&amp;quot; one
今天天气不错
挺风和日丽的
我们下午没有课
心情挺好的

$ cat four
今天天气不错
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;6.&lt;/strong&gt; 在匹配行后追加插入内容&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;# 把“测试两下”插入到“今天”匹配的“今天天气不错”下面
$ sed &amp;quot;/^今天/a测试两下&amp;quot; one
今天天气不错
测试两下
挺风和日丽的
我们下午没有课
心情挺好的
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;7.&lt;/strong&gt; 读取一个文件的内容写入到另一个文件的匹配位置&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;# 加“-i”会直接写入文件
$ sed -i &amp;quot;/测试/r one&amp;quot; three
$ cat one
今天天气不错
挺风和日丽的
我们下午没有课
心情挺好的
$ cat three
测试一下
今天天气不错
挺风和日丽的
我们下午没有课
心情挺好的
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;8.&lt;/strong&gt; 用s///直接替换字符串&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;$ sed &amp;quot;s/今天/昨天/&amp;quot; one
昨天天气不错
挺风和日丽的
我们下午没有课
心情挺好的
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;9.&lt;/strong&gt; 分别用first~step语法和命令n语法打印奇数行&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;$ cat -n one
     1  今天天气不错
     2  挺风和日丽的
     3  我们下午没有课
     4  心情挺好的
$ sed -n &amp;quot;1~2p&amp;quot; one
今天天气不错
我们下午没有课



$ cat -n one
     1  今天天气不错
     2  挺风和日丽的
     3  我们下午没有课
     4  心情挺好的
$ sed -n &amp;quot;p;n&amp;quot; one
今天天气不错
我们下午没有课
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;10.&lt;/strong&gt; 分别用first~step语法和命令n语法打印偶数行&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;$ cat -n one
     1  今天天气不错
     2  挺风和日丽的
     3  我们下午没有课
     4  心情挺好的
$ sed -n &amp;quot;2~2p&amp;quot; one
挺风和日丽的
心情挺好的



$ cat -n one
     1  今天天气不错
     2  挺风和日丽的
     3  我们下午没有课
     4  心情挺好的
$ sed -n &amp;quot;n;p&amp;quot; one
挺风和日丽的
心情挺好的
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;4-awk&#34;&gt;4. 三剑客之awk&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;awk&lt;/code&gt; 是一个处理文本的编程语言工具，能用简短的程序处理标准输入或文件、数据排序、计算以及生成报表等等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;命令格式&lt;/strong&gt;：&lt;code&gt;awk option &#39;pattern {action}&#39; file&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;其中pattern表示AWK在数据中查找的内容，而action是在找到匹配内容时所执行的一系列命令。花括号用于根据特定的模式对一系列指令进行分组。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;awk处理的工作方式与数据库类似，支持对记录和字段处理，这也是grep和sed不能实现的。&lt;/p&gt;
&lt;p&gt;在awk中，缺省的情况下将文本文件中的一行视为一个记录，逐行放到内存中处理，而将一行中的某一部分作为记录中的一个字段。用1,2,3...数字的方式顺序的表示行（记录）中的不同字段。用\$后跟数字，引用对应的字段，以逗号分隔，0表示整个行。&lt;/p&gt;
&lt;h4 id=&#34;41&#34;&gt;4.1. 常用参数&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;1. 选项&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;-f program-file：从文件中读取awk程序源文件；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;-F fs：指定fs为输入字段分隔符；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;-v var=value：变量赋值；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;--posix：兼容POSIX正则表达式；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;--dump-variables=[file]：把awk命令时的全局变量写入文件，默认文件是awkvars.out；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;--profile=[file]：格式化awk语句到文件，默认是awkprof.out。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;2. 常用模式&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align: left;&#34;&gt;&lt;strong&gt;Pattern&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&#34;text-align: left;&#34;&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: left;&#34;&gt;BEGIN{ }&lt;/td&gt;
&lt;td style=&#34;text-align: left;&#34;&gt;给程序赋予初始状态，先执行的工作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: left;&#34;&gt;END{ }&lt;/td&gt;
&lt;td style=&#34;text-align: left;&#34;&gt;程序结束之后执行的一些扫尾工作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: left;&#34;&gt;/regular expression/&lt;/td&gt;
&lt;td style=&#34;text-align: left;&#34;&gt;为每个输入记录匹配正则表达式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: left;&#34;&gt;pattern &amp;amp;&amp;amp; pattern&lt;/td&gt;
&lt;td style=&#34;text-align: left;&#34;&gt;逻辑and，满足两个模式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: left;&#34;&gt;pattern&lt;/td&gt;
&lt;td style=&#34;text-align: left;&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: left;&#34;&gt;! pattern&lt;/td&gt;
&lt;td style=&#34;text-align: left;&#34;&gt;逻辑not，不满足模式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: left;&#34;&gt;pattern1, pattern2&lt;/td&gt;
&lt;td style=&#34;text-align: left;&#34;&gt;范围模式，匹配所有模式1的记录，直到匹配到模式2&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;42&#34;&gt;4.2. 示例&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;1.&lt;/strong&gt; 从文件读取awk程序处理文件&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;$ nano test.awk
{print $2}
$ tail -n3 /etc/services |awk -f test.awk
60179/tcp

Local
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;2.&lt;/strong&gt; 指定分隔符，打印指定字段，默认以空格分隔&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;$ tail -n3 /etc/services |awk &#39;{print $2}&#39;
60179/tcp

Local
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;3.&lt;/strong&gt; 指定冒号为分隔符打印&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;# 这里要用单印号
$ tail -n5 /etc/passwd | awk -F &#39;:&#39; &#39;{print $1}&#39;
polkitd
rtkit
colord
poo
sshd
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;43-beginend&#34;&gt;4.3. BEGIN和END&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;语法结构:&lt;/strong&gt; &lt;code&gt;awk &#39;BEGIN{ print &#34;start&#34; } pattern{ commands } END { print &#34;end&#34; }&#39; filename&lt;/code&gt; ，BEGIN语句+模式匹配+END语句三个部分组成，这三个部分都是可选项。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;工作原理&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;第一步执行BEGIN语句；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第二步从文件或标准输入读取一行，然后再执行行pattern语句，逐行扫描文件到文件全部被读取；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第三步执行END语句。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.&lt;/strong&gt; 通过print参数打印&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;$ echo &amp;quot;hello&amp;quot; | awk &#39;BEGIN{print &amp;quot;welcome&amp;quot;} {print} END{print &amp;quot;this is a test of awk&amp;quot;}&#39;
welcome
hello
this is a test of awk
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;2.&lt;/strong&gt; 初始化标题打印&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;$ tail /etc/services | awk &#39;BEGIN{print &amp;quot;Service\t\tPort\t\t\tDescription\n&amp;quot;}{print $0}&#39;
Service         Port                    Description

sgi-cad         17004/tcp                       # Cluster Admin daemon
binkp           24554/tcp                       # binkp fidonet protocol
asp             27374/tcp                       # Address Search Protocol
asp             27374/udp
csync2          30865/tcp                       # cluster synchronization tool
dircproxy       57000/tcp                       # Detachable IRC Proxy
tfido           60177/tcp                       # fidonet EMSI over telnet
fido            60179/tcp                       # fidonet EMSI over TCP

# Local services
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;3.&lt;/strong&gt; 使用print逗号分隔时，打印则是以空格分界&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;$ echo | awk &#39;{a=&amp;quot;This is&amp;quot;; b=&amp;quot;a test&amp;quot;; c=&amp;quot;of awk&amp;quot;;print a,b,c}&#39;

This is a test of awk
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;44&#34;&gt;4.4. 内置变量&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align: left;&#34;&gt;&lt;strong&gt;变量名&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&#34;text-align: left;&#34;&gt;&lt;strong&gt;描述&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: left;&#34;&gt;$0&lt;/td&gt;
&lt;td style=&#34;text-align: left;&#34;&gt;当前记录&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: left;&#34;&gt;$1~$n&lt;/td&gt;
&lt;td style=&#34;text-align: left;&#34;&gt;当前记录的第N个字段&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: left;&#34;&gt;FS&lt;/td&gt;
&lt;td style=&#34;text-align: left;&#34;&gt;输入字段分隔符（-F作用相同）默认空格&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: left;&#34;&gt;OFS&lt;/td&gt;
&lt;td style=&#34;text-align: left;&#34;&gt;输出字段分隔符，默认是空格&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: left;&#34;&gt;RS&lt;/td&gt;
&lt;td style=&#34;text-align: left;&#34;&gt;输入记录分隔符，默认换行符\n&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: left;&#34;&gt;ORS&lt;/td&gt;
&lt;td style=&#34;text-align: left;&#34;&gt;输出记录分隔符，默认是换行符\n&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: left;&#34;&gt;NF&lt;/td&gt;
&lt;td style=&#34;text-align: left;&#34;&gt;字段个数/列个数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: left;&#34;&gt;NR&lt;/td&gt;
&lt;td style=&#34;text-align: left;&#34;&gt;统计记录编号，每处理一行记录，编号就会+1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: left;&#34;&gt;FNR&lt;/td&gt;
&lt;td style=&#34;text-align: left;&#34;&gt;统计记录编号，每处理一行记录，编号也会+1，与NR不同的是，处理第二个文件时，编号会重新计数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: left;&#34;&gt;OFS&lt;/td&gt;
&lt;td style=&#34;text-align: left;&#34;&gt;输出字段分隔符，默认空格&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: left;&#34;&gt;IGNORECASE&lt;/td&gt;
&lt;td style=&#34;text-align: left;&#34;&gt;忽略大小写&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.&lt;/strong&gt; FS&lt;/p&gt;
&lt;p&gt;创建带空格的测试文件，查看前赋值FS变量，改变默认分空隔符为冒号。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;$ cat test1.awk
aa:bb:cc
dd:ee:ff
$ awk &#39;BEGIN{FS=&amp;quot;:&amp;quot;}{print $1,$2,$3}&#39; test1.awk
aa bb cc
dd ee ff
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;2.&lt;/strong&gt; OFS，&lt;code&gt;OFS&lt;/code&gt; 可以理解为 &lt;code&gt;FS&lt;/code&gt; 的逆向过程，即将输出字段的分隔符改为空格&lt;/p&gt;
&lt;p&gt;创建带：的测试文件，查看前赋值 &lt;code&gt;OFS&lt;/code&gt; 变量，改变默认：隔符为空格。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;$ cat test2.awk
aa bb cc
dd ee ff
$ awk &#39;BEGIN{OFS=&amp;quot;:&amp;quot;}{print $1,$2,$3}&#39; test2.awk
aa:bb:cc
dd:ee:ff
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;3.&lt;/strong&gt; RS，匹配分隔符号，默认以\n分隔每行&lt;/p&gt;
&lt;p&gt;将/替换为换行（\n）输出：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;$ echo &amp;quot;RS/test/of/awk&amp;quot; | awk &#39;BEGIN{RS=&amp;quot;/&amp;quot;}{print $0}&#39;
RS
test
of
awk
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;4.&lt;/strong&gt; ORS，匹配每个记录的换行符（\n）,替换为指定的符号&lt;/p&gt;
&lt;p&gt;将换行（\n）替换为+：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;$ seq 10 | awk &#39;BEGIN{ORS=&amp;quot;+&amp;quot;}{print $0} END{print &amp;quot;\n&amp;quot;}&#39;

1+2+3+4+5+6+7+8+9+10+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;5.&lt;/strong&gt; NF，字段个数/列个数&lt;/p&gt;
&lt;p&gt;打印字段个数：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;$ echo &amp;quot;a b c d e f&amp;quot; | awk &#39;{print NF}&#39;

6
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;打印最后一个字段：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;$ echo &amp;quot;a b c d e f&amp;quot; | awk &#39;{print $NF}&#39;

f
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;打印倒数第二个字段：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;$ echo &amp;quot;a b c d e f&amp;quot; | awk &#39;{print $(NF-1)}&#39;
e
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;排除最后两个字段：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;$ echo &amp;quot;a b c d e f&amp;quot; | awk &#39;{$NF=&amp;quot;&amp;quot;;$(NF-1)=&amp;quot;&amp;quot;;print $0}&#39;
a b c d
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;排除第一个字段：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;$ echo &amp;quot;a b c d e f&amp;quot; | awk &#39;{$1=&amp;quot;&amp;quot;;print $0}&#39;
 b c d e f
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;45&#34;&gt;4.5. 运算符&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align: left;&#34;&gt;&lt;strong&gt;运算符&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&#34;text-align: left;&#34;&gt;&lt;strong&gt;描述&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: left;&#34;&gt;（....）&lt;/td&gt;
&lt;td style=&#34;text-align: left;&#34;&gt;分组&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: left;&#34;&gt;$&lt;/td&gt;
&lt;td style=&#34;text-align: left;&#34;&gt;字段引用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: left;&#34;&gt;++ --&lt;/td&gt;
&lt;td style=&#34;text-align: left;&#34;&gt;递增和递减&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: left;&#34;&gt;+ - !&lt;/td&gt;
&lt;td style=&#34;text-align: left;&#34;&gt;加号，减号，和逻辑否定&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: left;&#34;&gt;* / %&lt;/td&gt;
&lt;td style=&#34;text-align: left;&#34;&gt;乘，除和取余&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: left;&#34;&gt;+ -&lt;/td&gt;
&lt;td style=&#34;text-align: left;&#34;&gt;加法，减法&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: left;&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: left;&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: left;&#34;&gt;&amp;lt; &amp;gt; &amp;lt;= &amp;gt;= != ==&lt;/td&gt;
&lt;td style=&#34;text-align: left;&#34;&gt;关系运算符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: left;&#34;&gt;~ !~&lt;/td&gt;
&lt;td style=&#34;text-align: left;&#34;&gt;正则表达式匹配，否定正则表达式匹配&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: left;&#34;&gt;in&lt;/td&gt;
&lt;td style=&#34;text-align: left;&#34;&gt;数组成员&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: left;&#34;&gt;&amp;amp;&amp;amp;&lt;/td&gt;
&lt;td style=&#34;text-align: left;&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: left;&#34;&gt;?:&lt;/td&gt;
&lt;td style=&#34;text-align: left;&#34;&gt;简写条件表达式：expr1 ? expr2 : expr3第一个表达式为真，执行expr2，否则执行expr3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: left;&#34;&gt;= += -= *= /= %= ^=&lt;/td&gt;
&lt;td style=&#34;text-align: left;&#34;&gt;变量赋值运算符&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;示例:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.&lt;/strong&gt; 求和&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;$ awk &#39;BEGIN{a=2;b=3; print a+b }&#39;

5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;2.&lt;/strong&gt; 感叹号 否定匹配&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;$ tail /etc/services |awk &#39;!/blp5/{print $0}&#39;

sgi-cad         17004/tcp                       # Cluster Admin daemon
binkp           24554/tcp                       # binkp fidonet protocol
asp             27374/tcp                       # Address Search Protocol
asp             27374/udp
csync2          30865/tcp                       # cluster synchronization tool
dircproxy       57000/tcp                       # Detachable IRC Proxy
tfido           60177/tcp                       # fidonet EMSI over telnet
fido            60179/tcp                       # fidonet EMSI over TCP

# Local services
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;3.&lt;/strong&gt; 求余&lt;/p&gt;
&lt;p&gt;打印偶数行&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;$ seq 5 |awk &#39;$0%2==0{print $0}&#39;

2
4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;打印奇数行&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;$ seq 5 |awk &#39;$0%2!=0{print $0}&#39;
1
3
5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;4.&lt;/strong&gt; 正则表达式匹配&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;$ seq 5 |awk &#39;$0%2!=0{print $0}&#39;
1
3
5

$ seq 5 |awk &#39;$0!~/[34]/{print $0}&#39;
1
2
5

$ seq 5 |awk &#39;$0!~/[^34]/{print $0}&#39;
3
4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;5.&lt;/strong&gt; ?: 条件表达式，也叫三目运算&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;$ awk &#39;BEGIN{print 1==1?&amp;quot;yes&amp;quot;:&amp;quot;no&amp;quot;}&#39;
yes

$ awk &#39;BEGIN{print 1==2?&amp;quot;yes&amp;quot;:&amp;quot;no&amp;quot;}&#39;
no
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;6.&lt;/strong&gt; 变量赋值&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;$ seq 5 |awk &#39;{sum+=$0}END{print sum}&#39;

15
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;6. 流程控制&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;if&lt;/code&gt; 语句&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;格式：&lt;/strong&gt;&lt;code&gt;if (condition) statement [ else statement ]&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;$ seq 5 |awk &#39;{if($0==3)print $0}&#39;
3

$ seq 5 |awk &#39;{if($0==3)print $0;else print &amp;quot;no&amp;quot;}&#39;
no
no
3
no
no
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;while&lt;/code&gt; 语句&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;格式：&lt;/strong&gt;&lt;code&gt;while (condition) statement&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;遍历打印所有字段。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-Shell&#34;&gt;$ awk &#39;{i=1;while(i&amp;lt;=NF){print $i;i++}}&#39; one

今天天气不错
挺风和日丽的
我们下午没有课
心情挺好的
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;for&lt;/code&gt; 语句&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;格式：&lt;/strong&gt;&lt;code&gt;for (expr1; expr2; expr3) statement&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;遍历打印所有字段。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-Shell&#34;&gt;$ awk &#39;{for(i=1;i&amp;lt;=NF;i++)print $i}&#39; one

今天天气不错
挺风和日丽的
我们下午没有课
心情挺好的
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;break&lt;/code&gt; 和 &lt;code&gt;continue&lt;/code&gt; 语句&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;break&lt;/code&gt; 跳过所有循环，&lt;code&gt;continue&lt;/code&gt; 跳过当前循环。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-Shell&#34;&gt;$ awk &#39;BEGIN{for(i=1;i&amp;lt;=5;i++){if(i==3){break};print i}}&#39;
1
2

$ awk &#39;BEGIN{for(i=1;i&amp;lt;=5;i++){if(i==3){continue};print i}}&#39;
1
2
4
5
&lt;/code&gt;&lt;/pre&gt;</description>  
      <pubDate>2025-10-09 17:54:40</pubDate>  
      <link>https://testpoo.github.io/shell三剑客简介.html</link>  
      <guid isPermaLink="true">https://testpoo.github.io/shell三剑客简介.html</guid>
       
      <category>技术</category> 
      
    </item>
    
    <item> 
      <title>Python造假数据神器Faker</title>  
      <description>&lt;div class=&#34;toc&#34;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1&#34;&gt;1. 简介&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#11&#34;&gt;1.1. 安装&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#12&#34;&gt;1.2 查看帮助&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#13&#34;&gt;1.3 官方文档&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2&#34;&gt;2. 简单使用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3-locale&#34;&gt;3. 参数 locale&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4&#34;&gt;4. 其他方法&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#41&#34;&gt;4.1 地理信息类&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#42&#34;&gt;4.2 基础信息类&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#43&#34;&gt;4.3 邮箱信息类&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#44&#34;&gt;4.4 网络基础信息类&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#45&#34;&gt;4.5 浏览器信息类&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#46&#34;&gt;4.6 数字信息&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#47&#34;&gt;4.7 文本加密类&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#48&#34;&gt;4.8 文件信息类&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#49&#34;&gt;4.9 时间信息类&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#410&#34;&gt;4.10 集合信息类&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5&#34;&gt;5. 实战使用&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h3 id=&#34;1&#34;&gt;1. 简介&lt;/h3&gt;
&lt;p&gt;Faker 是一个 Python 包，可以为您生成虚假数据。无论您是需要引导数据库，创建外观漂亮的 XML 文档，填写持久性来对其进行压力测试，还是匿名化从生产服务中获取的数据，Faker 都适合您。&lt;/p&gt;
&lt;h4 id=&#34;11&#34;&gt;1.1. 安装&lt;/h4&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;pip install Faker
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;12&#34;&gt;1.2 查看帮助&lt;/h4&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;(faker) E:\project\faker&amp;gt;faker -h
usage: faker [-h] [--version] [-v] [-o output] [-l LOCALE] [-r REPEAT] [-s SEP] [--seed SEED] [-i [INCLUDE ...]] [fake] [fake argument ...]

faker version 23.2.1

positional arguments:
  fake                  name of the fake to generate output for (e.g. profile)
  fake argument         optional arguments to pass to the fake (e.g. the profile fake takes an optional list of comma separated field names as the first argument)

options:
  -h, --help            show this help message and exit
  --version             show program&#39;s version number and exit
  -v, --verbose         show INFO logging events instead of CRITICAL, which is the default. These logging events provide insight into localization of specific providers.
  -o output             redirect output to a file
  -l LOCALE, --lang LOCALE
                        specify the language for a localized provider (e.g. de_DE)
  -r REPEAT, --repeat REPEAT
                        generate the specified number of outputs
  -s SEP, --sep SEP     use the specified separator after each output
  --seed SEED           specify a seed for the random generator so that results are repeatable. Also compatible with &#39;repeat&#39; option
  -i [INCLUDE ...], --include [INCLUDE ...]
                        list of additional custom providers to user, given as the import path of the module containing your Provider class (not the provider class itself)

supported locales:

  ar_AA, ar_AE, ar_BH, ar_EG, ar_JO, ar_PS, ar_SA, az_AZ, bg_BG, bn_BD, bs_BA, cs_CZ, da_DK, de, de_AT, de_CH, de_DE, dk_DK, el_CY, el_GR, en, en_AU, en_BD, en_CA, en_GB, en_IE, en_IN, en_NZ, en_PH, en_TH, en_US, es, es_AR, es_CA, es_CL, es_CO, es_ES, es_MX, et_EE, fa_IR, fi_FI, fil_PH, fr_BE, fr_CA, fr_CH, fr_FR, fr_QC, ga_IE, he_IL, hi_IN, hr_HR, hu_HU, hy_AM, id_ID, it_CH, it_IT, ja_JP, ka_GE, ko_KR, la, lb_LU, lt_LT, lv_LV, mt_MT, ne_NP, nl_BE, nl_NL, no_NO, or_IN, pl_PL, pt_BR, pt_PT, ro_RO, ru_RU, sk_SK, sl_SI, sq_AL, sv_SE, ta_IN, th, th_TH, tl_PH, tr_TR, tw_GH, uk_UA, vi_VN, zh_CN, zh_TW, zu_ZA

  Faker can take a locale as an optional argument, to return localized data. If
  no locale argument is specified, the factory falls back to the user&#39;s OS
  locale as long as it is supported by at least one of the providers.
     - for this user, the default locale is en_US.

  If the optional argument locale and/or user&#39;s default locale is not available
  for the specified provider, the factory falls back to faker&#39;s default locale,
  which is en_US.

examples:

  $ faker address
  968 Bahringer Garden Apt. 722
  Kristinaland, NJ 09890

  $ faker -l de_DE address
  Samira-Niemeier-Allee 56
  94812 Biedenkopf

  $ faker profile ssn,birthdate
  {&#39;ssn&#39;: u&#39;628-10-1085&#39;, &#39;birthdate&#39;: &#39;2008-03-29&#39;}

  $ faker -r=3 -s=&amp;quot;;&amp;quot; name
  Willam Kertzmann;
  Josiah Maggio;
  Gayla Schmitt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;13&#34;&gt;1.3 官方文档&lt;/h4&gt;
&lt;p&gt;faker官方文档：&lt;a href=&#34;https://faker.readthedocs.io/en/latest/index.html&#34;&gt;https://faker.readthedocs.io/en/latest/index.html&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;2&#34;&gt;2. 简单使用&lt;/h3&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; from faker import Faker
&amp;gt;&amp;gt;&amp;gt; fake = Faker(locale=&#39;zh_CN&#39;)
&amp;gt;&amp;gt;&amp;gt; fake.name()
&#39;曹洋&#39;
&amp;gt;&amp;gt;&amp;gt; fake.address()
&#39;西藏自治区玉英县六枝特长春街m座 669309&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;3-locale&#34;&gt;3. 参数 locale&lt;/h3&gt;
&lt;p&gt;参数为生成数据的文化选项（语种），默认为 en_US，只有使用了相关文化，才能生成相对应的随机信息。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align: left;&#34;&gt;参数&lt;/th&gt;
&lt;th style=&#34;text-align: left;&#34;&gt;说明&lt;/th&gt;
&lt;th style=&#34;text-align: left;&#34;&gt;用法&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: left;&#34;&gt;zh_CN&lt;/td&gt;
&lt;td style=&#34;text-align: left;&#34;&gt;中文简体&lt;/td&gt;
&lt;td style=&#34;text-align: left;&#34;&gt;Faker(locale=&#39;zh_CN&#39;)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: left;&#34;&gt;zh_TW&lt;/td&gt;
&lt;td style=&#34;text-align: left;&#34;&gt;中文繁体&lt;/td&gt;
&lt;td style=&#34;text-align: left;&#34;&gt;Faker(locale=&#39;zh_TW&#39;)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: left;&#34;&gt;en_US&lt;/td&gt;
&lt;td style=&#34;text-align: left;&#34;&gt;英语（美国）&lt;/td&gt;
&lt;td style=&#34;text-align: left;&#34;&gt;Faker(locale=&#39;en_US&#39;)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: left;&#34;&gt;en_GB&lt;/td&gt;
&lt;td style=&#34;text-align: left;&#34;&gt;英语（英国）&lt;/td&gt;
&lt;td style=&#34;text-align: left;&#34;&gt;Faker(locale=&#39;en_GB&#39;)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: left;&#34;&gt;de_DE&lt;/td&gt;
&lt;td style=&#34;text-align: left;&#34;&gt;德语&lt;/td&gt;
&lt;td style=&#34;text-align: left;&#34;&gt;Faker(locale=&#39;de_DE&#39;)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: left;&#34;&gt;ja_JP&lt;/td&gt;
&lt;td style=&#34;text-align: left;&#34;&gt;日语&lt;/td&gt;
&lt;td style=&#34;text-align: left;&#34;&gt;Faker(locale=&#39;ja_JP&#39;)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: left;&#34;&gt;ko_KR&lt;/td&gt;
&lt;td style=&#34;text-align: left;&#34;&gt;韩语&lt;/td&gt;
&lt;td style=&#34;text-align: left;&#34;&gt;Faker(locale=&#39;ko_KR&#39;)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: left;&#34;&gt;fr_FR&lt;/td&gt;
&lt;td style=&#34;text-align: left;&#34;&gt;法语&lt;/td&gt;
&lt;td style=&#34;text-align: left;&#34;&gt;Faker(locale=&#39;fr_FR&#39;)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: left;&#34;&gt;es_ES&lt;/td&gt;
&lt;td style=&#34;text-align: left;&#34;&gt;西班牙语&lt;/td&gt;
&lt;td style=&#34;text-align: left;&#34;&gt;Faker(locale=&#39;zh_CN&#39;)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: left;&#34;&gt;……&lt;/td&gt;
&lt;td style=&#34;text-align: left;&#34;&gt;……&lt;/td&gt;
&lt;td style=&#34;text-align: left;&#34;&gt;……&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;还有很多其他的语言，部分列举&lt;/p&gt;
&lt;h3 id=&#34;4&#34;&gt;4. 其他方法&lt;/h3&gt;
&lt;h4 id=&#34;41&#34;&gt;4.1 地理信息类&lt;/h4&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-Python&#34;&gt;city_suffix()：市，县
# 市 或 县
country()：国家
# 葡萄牙
country_code()：国家编码
# IN
district()：区
# 黄浦
coordinate()：地理坐标
# Decimal(&#39;-6.314017&#39;)
latitude()：地理坐标(纬度)
# Decimal(&#39;-52.842700&#39;)
longitude()：地理坐标(经度)
# Decimal(&#39;-103.420509&#39;)
postcode()：邮编
# 930438
province()：省份
# 贵州省
address()：详细地址
# 江西省荆门市山亭宜都街G座 379902
street_address()：街道地址
# 王路H座
street_name()：街道名
# 刘路
street_suffix()：街、路
# 街 或 路
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;42&#34;&gt;4.2 基础信息类&lt;/h4&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-Python&#34;&gt;ssn()：生成身份证号
# 460105195602289565
bs()：随机公司服务名
# synthesize wireless channels
company()：随机公司名（长）
# 快讯科技有限公司
company_prefix()：随机公司名（短）
# 时刻
company_suffix()：公司性质，如&#39;信息有限公司&#39;
# 传媒有限公司
credit_card_expire()：随机信用卡到期日，如&#39;03/30&#39;
# 08/27
credit_card_full()：生成完整信用卡信息
# VISA 13 digit
# 佳 魏
# 4510659631299 09/27
# CVC: 292
credit_card_number()：信用卡号
# 4841223722482
credit_card_provider()：信用卡类型
# Mastercard
credit_card_security_code()：信用卡安全码
# 511
job()：随机职位
# 临床协调员
first_name()：第一个名字
# 莉
first_name_female()：女性名
# 军
first_name_male()：男性名
# 军
first_romanized_name()：罗马名
# ping
last_name()：最后一个名字
# 谢
last_name_female()：女姓
# 韩
last_name_male()：男姓
# 顾
last_romanized_name()：罗马姓氏
# Feng
name()：随机生成全名
# 彭华
name_female()：男性全名
# 任宁
name_male()：女性全名
# 王俊
romanized_name()：罗马名
# Juan Sun
msisdn()：移动台国际用户识别码，即移动用户的ISDN号码
# 9271661830556
phone_number()：随机生成手机号
# 15237436258
phonenumber_prefix()：随机生成手机号段，如139
# 180
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;43&#34;&gt;4.3 邮箱信息类&lt;/h4&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-Cython&#34;&gt;ascii_company_email()：随机ASCII公司邮箱名
# ming81@wangwang.cn
ascii_email()：随机ASCII邮箱
# xiamin@guiyingjing.cn
ascii_free_email()：随机ASCII免费邮箱
# yan93@gmail.com
ascii_safe_email()：随机ASCII安全邮箱
# yeyan@example.com
company_email()：公司邮箱
# yong66@leizheng.cn
email()：普通邮箱
# leixiang@example.net
free_email()：免费邮箱
# osun@gmail.com
free_email_domain()：免费邮箱域
# http://hotmail.com
safe_email()：安全邮箱
# wdu@example.org
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;44&#34;&gt;4.4 网络基础信息类&lt;/h4&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-Cython&#34;&gt;domain_name()：生成域名
# jing.cn
domain_word()：域词(即，不包含后缀)
# qiang
ipv4()：随机IP4地址
# 188.216.215.251
ipv6()：随机IP6地址
# df53:6891:74b9:7177:98ec:44b3:3498:7c69
mac_address()：随机MAC地址
# f0:1e:24:b3:b7:e8
tld()：网址域名后缀(.com,.net.cn,等等，不包括.)
# cn
uri()：随机URI地址
# http://46.cn/searchindex.php
uri_extension()：网址文件后缀
# .php
uri_page()：网址文件（不包含后缀）
# main
uri_path()：网址文件路径（不包含文件名）
# search/category
url()：随机URL地址
# https://www.rencao.cn/
user_name()：随机用户名
# jgao
image_url()：随机URL地址
# https://picsum.photos/619/449
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;45&#34;&gt;4.5 浏览器信息类&lt;/h4&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-Cython&#34;&gt;chrome()：随机生成Chrome的浏览器user_agent信息
# Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_2) AppleWebKit/533.1 (KHTML, like Gecko) Chrome/16.0.879.0 Safari/533.1
firefox()：随机生成FireFox的浏览器user_agent信息
# Mozilla/5.0 (Macintosh; U; PPC Mac OS X 10_12_2; rv:1.9.3.20) Gecko/8618-06-21 05:10:08 Firefox/3.6.4
internet_explorer()：随机生成IE的浏览器user_agent信息
# Mozilla/5.0 (compatible; MSIE 9.0; Windows 98; Win 9x 4.90; Trident/3.0)
opera()：随机生成Opera的浏览器user_agent信息
# Opera/8.47.(Windows NT 6.1; kok-IN) Presto/2.9.178 Version/12.00
safari()：随机生成Safari的浏览器user_agent信息
# Mozilla/5.0 (Macintosh; U; PPC Mac OS X 10_7_6 rv:5.0; mr-IN) AppleWebKit/535.25.4 (KHTML, like Gecko) Version/4.1 Safari/535.25.4
linux_platform_token()：随机Linux信息
# X11; Linux i686
user_agent()：随机user_agent信息
# Mozilla/5.0 (Windows; U; Windows 98; Win 9x 4.90) AppleWebKit/534.34.6 (KHTML, like Gecko) Version/5.1 Safari/534.34.6
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;46&#34;&gt;4.6 数字信息&lt;/h4&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-Cython&#34;&gt;numerify()：三位随机数字
# 865
random_digit()：0~9随机数
# 5
random_digit_not_null()：1~9的随机数
# 7
random_int()：随机数字，默认0~9999，可以通过设置min,max来设置
# 2497
random_number()：随机数字，参数digits设置生成的数字位数
# 25011312
pyfloat()：随机Float数字
# 955.707810796746
pyint()：随机Int数字（参考random_int()参数）
# 2673
pydecimal()：随机Decimal数字（参考pyfloat参数）
# 9371388754385663915393032330587677.707987943449603003369594742167786
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;47&#34;&gt;4.7 文本加密类&lt;/h4&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-Cython&#34;&gt;pystr()：随机字符串
# VXaBYNWVfBNuvoLNAkYc
random_element()：随机字母
# c
random_letter()：随机字母
# R
paragraph()：随机生成一个段落
# 男人安全质量一起程序业务起来.因此非常浏览基本.
paragraphs()：随机生成多个段落
# [&#39;女人任何在线登录到了精华管理.功能这个来源学生选择根据孩子.工具决定内容法律基本查看.&#39;, &#39;不断有限大小下载.作者本站注意其中等级然后觉得.需要语言孩子作者手机积分.&#39;, &#39;合作操作选择.希望同时决定最大管理.一次业务软件只是社区因为查看.密码在线加入 显示这么.&#39;]
sentence()：随机生成一句话
# 最后回复就是上海出现不同.
sentences()：随机生成多句话，与段落类似
# [&#39;表示标题如果那些地区质量电话.&#39;, &#39;东西这个责任完全.&#39;, &#39;一起影响留言类型有限来自只有.&#39;]
text()：随机生成一篇文章
# 情况北京城市.技术没有可以安全政府完全电影.注意设备科技.
# 主题已经或者的人.方式信息如果关于看到不是.留言报告详细标题相关基本.
# 表示有些他们这里.制作就是成为方法希望他的电子单位.过程语言论坛可是.
# 法律客户程序报告有限只要表示.最新时候无法计划.目前相关不是深圳我的.
# 密码包括那么.地址一直说明商品.
# 一点显示设备最新最大功能我的国内.日期知道原因.目前朋友重要.
word()：随机生成词语
# 活动
words()：随机生成多个词语，用法与段落，句子，类似
# [&#39;朋友&#39;, &#39;经验&#39;, &#39;出现&#39;]
binary()：随机生成二进制编码
boolean()：True/False
# False
language_code()：随机生成两位语言编码
# iu
locale()：随机生成语言/国际 信息
# kw_GB
md5()：随机生成MD5
# 56065e546f9cf078702e713c6981ce35
null_boolean()：NULL/True/False
# True
password()：随机生成密码,可选参数：length：密码长度；special_chars：是否能使用特殊字符；digits：是否包含数字；upper_case：是否包含大写字母；lower_case：是否包含小写字母
# $68W0+xp$+
sha1()：随机SHA1
# 3030de488299d4ed76806447e3741201ba9a326a
sha256()：随机SHA256
# 42bc239bd183f2e3f60ec54fceabc2eca4074f8d3598bedd685985d20c863e07
uuid4()：随机UUID
# c0424eb8-6793-42fa-b2b8-01ce7d5db3c9
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;48&#34;&gt;4.8 文件信息类&lt;/h4&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-Shell&#34;&gt;file_extension()：随机文件扩展名
# json
file_name()：随机文件名（包含扩展名，不包含路径）
# 这是.
gif file_path()：随机文件路径（包含文件名，扩展名）
# /新闻/具有.
odp mime_type()：随机mime Type
# multipart/related
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;49&#34;&gt;4.9 时间信息类&lt;/h4&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-Cython&#34;&gt;am_pm()：AM/PM
# PM
century()：随机世纪
# XII
date()：随机日期
# 2001-04-07
date_between()：随机生成指定范围内日期，参数：start_date，end_date取值：具体日期或者today,-30d,-30y类似
# 2011-04-21
date_between_dates()：随机生成指定范围内日期，用法同上
# 2022-11-15
date_object()：随机生产从1970-1-1到指定日期的随机日期。
# 2014-12-12
date_this_month()：现在这个月的日期
# 2022-11-12
date_this_year()：现在这一年的日期
# 2022-02-16
date_time()：随机生成指定时间（1970年1月1日至今）
# 1988-07-07 04:42:25
date_time_ad()：生成公元1年到现在的随机时间
# 1658-11-20 09:19:22
date_time_between()：用法同dates
# 2001-06-05 01:11:45
future_date()：未来日期
# 2022-12-02
future_datetime()：未来时间
# 2022-11-28 06:07:21
month()：随机月份
# 10
month_name()：随机月份（汉语）
# 十二月
past_date()：随机生成已经过去的日期
# 2022-11-06
past_datetime()：随机生成已经过去的时间
# 2022-10-28 18:36:07
time()：随机24小时时间
# 05:58:43
timedelta()：随机获取时间差
# /
time_object()：随机24小时时间，time对象
# 19:28:21
time_series()：随机TimeSeries对象
# &amp;lt;generator object Provider.time_series at 0x7fc346f30190&amp;gt;
timezone()：随机时区
# America/Noronha
unix_time()：随机Unix时间
# 55170123
year()：随机年份
# 1979
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;410&#34;&gt;4.10 集合信息类&lt;/h4&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-Cython&#34;&gt;profile()：随机生成档案信息
# {&#39;job&#39;: &#39;高级建筑工程师/总工&#39;, &#39;company&#39;: &#39;诺依曼软件传媒有限公司&#39;, &#39;ssn&#39;: &#39;230822195904280066&#39;, &#39;residence&#39;: &#39;湖南省玉梅县高明符路J座 227449&#39;, &#39;current_location&#39;: (Decimal(&#39;75.297849&#39;), Decimal(&#39;-0.733280&#39;)), &#39;blood_group&#39;: &#39;A+&#39;, &#39;website&#39;: [&#39;https://guiyingxiulan.cn/&#39;, &#39;http://yanxiuying.net/&#39;], &#39;username&#39;: &#39;yangliu&#39;, &#39;name&#39;: &#39;徐玉梅&#39;, &#39;sex&#39;: &#39;F&#39;, &#39;address&#39;: &#39;甘肃省红霞市永川李路K座 215966&#39;, &#39;mail&#39;: &#39;wliang@hotmail.com&#39;, &#39;birthdate&#39;: datetime.date(1960, 11, 28)}
simple_profile()：随机生成简单档案信息
# {&#39;username&#39;: &#39;qianghuang&#39;, &#39;name&#39;: &#39;董阳&#39;, &#39;sex&#39;: &#39;F&#39;, &#39;address&#39;: &#39;澳门特别行政区沈阳市东城东莞街n座 902934&#39;, &#39;mail&#39;: &#39;guiying78@hotmail.com&#39;, &#39;birthdate&#39;: datetime.date(1928, 10, 19)}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;5&#34;&gt;5. 实战使用&lt;/h3&gt;
&lt;p&gt;在数据库建一张表，通过Faker造数据，插入到表中。并且打印Faker造的数据。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-Python&#34;&gt;# coding=utf-8

from faker import Faker
import sqlite3

# 连接到SQLite数据库（如果不存在则创建）
conn = sqlite3.connect(&#39;faker.db&#39;)
cursor = conn.cursor()

# 表存在先删除
delete_exists_table = &amp;quot;&amp;quot;&amp;quot;drop table if exists faker_user&amp;quot;&amp;quot;&amp;quot;
cursor.execute(delete_exists_table)

# 创建表格
create_table_query = &#39;&#39;&#39;CREATE TABLE IF NOT EXISTS faker_user (id INTEGER PRIMARY KEY AUTOINCREMENT, username TEXT, password TEXT, address TEXT)&#39;&#39;&#39;
cursor.execute(create_table_query)

fake = Faker(locale=&#39;zh_CN&#39;)

# 插入数据
for i in range(20):
    sql = &amp;quot;&amp;quot;&amp;quot;insert into faker_user(username,password,address) 
    values(&#39;%s&#39;,&#39;%s&#39;,&#39;%s&#39;)&amp;quot;&amp;quot;&amp;quot; % (fake.name(), fake.password(special_chars=False), fake.address())
    cursor.execute(sql)

# 提交更改
conn.commit()

# 查询数据
select_data_query = &#39;SELECT * FROM faker_user&#39;
cursor.execute(select_data_query)
result = cursor.fetchall()
for row in result:
    print(&amp;quot;姓名:{}|密码:{}|地址:{}&amp;quot;.format(row[1], row[2], row[3]))

# 关闭连接
cursor.close()
conn.close()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出的结果如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-Shell&#34;&gt;姓名:马梅|密码:2hGP8eC186|地址:辽宁省拉萨县永川哈尔滨街I座 857047
姓名:谭荣|密码:msBdcfeiZ3|地址:广东省成县海陵北镇路q座 413065
姓名:陈俊|密码:nyULGcNf8g|地址:湖北省玲县璧山凌街z座 953074
姓名:单峰|密码:w4WOAZzyx2|地址:青海省合山市兴山福州街h座 756882
姓名:许亮|密码:2ABJj4d0AH|地址:福建省淑华县东丽侯街r座 882820
姓名:杨娟|密码:xVwtOOCl2l|地址:湖北省海门县南溪苏路K座 405426
姓名:李文|密码:5p8RTukwUw|地址:重庆市北京市安次杭州路A座 109157
姓名:颜杰|密码:8SjPmLZtaB|地址:山东省福州县兴山赵街g座 375532
姓名:宋玉英|密码:pNIPLaNeN7|地址:贵州省辛集市滨城邝路o座 250860
姓名:吴慧|密码:9kXieqeeXX|地址:四川省建县萧山太原街Q座 687935
姓名:杨岩|密码:eViwelXs9m|地址:宁夏回族自治区红梅县新城黄路M座 248851
姓名:胡东|密码:HTVi6KVxD6|地址:安徽省秀芳市高港南昌路z座 391643
姓名:古玉|密码:ndlGJS8uS8|地址:宁夏回族自治区北京市花溪陈路h座 217657
姓名:李丽|密码:K6GYm0PQi5|地址:宁夏回族自治区嘉禾市清城陈路n座 754327
姓名:孙桂珍|密码:NScteUAeX1|地址:河南省莉县东丽南宁路R座 968642
姓名:何秀英|密码:7h6VzJ8u25|地址:香港特别行政区金凤市永川嘉禾路m座 814796
姓名:黄玲|密码:7CPxLtH8WK|地址:上海市昆明市涪城王路J座 734183
姓名:高林|密码:NRm011Zb4H|地址:海南省玉英县东城袁路i座 168381
姓名:陆兰英|密码:7e6Q3nltOt|地址:山西省天津市高坪李路A座 605319
姓名:杨杨|密码:84LWBXxhK1|地址:辽宁省宜都县徐汇邯郸路k座 372826
&lt;/code&gt;&lt;/pre&gt;</description>  
      <pubDate>2025-10-09 17:54:40</pubDate>  
      <link>https://testpoo.github.io/Python造假数据神器Faker.html</link>  
      <guid isPermaLink="true">https://testpoo.github.io/Python造假数据神器Faker.html</guid>
       
      <category>测试</category> 
      
    </item>
    
    <item> 
      <title>FastApi简析</title>  
      <description>&lt;div class=&#34;toc&#34;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1&#34;&gt;1. 简介&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-fastapi&#34;&gt;2. FastAPI 特性&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#21&#34;&gt;2.1 基于开放标准&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#22&#34;&gt;2.2 自动生成文档&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#23-python&#34;&gt;2.3 更主流的 Python&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#24&#34;&gt;2.4 编辑器支持&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#25&#34;&gt;2.5 简洁&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#26&#34;&gt;2.6 验证&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#27&#34;&gt;2.7 安全性及身份验证&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#28&#34;&gt;2.8 依赖注入&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#29&#34;&gt;2.9 无限制&#34;插件&#34;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#210&#34;&gt;2.10 测试&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3-starlette&#34;&gt;3. Starlette 特性&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4-pydantic&#34;&gt;4. Pydantic 特性&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5-python&#34;&gt;5. Python 类型提示简介&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#51&#34;&gt;5.1 动机&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#511&#34;&gt;5.1.1 修改示例&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#512&#34;&gt;5.1.2 添加类型&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#52&#34;&gt;5.2 更多动机&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#53&#34;&gt;5.3 声明类型&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#531&#34;&gt;5.3.1 简单类型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#532&#34;&gt;5.3.2 嵌套类型&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#5321&#34;&gt;5.3.2.1 列表&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5322&#34;&gt;5.3.2.2 元组和集合&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5323&#34;&gt;5.3.2.3 字典&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#533&#34;&gt;5.3.3 类作为类型&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#54-pydantic&#34;&gt;5.4 Pydantic 模型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#55-fastapi&#34;&gt;5.5 FastAPI 中的类型提示&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h1 id=&#34;1&#34;&gt;1. 简介&lt;/h1&gt;
&lt;p&gt;FastAPI 是一个用于构建 API 的现代、快速（高性能）的 web 框架，使用 Python 3.6+ 并基于标准的 Python 类型提示。&lt;/p&gt;
&lt;p&gt;关键特性:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;快速&lt;/strong&gt;：可与 &lt;strong&gt;NodeJS&lt;/strong&gt; 和 &lt;strong&gt;Go&lt;/strong&gt; 并肩的极高性能（归功于 Starlette 和 Pydantic）。最快的 Python web 框架之一。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;高效编码&lt;/strong&gt;：提高功能开发速度约 200％ 至 300％。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;更少 bug&lt;/strong&gt;：减少约 40％ 的人为（开发者）导致的错误。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;智能&lt;/strong&gt;：极佳的编辑器支持。处处皆可自动补全，减少调试时间。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;简单&lt;/strong&gt;：设计易于使用和学习，阅读文档的时间更短。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;简短&lt;/strong&gt;：使代码重复最小化。通过不同的参数声明实现丰富功能，bug 更少。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;健壮&lt;/strong&gt;：生产可用级别的代码。还有自动生成的交互式文档。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;标准化&lt;/strong&gt;：基于（并完全兼容）API 的相关开放标准：&lt;a href=&#34;https://github.com/OAI/OpenAPI-Specification&#34;&gt;OpenAPI&lt;/a&gt; (以前被称为 Swagger) 和 &lt;a href=&#34;https://json-schema.org/&#34;&gt;JSON Schema&lt;/a&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;2-fastapi&#34;&gt;2. FastAPI 特性&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;FastAPI&lt;/strong&gt; 提供了以下内容：&lt;/p&gt;
&lt;h2 id=&#34;21&#34;&gt;2.1 基于开放标准&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;用于创建 API 的 &lt;a href=&#34;https://github.com/OAI/OpenAPI-Specification&#34;&gt;&lt;strong&gt;OpenAPI&lt;/strong&gt;&lt;/a&gt; 包含了路径操作，请求参数，请求体，安全性等的声明。&lt;/li&gt;
&lt;li&gt;使用 &lt;a href=&#34;https://json-schema.org/&#34;&gt;&lt;strong&gt;JSON Schema&lt;/strong&gt;&lt;/a&gt; (因为 OpenAPI 本身就是基于 JSON Schema 的)自动生成数据模型文档。&lt;/li&gt;
&lt;li&gt;经过了缜密的研究后围绕这些标准而设计，并非狗尾续貂。&lt;/li&gt;
&lt;li&gt;这也允许了在很多语言中自动&lt;strong&gt;生成客户端代码&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;22&#34;&gt;2.2 自动生成文档&lt;/h2&gt;
&lt;p&gt;交互式 API 文档以及具探索性 web 界面。因为该框架是基于 OpenAPI，所以有很多可选项，FastAPI 默认自带两个交互式 API 文档。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/swagger-api/swagger-ui&#34;&gt;&lt;strong&gt;Swagger UI&lt;/strong&gt;&lt;/a&gt;，可交互式操作，能在浏览器中直接调用和测试你的 API 。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt=&#34;Swagger UI interaction&#34; src=&#34;https://fastapi.tiangolo.com/img/index/index-03-swagger-02.png&#34; /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;另外的 API 文档：&lt;a href=&#34;https://github.com/Rebilly/ReDoc&#34;&gt;&lt;strong&gt;ReDoc&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt=&#34;ReDoc&#34; src=&#34;https://fastapi.tiangolo.com/img/index/index-06-redoc-02.png&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;23-python&#34;&gt;2.3 更主流的 Python&lt;/h2&gt;
&lt;p&gt;全部都基于标准的 &lt;strong&gt;Python 3.6 类型&lt;/strong&gt;声明（感谢 Pydantic ）。没有新的语法需要学习。只需要标准的 Python 。&lt;/p&gt;
&lt;p&gt;如果你需要2分钟来学习如何使用 Python 类型（即使你不使用 FastAPI ），看看这个简短的教程：&lt;a href=&#34;https://fastapi.tiangolo.com/zh/python-types/&#34;&gt;Python Types&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;编写带有类型标注的标准 Python：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-python&#34;&gt;from datetime import date
from pydantic import BaseModel 
# Declare a variable as a str 
# and get editor support inside the function 
def main(user_id: str): 
    return user_id 
    # A Pydantic model 
class User(BaseModel): 
    id: int 
    name: str 
    joined: date
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以像这样来使用：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-python&#34;&gt;my_user: User = User(id=3, name=&amp;quot;John Doe&amp;quot;, joined=&amp;quot;2018-07-19&amp;quot;) 
second_user_data = {
    &amp;quot;id&amp;quot;: 4,
    &amp;quot;name&amp;quot;: &amp;quot;Mary&amp;quot;,
    &amp;quot;joined&amp;quot;: &amp;quot;2018-11-30&amp;quot;,
}
my_second_user: User = User(**second_user_data)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;second_user_data&lt;/code&gt; 意思是:&lt;/p&gt;
&lt;p&gt;直接将&lt;code&gt;second_user_data&lt;/code&gt;字典的键和值直接作为key-value参数传递，等同于：&lt;code&gt;User(id=4, name=&#34;Mary&#34;, joined=&#34;2018-11-30&#34;)&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;24&#34;&gt;2.4 编辑器支持&lt;/h2&gt;
&lt;p&gt;整个框架都被设计得易于使用且直观，所有的决定都在开发之前就在多个编辑器上进行了测试，来确保最佳的开发体验。&lt;/p&gt;
&lt;p&gt;在最近的 Python 开发者调查中，我们能看到 &lt;a href=&#34;https://www.jetbrains.com/research/python-developers-survey-2017/#tools-and-features&#34;&gt;被使用最多的功能是&#34;自动补全&#34;&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;整个 &lt;strong&gt;FastAPI&lt;/strong&gt; 框架就是基于这一点的。任何地方都可以进行自动补全。&lt;/p&gt;
&lt;p&gt;你几乎不需要经常回来看文档。&lt;/p&gt;
&lt;p&gt;在这里，你的编辑器可能会这样帮助你：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://code.visualstudio.com/&#34;&gt;Visual Studio Code&lt;/a&gt; 中:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt=&#34;editor support&#34; src=&#34;https://fastapi.tiangolo.com/img/vscode-completion.png&#34; /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.jetbrains.com/pycharm/&#34;&gt;PyCharm&lt;/a&gt; 中:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt=&#34;editor support&#34; src=&#34;https://fastapi.tiangolo.com/img/pycharm-completion.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;你将能进行代码补全，这是在之前你可能曾认为不可能的事。例如，在来自请求 JSON 体（可能是嵌套的）中的键 &lt;code&gt;price&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;不会再输错键名，来回翻看文档，或者来回滚动寻找你最后使用的 &lt;code&gt;username&lt;/code&gt; 或者 &lt;code&gt;user_name&lt;/code&gt; 。&lt;/p&gt;
&lt;h2 id=&#34;25&#34;&gt;2.5 简洁&lt;/h2&gt;
&lt;p&gt;任何类型都有合理的&lt;strong&gt;默认值&lt;/strong&gt;，任何和地方都有可选配置。所有的参数被微调，来满足你的需求，定义成你需要的 API。&lt;/p&gt;
&lt;p&gt;但是默认情况下，一切都能&lt;strong&gt;顺利工作&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;26&#34;&gt;2.6 验证&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;校验大部分（甚至所有）的 Python &lt;strong&gt;数据类型&lt;/strong&gt;，包括：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;JSON 对象 (&lt;code&gt;dict&lt;/code&gt;).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;JSON 数组 (&lt;code&gt;list&lt;/code&gt;) 定义成员类型。&lt;/li&gt;
&lt;li&gt;字符串 (&lt;code&gt;str&lt;/code&gt;) 字段, 定义最小或最大长度。&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数字 (&lt;code&gt;int&lt;/code&gt;, &lt;code&gt;float&lt;/code&gt;) 有最大值和最小值， 等等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;校验外来类型， 比如:&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;URL.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;Email.&lt;/li&gt;
&lt;li&gt;UUID.&lt;/li&gt;
&lt;li&gt;...及其他.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所有的校验都由完善且强大的 &lt;strong&gt;Pydantic&lt;/strong&gt; 处理。&lt;/p&gt;
&lt;h2 id=&#34;27&#34;&gt;2.7 安全性及身份验证&lt;/h2&gt;
&lt;p&gt;集成了安全性和身份认证。杜绝数据库或者数据模型的渗透风险。&lt;/p&gt;
&lt;p&gt;OpenAPI 中定义的安全模式，包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HTTP 基本认证。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;OAuth2&lt;/strong&gt; (也使用 &lt;strong&gt;JWT tokens&lt;/strong&gt;)。在 &lt;a href=&#34;https://fastapi.tiangolo.com/zh/tutorial/security/oauth2-jwt/&#34;&gt;OAuth2 with JWT&lt;/a&gt;查看教程。&lt;/li&gt;
&lt;li&gt;API 密钥，在:&lt;/li&gt;
&lt;li&gt;请求头。&lt;/li&gt;
&lt;li&gt;查询参数。&lt;/li&gt;
&lt;li&gt;Cookies, 等等。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;加上来自 Starlette（包括 &lt;strong&gt;session cookie&lt;/strong&gt;）的所有安全特性。&lt;/p&gt;
&lt;p&gt;所有的这些都是可复用的工具和组件，可以轻松与你的系统，数据仓库，关系型以及 NoSQL 数据库等等集成。&lt;/p&gt;
&lt;h2 id=&#34;28&#34;&gt;2.8 依赖注入&lt;/h2&gt;
&lt;p&gt;FastAPI 有一个使用非常简单，但是非常强大的&lt;strong&gt;依赖注入&lt;/strong&gt;系统。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;甚至依赖也可以有依赖，创建一个层级或者&lt;strong&gt;“图”依赖&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;所有&lt;strong&gt;自动化处理&lt;/strong&gt;都由框架完成。&lt;/li&gt;
&lt;li&gt;所有的依赖关系都可以从请求中获取数据，并且&lt;strong&gt;增加了路径操作&lt;/strong&gt;约束和自动文档生成。&lt;/li&gt;
&lt;li&gt;即使在依赖项中被定义的&lt;em&gt;路径操作&lt;/em&gt; 也会&lt;strong&gt;自动验证&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;支持复杂的用户身份认证系统，&lt;strong&gt;数据库连接&lt;/strong&gt;等等。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不依赖&lt;/strong&gt;数据库，前端等。 但是和它们集成很简单。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;29&#34;&gt;2.9 无限制&#34;插件&#34;&lt;/h2&gt;
&lt;p&gt;或者说，导入并使用你需要的代码，而不需要它们。&lt;/p&gt;
&lt;p&gt;任何集成都被设计得被易于使用（用依赖关系），你可以用和&lt;em&gt;路径操作&lt;/em&gt;相同的结构和语法，在两行代码中为你的应用创建一个“插件”。&lt;/p&gt;
&lt;h2 id=&#34;210&#34;&gt;2.10 测试&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;100% 测试覆盖。&lt;/li&gt;
&lt;li&gt;代码库100% 类型注释。&lt;/li&gt;
&lt;li&gt;用于生产应用。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;3-starlette&#34;&gt;3. Starlette 特性&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;FastAPI&lt;/strong&gt; 和 &lt;a href=&#34;https://www.starlette.io/&#34;&gt;&lt;strong&gt;Starlette&lt;/strong&gt;&lt;/a&gt; 完全兼容(并基于)。所以，你有的其他的 Starlette 代码也能正常工作。&lt;code&gt;FastAPI&lt;/code&gt; 实际上是 &lt;code&gt;Starlette&lt;/code&gt;的一个子类。所以，如果你已经知道或者使用 Starlette，大部分的功能会以相同的方式工作。&lt;/p&gt;
&lt;p&gt;通过 &lt;strong&gt;FastAPI&lt;/strong&gt; 你可以获得所有 &lt;strong&gt;Starlette&lt;/strong&gt; 的特性 ( FastAPI 就像加强版的 Starlette )：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;令人惊叹的性能。它是 &lt;a href=&#34;https://github.com/encode/starlette#performance&#34;&gt;Python 可用的最快的框架之一，和 &lt;strong&gt;NodeJS&lt;/strong&gt; 及 &lt;strong&gt;Go&lt;/strong&gt; 相当&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;支持 WebSocket&lt;/strong&gt; 。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;支持 GraphQL&lt;/strong&gt; 。&lt;/li&gt;
&lt;li&gt;后台任务处理。&lt;/li&gt;
&lt;li&gt;Startup 和 shutdown 事件。&lt;/li&gt;
&lt;li&gt;测试客户端基于 HTTPX。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CORS&lt;/strong&gt;, GZip, 静态文件, 流响应。&lt;/li&gt;
&lt;li&gt;支持 &lt;strong&gt;Session 和 Cookie&lt;/strong&gt; 。&lt;/li&gt;
&lt;li&gt;100% 测试覆盖率。&lt;/li&gt;
&lt;li&gt;代码库 100% 类型注释。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;4-pydantic&#34;&gt;4. Pydantic 特性&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;FastAPI&lt;/strong&gt; 和 &lt;a href=&#34;https://pydantic-docs.helpmanual.io/&#34;&gt;&lt;strong&gt;Pydantic&lt;/strong&gt;&lt;/a&gt; 完全兼容(并基于)。所以，你有的其他的 Pydantic 代码也能正常工作。&lt;/p&gt;
&lt;p&gt;兼容包括基于 Pydantic 的外部库， 例如用与数据库的 ORMs, ODMs。&lt;/p&gt;
&lt;p&gt;这也意味着在很多情况下，你可以将从请求中获得的相同对象&lt;strong&gt;直接传到数据库&lt;/strong&gt;，因为所有的验证都是自动的。&lt;/p&gt;
&lt;p&gt;反之亦然，在很多情况下，你也可以将从数据库中获取的对象&lt;strong&gt;直接传到客户端&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;通过 &lt;strong&gt;FastAPI&lt;/strong&gt; 你可以获得所有 &lt;strong&gt;Pydantic&lt;/strong&gt; (FastAPI 基于 Pydantic 做了所有的数据处理)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;更简单&lt;/strong&gt;：&lt;/li&gt;
&lt;li&gt;没有新的模式定义 micro-language 需要学习。&lt;/li&gt;
&lt;li&gt;如果你知道 Python types，你就知道如何使用 Pydantic。&lt;/li&gt;
&lt;li&gt;和你 &lt;strong&gt;IDE/linter/brain&lt;/strong&gt; 适配:&lt;/li&gt;
&lt;li&gt;因为 pydantic 数据结构仅仅是你定义的类的实例；自动补全，linting，mypy 以及你的直觉应该可以和你验证的数据一起正常工作。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;更快&lt;/strong&gt;：&lt;/li&gt;
&lt;li&gt;在 &lt;a href=&#34;https://pydantic-docs.helpmanual.io/benchmarks/&#34;&gt;基准测试&lt;/a&gt; 中，Pydantic 比其他被测试的库都要快。&lt;/li&gt;
&lt;li&gt;验证&lt;strong&gt;复杂结构&lt;/strong&gt;:&lt;/li&gt;
&lt;li&gt;使用分层的 Pydantic 模型, Python &lt;code&gt;typing&lt;/code&gt;的 &lt;code&gt;List&lt;/code&gt; 和 &lt;code&gt;Dict&lt;/code&gt; 等等。&lt;/li&gt;
&lt;li&gt;验证器使我们能够简单清楚的将复杂的数据模式定义、检查并记录为 JSON Schema。&lt;/li&gt;
&lt;li&gt;你可以拥有深度&lt;strong&gt;嵌套的 JSON&lt;/strong&gt; 对象并对它们进行验证和注释。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可扩展&lt;/strong&gt;:&lt;/li&gt;
&lt;li&gt;Pydantic 允许定义自定义数据类型或者你可以用验证器装饰器对被装饰的模型上的方法扩展验证。&lt;/li&gt;
&lt;li&gt;100% 测试覆盖率。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;5-python&#34;&gt;5. Python 类型提示简介&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;Python 3.6+ 版本&lt;/strong&gt;加入了对&#34;类型提示&#34;的支持。&lt;/p&gt;
&lt;p&gt;这些&lt;strong&gt;类型提示&lt;/strong&gt;是一种新的语法（在 Python 3.6 版本加入）用来声明一个变量的类型。&lt;/p&gt;
&lt;p&gt;通过声明变量的类型，编辑器和一些工具能给你提供更好的支持。&lt;/p&gt;
&lt;p&gt;这只是一个关于 Python 类型提示的&lt;strong&gt;快速入门 / 复习&lt;/strong&gt;。它仅涵盖与 &lt;strong&gt;FastAPI&lt;/strong&gt; 一起使用所需的最少部分，实际上只有很少一点。&lt;/p&gt;
&lt;p&gt;整个 &lt;strong&gt;FastAPI&lt;/strong&gt; 都基于这些类型提示构建，它们带来了许多优点和好处。&lt;/p&gt;
&lt;p&gt;但即使你不会用到 &lt;strong&gt;FastAPI&lt;/strong&gt;，了解一下类型提示也会让你从中受益。&lt;/p&gt;
&lt;p&gt;如果你已经精通 Python，并且了解关于类型提示的一切知识，直接跳到下一章节吧。&lt;/p&gt;
&lt;h2 id=&#34;51&#34;&gt;5.1 动机&lt;/h2&gt;
&lt;p&gt;让我们从一个简单的例子开始：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-python&#34;&gt;def get_full_name(first_name, last_name):
    full_name = first_name.title() + &amp;quot; &amp;quot; + last_name.title()
    return full_name print(get_full_name(&amp;quot;john&amp;quot;, &amp;quot;doe&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行这段程序将输出：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;John Doe&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这个函数做了下面这些事情：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;接收 &lt;code&gt;first_name&lt;/code&gt; 和 &lt;code&gt;last_name&lt;/code&gt; 参数。&lt;/li&gt;
&lt;li&gt;通过 &lt;code&gt;title()&lt;/code&gt; 将每个参数的第一个字母转换为大写形式。&lt;/li&gt;
&lt;li&gt;中间用一个空格来拼接它们。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;511&#34;&gt;5.1.1 修改示例&lt;/h3&gt;
&lt;p&gt;这是一个非常简单的程序。&lt;/p&gt;
&lt;p&gt;现在假设你将从头开始编写这段程序。&lt;/p&gt;
&lt;p&gt;在某一时刻，你开始定义函数，并且准备好了参数。&lt;/p&gt;
&lt;p&gt;现在你需要调用一个&#34;将第一个字母转换为大写形式的方法&#34;。&lt;/p&gt;
&lt;p&gt;等等，那个方法是什么来着？&lt;code&gt;upper&lt;/code&gt;？还是 &lt;code&gt;uppercase&lt;/code&gt;？&lt;code&gt;first_uppercase&lt;/code&gt;？&lt;code&gt;capitalize&lt;/code&gt;？&lt;/p&gt;
&lt;p&gt;然后你尝试向程序员老手的朋友——编辑器自动补全寻求帮助。&lt;/p&gt;
&lt;p&gt;输入函数的第一个参数 &lt;code&gt;first_name&lt;/code&gt;，输入点号（&lt;code&gt;.&lt;/code&gt;）然后敲下 &lt;code&gt;Ctrl+Space&lt;/code&gt; 来触发代码补全。&lt;/p&gt;
&lt;p&gt;但遗憾的是并没有起什么作用：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;https://fastapi.tiangolo.com/img/python-types/image01.png&#34; /&gt;&lt;/p&gt;
&lt;h3 id=&#34;512&#34;&gt;5.1.2 添加类型&lt;/h3&gt;
&lt;p&gt;让我们来修改上面例子的一行代码。&lt;/p&gt;
&lt;p&gt;我们将把下面这段代码中的函数参数从：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;first_name, last_name
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;改成：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;first_name: str, last_name: str
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;就是这样。&lt;/p&gt;
&lt;p&gt;这些就是&#34;类型提示&#34;：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-python&#34;&gt;def get_full_name(first_name: str, last_name: str):
    full_name = first_name.title() + &amp;quot; &amp;quot; + last_name.title()
    return full_name
    print(get_full_name(&amp;quot;john&amp;quot;, &amp;quot;doe&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这和声明默认值是不同的，例如：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;first_name=&amp;quot;john&amp;quot;, last_name=&amp;quot;doe&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这两者不一样。&lt;/p&gt;
&lt;p&gt;我们用的是冒号（&lt;code&gt;:&lt;/code&gt;），不是等号（&lt;code&gt;=&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;而且添加类型提示一般不会改变原来的运行结果。&lt;/p&gt;
&lt;p&gt;现在假设我们又一次正在创建这个函数，这次添加了类型提示。&lt;/p&gt;
&lt;p&gt;在同样的地方，通过 &lt;code&gt;Ctrl+Space&lt;/code&gt; 触发自动补全，你会发现：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;https://fastapi.tiangolo.com/img/python-types/image02.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;这样，你可以滚动查看选项，直到你找到看起来眼熟的那个：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;https://fastapi.tiangolo.com/img/python-types/image03.png&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;52&#34;&gt;5.2 更多动机&lt;/h2&gt;
&lt;p&gt;下面是一个已经有类型提示的函数：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-python&#34;&gt;def get_name_with_age(name: str, age: int):
    name_with_age = name + &amp;quot; is this old: &amp;quot; + age
    return name_with_age
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因为编辑器已经知道了这些变量的类型，所以不仅能对代码进行补全，还能检查其中的错误：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;https://fastapi.tiangolo.com/img/python-types/image04.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;现在你知道了必须先修复这个问题，通过 &lt;code&gt;str(age)&lt;/code&gt; 把 &lt;code&gt;age&lt;/code&gt; 转换成字符串：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-python&#34;&gt;def get_name_with_age(name: str, age: int):
    name_with_age = name + &amp;quot; is this old: &amp;quot; + str(age)
    return name_with_age
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;53&#34;&gt;5.3 声明类型&lt;/h2&gt;
&lt;p&gt;你刚刚看到的就是声明类型提示的主要场景。用于函数的参数。&lt;/p&gt;
&lt;p&gt;这也是你将在 &lt;strong&gt;FastAPI&lt;/strong&gt; 中使用它们的主要场景。&lt;/p&gt;
&lt;h3 id=&#34;531&#34;&gt;5.3.1 简单类型&lt;/h3&gt;
&lt;p&gt;不只是 &lt;code&gt;str&lt;/code&gt;，你能够声明所有的标准 Python 类型。&lt;/p&gt;
&lt;p&gt;比如以下类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;int&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;float&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-python&#34;&gt;def get_items(item_a: str, item_b: int, item_c: float, item_d: bool, item_e: bytes):
    return item_a, item_b, item_c, item_d, item_d, item_e
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;532&#34;&gt;5.3.2 嵌套类型&lt;/h3&gt;
&lt;p&gt;有些容器数据结构可以包含其他的值，比如 &lt;code&gt;dict&lt;/code&gt;、&lt;code&gt;list&lt;/code&gt;、&lt;code&gt;set&lt;/code&gt; 和 &lt;code&gt;tuple&lt;/code&gt;。它们内部的值也会拥有自己的类型。&lt;/p&gt;
&lt;p&gt;你可以使用 Python 的 &lt;code&gt;typing&lt;/code&gt; 标准库来声明这些类型以及子类型。&lt;/p&gt;
&lt;p&gt;它专门用来支持这些类型提示。&lt;/p&gt;
&lt;h4 id=&#34;5321&#34;&gt;5.3.2.1 列表&lt;/h4&gt;
&lt;p&gt;例如，让我们来定义一个由 &lt;code&gt;str&lt;/code&gt; 组成的 &lt;code&gt;list&lt;/code&gt; 变量。&lt;/p&gt;
&lt;p&gt;从 &lt;code&gt;typing&lt;/code&gt; 模块导入 &lt;code&gt;List&lt;/code&gt;（注意是大写的 &lt;code&gt;L&lt;/code&gt;）：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-python&#34;&gt;from typing import List

def process_items(items: List[str]):
    for item in items:
        print(item)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同样以冒号（&lt;code&gt;:&lt;/code&gt;）来声明这个变量。&lt;/p&gt;
&lt;p&gt;输入 &lt;code&gt;List&lt;/code&gt; 作为类型。&lt;/p&gt;
&lt;p&gt;由于列表是带有&#34;子类型&#34;的类型，所以我们把子类型放在方括号中：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-python&#34;&gt;from typing import List

def process_items(items: List[str]):
    for item in items:
        print(item)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这表示：&#34;变量 &lt;code&gt;items&lt;/code&gt; 是一个 &lt;code&gt;list&lt;/code&gt;，并且这个列表里的每一个元素都是 &lt;code&gt;str&lt;/code&gt;&#34;。&lt;/p&gt;
&lt;p&gt;这样，即使在处理列表中的元素时，你的编辑器也可以提供支持。&lt;/p&gt;
&lt;p&gt;没有类型，几乎是不可能实现下面这样：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;https://fastapi.tiangolo.com/img/python-types/image05.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;注意，变量 &lt;code&gt;item&lt;/code&gt; 是列表 &lt;code&gt;items&lt;/code&gt; 中的元素之一。&lt;/p&gt;
&lt;p&gt;而且，编辑器仍然知道它是一个 &lt;code&gt;str&lt;/code&gt;，并为此提供了支持。&lt;/p&gt;
&lt;h4 id=&#34;5322&#34;&gt;5.3.2.2 元组和集合&lt;/h4&gt;
&lt;p&gt;声明 &lt;code&gt;tuple&lt;/code&gt; 和 &lt;code&gt;set&lt;/code&gt; 的方法也是一样的：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-python&#34;&gt;from typing import Set, Tuple

def process_items(items_t: Tuple[int, int, str], items_s: Set[bytes]):
    return items_t, items_s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这表示：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;变量 &lt;code&gt;items_t&lt;/code&gt; 是一个 &lt;code&gt;tuple&lt;/code&gt;，其中的前两个元素都是 &lt;code&gt;int&lt;/code&gt; 类型, 最后一个元素是 &lt;code&gt;str&lt;/code&gt; 类型。&lt;/li&gt;
&lt;li&gt;变量 &lt;code&gt;items_s&lt;/code&gt; 是一个 &lt;code&gt;set&lt;/code&gt;，其中的每个元素都是 &lt;code&gt;bytes&lt;/code&gt; 类型。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;5323&#34;&gt;5.3.2.3 字典&lt;/h4&gt;
&lt;p&gt;定义 &lt;code&gt;dict&lt;/code&gt; 时，需要传入两个子类型，用逗号进行分隔。&lt;/p&gt;
&lt;p&gt;第一个子类型声明 &lt;code&gt;dict&lt;/code&gt; 的所有键。&lt;/p&gt;
&lt;p&gt;第二个子类型声明 &lt;code&gt;dict&lt;/code&gt; 的所有值：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-python&#34;&gt;from typing import Dict

def process_items(prices: Dict[str, float]):
    for item_name, item_price in prices.items():
        print(item_name)
        print(item_price)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这表示：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;变量 &lt;code&gt;prices&lt;/code&gt; 是一个 &lt;code&gt;dict&lt;/code&gt;：&lt;/li&gt;
&lt;li&gt;这个 &lt;code&gt;dict&lt;/code&gt; 的所有键为 &lt;code&gt;str&lt;/code&gt; 类型（可以看作是字典内每个元素的名称）。&lt;/li&gt;
&lt;li&gt;这个 &lt;code&gt;dict&lt;/code&gt; 的所有值为 &lt;code&gt;float&lt;/code&gt; 类型（可以看作是字典内每个元素的价格）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;533&#34;&gt;5.3.3 类作为类型&lt;/h3&gt;
&lt;p&gt;你也可以将类声明为变量的类型。&lt;/p&gt;
&lt;p&gt;假设你有一个名为 &lt;code&gt;Person&lt;/code&gt; 的类，拥有 name 属性：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-python&#34;&gt;class Person:
    def __init__(self, name: str):
        self.name = name

    def get_person_name(one_person: Person):
        return one_person.name
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来，你可以将一个变量声明为 &lt;code&gt;Person&lt;/code&gt; 类型：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-python&#34;&gt;class Person:
    def __init__(self, name: str):
        self.name = name

    def get_person_name(one_person: Person):
        return one_person.name
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后，你将再次获得所有的编辑器支持：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;https://fastapi.tiangolo.com/img/python-types/image06.png&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;54-pydantic&#34;&gt;5.4 Pydantic 模型&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://pydantic-docs.helpmanual.io/&#34;&gt;Pydantic&lt;/a&gt; 是一个用来用来执行数据校验的 Python 库。&lt;/p&gt;
&lt;p&gt;你可以将数据的&#34;结构&#34;声明为具有属性的类。&lt;/p&gt;
&lt;p&gt;每个属性都拥有类型。&lt;/p&gt;
&lt;p&gt;接着你用一些值来创建这个类的实例，这些值会被校验，并被转换为适当的类型（在需要的情况下），返回一个包含所有数据的对象。&lt;/p&gt;
&lt;p&gt;然后，你将获得这个对象的所有编辑器支持。&lt;/p&gt;
&lt;p&gt;下面的例子来自 Pydantic 官方文档：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-python&#34;&gt;class Person:
    def __init__(self, name: str):
        self.name = name

    def get_person_name(one_person: Person):
        return one_person.name
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;想进一步了解 &lt;a href=&#34;https://pydantic-docs.helpmanual.io/&#34;&gt;Pydantic，请阅读其文档&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;整个 &lt;strong&gt;FastAPI&lt;/strong&gt; 建立在 Pydantic 的基础之上。&lt;/p&gt;
&lt;p&gt;实际上你将在 &lt;a href=&#34;https://fastapi.tiangolo.com/zh/tutorial/&#34;&gt;教程 - 用户指南&lt;/a&gt; 看到很多这种情况。&lt;/p&gt;
&lt;h2 id=&#34;55-fastapi&#34;&gt;5.5 FastAPI 中的类型提示&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;FastAPI&lt;/strong&gt; 利用这些类型提示来做下面几件事。&lt;/p&gt;
&lt;p&gt;使用 &lt;strong&gt;FastAPI&lt;/strong&gt; 时用类型提示声明参数可以获得：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;编辑器支持&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;类型检查&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;并且 &lt;strong&gt;FastAPI&lt;/strong&gt; 还会用这些类型声明来：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;定义参数要求&lt;/strong&gt;：声明对请求路径参数、查询参数、请求头、请求体、依赖等的要求。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;转换数据&lt;/strong&gt;：将来自请求的数据转换为需要的类型。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;校验数据&lt;/strong&gt;： 对于每一个请求：&lt;/li&gt;
&lt;li&gt;当数据校验失败时自动生成&lt;strong&gt;错误信息&lt;/strong&gt;返回给客户端。&lt;/li&gt;
&lt;li&gt;使用 OpenAPI &lt;strong&gt;记录&lt;/strong&gt; API：&lt;/li&gt;
&lt;li&gt;然后用于自动生成交互式文档的用户界面。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;听上去有点抽象。不过不用担心。你将在 &lt;a href=&#34;https://fastapi.tiangolo.com/zh/tutorial/&#34;&gt;教程 - 用户指南&lt;/a&gt; 中看到所有的实战。&lt;/p&gt;
&lt;p&gt;最重要的是，通过使用标准的 Python 类型，只需要在一个地方声明（而不是添加更多的类、装饰器等），&lt;strong&gt;FastAPI&lt;/strong&gt; 会为你完成很多的工作。&lt;/p&gt;</description>  
      <pubDate>2025-10-09 17:54:40</pubDate>  
      <link>https://testpoo.github.io/FastApi简析.html</link>  
      <guid isPermaLink="true">https://testpoo.github.io/FastApi简析.html</guid>
       
      <category>技术</category> 
      
    </item>
    
    <item> 
      <title>go测试库apitest简介</title>  
      <description>&lt;div class=&#34;toc&#34;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1&#34;&gt;1. 开始&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#11&#34;&gt;1.1. 概述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#12&#34;&gt;1.2. 特征&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#13&#34;&gt;1.3. 安装&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#14&#34;&gt;1.4. 一个测试例子的解析&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2&#34;&gt;2. 配置&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#21-debug&#34;&gt;2.1. Debug&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#22-http-handler&#34;&gt;2.2. HTTP Handler&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#23-hooks&#34;&gt;2.3. Hooks&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#24-networking&#34;&gt;2.4. Networking&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3&#34;&gt;3. 请求&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#31-basic-auth&#34;&gt;3.1. Basic Auth&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#32-body&#34;&gt;3.2. Body&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#33-cookies&#34;&gt;3.3. Cookies&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#34-form&#34;&gt;3.4. Form&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#35-graphql&#34;&gt;3.5. GraphQL&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#36-headers&#34;&gt;3.6. Headers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#37-intercept&#34;&gt;3.7. Intercept&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#38-query-params&#34;&gt;3.8. Query Params&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4&#34;&gt;4. 异常&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#41-body&#34;&gt;4.1. Body&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#42-cookies&#34;&gt;4.2. Cookies&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#43&#34;&gt;4.3. 自定义&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#44-headers&#34;&gt;4.4. Headers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#45-json-path&#34;&gt;4.5. JSON Path&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#46-status-code&#34;&gt;4.6. Status code&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5-mocks&#34;&gt;5. MOCKS&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#51-mocks&#34;&gt;5.1. 定义Mocks&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#52-matchers&#34;&gt;5.2. Matchers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#53-standalone&#34;&gt;5.3. Standalone&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#6-integrations&#34;&gt;6. INTEGRATIONS&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#61-ginkgo&#34;&gt;6.1. Ginkgo&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#7-reports&#34;&gt;7. REPORTS&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#71-sequence-diagrams&#34;&gt;7.1. Sequence diagrams&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#8&#34;&gt;8. 例子&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h3 id=&#34;1&#34;&gt;1. 开始&lt;/h3&gt;
&lt;h4 id=&#34;11&#34;&gt;1.1. 概述&lt;/h4&gt;
&lt;p&gt;apitest是一个简单且可扩展的 Go 语言测试库。你可以使用 &lt;code&gt;apitest&lt;/code&gt; 来简化 REST 服务、HTTP handlers(事件处理器) 和HTTP客户端的测试。&lt;/p&gt;
&lt;h4 id=&#34;12&#34;&gt;1.2. 特征&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;可模拟外部http调用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在测试完成时可呈现序列图&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可扩展——支持各种注入点&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;GraphQL（一种用于 API 的查询语言）支持&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;自定义断言函数和模拟匹配器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;JSON路径断言，css选择器断言等等&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;13&#34;&gt;1.3. 安装&lt;/h4&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-shell&#34;&gt;go get -u github.com/steinfletcher/apitest
# 使用时导入
import &amp;quot;github.com/steinfletcher/apitest&amp;quot;
# 就咱们现在这种网络状态，第一种方法基本不能用，目前只能手动下载，然后手动放到GOPATH/src/github.com/下。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;apitest遵循语义版本控制，使用 Github 版本管理发布。&lt;/p&gt;
&lt;h4 id=&#34;14&#34;&gt;1.4. 一个测试例子的解析&lt;/h4&gt;
&lt;p&gt;例子主要包括三个部分&lt;/p&gt;
&lt;p&gt;配置：定义将要测试的HTTP请求处理程序和所有其他特定的测试配置，例如模拟、调试模式和报告&lt;/p&gt;
&lt;p&gt;请求：定义测试输入，这通常是一个http请求需要的&lt;/p&gt;
&lt;p&gt;预期：定义被测应用程序应该如何响应。这通常是一个http响应需要的&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
    &amp;quot;net/http&amp;quot;
    &amp;quot;testing&amp;quot;

    &amp;quot;github.com/steinfletcher/apitest&amp;quot;
)

func TestGetMessage(t *testing.T) {
    handler := func(w http.ResponseWriter, r *http.Request) {
        msg := `{&amp;quot;message&amp;quot;: &amp;quot;hello&amp;quot;}`
        _, _ = w.Write([]byte(msg))
        w.WriteHeader(http.StatusOK)
    }

    apitest.New(). // 配置
            HandlerFunc(handler).  // 不通过网络进行 HTTP 调用
            Get(&amp;quot;/message&amp;quot;). // 请求，必须写
            Expect(t).       // Expect(t).Body 匹配 HTTP 响应体
            Body(`{&amp;quot;message&amp;quot;: &amp;quot;hello&amp;quot;}`).
            Status(http.StatusOK).  // 断言http状态 http.StatusOK = 200
            End()  // 测试结束
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用 &lt;code&gt;go test&lt;/code&gt; 执行测试，&lt;code&gt;go test -v&lt;/code&gt; 打印测试函数的所有细节，如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-shell&#34;&gt;$ go test 1_hello_test.go
ok      command-line-arguments  0.217s

=============================================

$ go test -v 1_hello_test.go
=== RUN   TestGetMessage

----------&amp;gt; inbound http request
GET /message HTTP/1.1
Host: sut



&amp;lt;---------- final response
HTTP/1.1 200 OK
Connection: close
Content-Type: text/plain; charset=utf-8

{&amp;quot;message&amp;quot;: &amp;quot;hello&amp;quot;}
Duration: 0s

--- PASS: TestGetMessage (0.00s)
PASS
ok      command-line-arguments  0.220s5s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;源文件和测试文件放在同一目录下，测试文件以 &lt;code&gt;_test&lt;/code&gt; 结尾，这个是固定格式，使用 &lt;code&gt;go build&lt;/code&gt; 进行编译时，&lt;code&gt;_test&lt;/code&gt; 文件不会编译。每个测试函数需要以 &lt;code&gt;Test&lt;/code&gt; 为前缀，每个性能测试函数需要以 &lt;code&gt;Benchmark&lt;/code&gt; 为前缀。&lt;/p&gt;
&lt;h3 id=&#34;2&#34;&gt;2. 配置&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;APITest&lt;/code&gt; 配置类型公开了一些方法来注册测试钩子、启用调试日志记录、并定义被测处理程序。&lt;/p&gt;
&lt;h4 id=&#34;21-debug&#34;&gt;2.1. Debug&lt;/h4&gt;
&lt;p&gt;启用调试日志记录并把所有请求和响应交互的http连接情况写入控制台。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;apitest.New().
  Debug().
  Handler(myHandler)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样会记录整个模拟交互过程，这对于定位失败测试用例背后的原因非常有用。在下面的示例中，由于模拟的 URL 不正确，导致不匹配。控制台会将每个模拟不匹配的原因记录下来。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-shell&#34;&gt;----------&amp;gt; inbound http request
GET /user HTTP/1.1
Host: application

failed to match mocks. Errors: received request did not match any mocks

Mock 1 mismatches:
• received path /user/12345 did not match mock path /preferences/12345

Mock 2 mismatches:
• received path /user/12345 did not match mock path /user/123456

----------&amp;gt; request to mock
GET /user/12345 HTTP/1.1
Host: localhost:8080
User-Agent: Go-http-client/1.1
Accept-Encoding: gzip
...
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;22-http-handler&#34;&gt;2.2. HTTP Handler&lt;/h4&gt;
&lt;p&gt;应该使用 Handler 或 HandlerFunc 测试定义的 &lt;code&gt;handler&lt;/code&gt;，其中 myHandler 是 一个Go的 &lt;code&gt;http.handler&lt;/code&gt;。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;apitest.New().Handler(myHandler)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;设置 Handler 时，apitest 不会通过网络进行 HTTP 调用。相反，提供的 HTTP Handler 的 &lt;code&gt;serveHTTP&lt;/code&gt; 方法在与测试代码相同的进程中调用。用户定义的请求和响应将通过 Go 的 &lt;code&gt;httptest&lt;/code&gt; 包转换成 &lt;code&gt;http.Request&lt;/code&gt; 和 &lt;code&gt;http.Response&lt;/code&gt; 类型。这里的目标是测试内部应用程序而非网络。这种方法使测试既快速又简单。如果你想要用真正的 http 客户端发起一个请求去运行应用程序，则需要通过网络执行。&lt;/p&gt;
&lt;p&gt;Handler 例子&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;package jsonpath

import (
    &amp;quot;net/http&amp;quot;
    &amp;quot;testing&amp;quot;

    &amp;quot;github.com/steinfletcher/apitest&amp;quot;
)

func TestHandler(t *testing.T) {
    handler := http.NewServeMux()
    handler.HandleFunc(&amp;quot;/data&amp;quot;, func(w http.ResponseWriter, r *http.Request) {
        w.WriteHeader(http.StatusOK)
    })

    apitest.New().
        Handler(handler).
        Get(&amp;quot;/data&amp;quot;).
        Expect(t).
        Status(http.StatusOK).
        End()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;HandlerFunc 例子&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;package jsonpath

import (
    &amp;quot;net/http&amp;quot;
    &amp;quot;testing&amp;quot;

    &amp;quot;github.com/steinfletcher/apitest&amp;quot;
)

func TestHandlerFunc(t *testing.T) {
    handlerFunc := func(w http.ResponseWriter, r *http.Request) {
        w.WriteHeader(http.StatusOK)
    }

    apitest.New().
        HandlerFunc(handlerFunc).
        Post(&amp;quot;/login&amp;quot;).
        Expect(t).
        Status(http.StatusOK).
        End()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;23-hooks&#34;&gt;2.3. Hooks&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Intercept&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在请求调用前，&lt;code&gt;Intercept&lt;/code&gt; 和 &lt;code&gt;Observe&lt;/code&gt;类似。允许请求发起者将请求对象发送到被测系统之前对其进行更改。在此示例中，我们使用自定义方案设置请求参数。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
    &amp;quot;net/http&amp;quot;
    &amp;quot;testing&amp;quot;

    &amp;quot;github.com/steinfletcher/apitest&amp;quot;
)

func TestIntercept(t *testing.T) {
    handler := func(w http.ResponseWriter, r *http.Request) {
        if r.URL.RawQuery != &amp;quot;a[]=xxx&amp;amp;a[]=yyy&amp;quot; {
            t.Fatal(&amp;quot;unexpected query&amp;quot;)
        }
        w.WriteHeader(http.StatusOK)
    }

    apitest.New().
        HandlerFunc(handler).
        Intercept(func(req *http.Request) {
            req.URL.RawQuery = &amp;quot;a[]=xxx&amp;amp;a[]=yyy&amp;quot;
        }).
        Get(&amp;quot;/&amp;quot;).
        Expect(t).
        Status(http.StatusOK).
        End()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Observe&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Observe&lt;/code&gt; 可用于在测试完成时检查请求、响应和 APITest 实例。此方法在 apitest 内部使用，以捕获跨模拟服务器的所有交互，从而呈现测试结果。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
    &amp;quot;net/http&amp;quot;
    &amp;quot;testing&amp;quot;

    &amp;quot;github.com/steinfletcher/apitest&amp;quot;
)

func TestObserve(t *testing.T) {
    var observeCalled bool

    apitest.New().
        Observe(func(res *http.Response, req *http.Request, apiTest *apitest.APITest) {
            observeCalled = true
            if http.StatusOK != res.StatusCode {
                t.Fatal(&amp;quot;unexpected status code&amp;quot;)
            }
        }).
        HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            w.WriteHeader(http.StatusOK)
        }).
        Get(&amp;quot;/hello&amp;quot;).
        Expect(t).
        Status(http.StatusOK).
        End()

    if !observeCalled {
        t.Fatal(&amp;quot;Observe not called&amp;quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;24-networking&#34;&gt;2.4. Networking&lt;/h4&gt;
&lt;p&gt;如果要针对正在运行的应用程序发起 HTTP 请求，则需要网络。并传递带有 cookie 的 http 请求，类似浏览器的会话行为，其中 cookie 要在多个 apitest 请求中留从。此方法可用于执行端到端的测试。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
    &amp;quot;fmt&amp;quot;
    &amp;quot;net/http&amp;quot;
    &amp;quot;net/http/cookiejar&amp;quot;
    &amp;quot;testing&amp;quot;
    &amp;quot;time&amp;quot;

    &amp;quot;github.com/steinfletcher/apitest&amp;quot;
)

// TestEnableNetworking creates a server with two endpoints, /login sets a token via a cookie and /authenticated_resource
// validates the token. A cookie jar is used to verify session persistence across multiple apitest instances
func TestEnableNetworking(t *testing.T) {
    srv := &amp;amp;http.Server{Addr: &amp;quot;localhost:9876&amp;quot;}
    finish := make(chan struct{})
    tokenValue := &amp;quot;ABCDEF&amp;quot;

    http.HandleFunc(&amp;quot;/login&amp;quot;, func(w http.ResponseWriter, r *http.Request) {
        http.SetCookie(w, &amp;amp;http.Cookie{Name: &amp;quot;Token&amp;quot;, Value: tokenValue})
        w.WriteHeader(203)
    })

    http.HandleFunc(&amp;quot;/authenticated_resource&amp;quot;, func(w http.ResponseWriter, r *http.Request) {
        token, err := r.Cookie(&amp;quot;Token&amp;quot;)
        if err == http.ErrNoCookie {
            w.WriteHeader(400)
            return
        }
        if err != nil {
            w.WriteHeader(500)
            return
        }

        if token.Value != tokenValue {
            t.Fatalf(&amp;quot;token did not equal %s&amp;quot;, tokenValue)
        }
        w.WriteHeader(204)
    })

    go func() {
        if err := srv.ListenAndServe(); err != nil {
            panic(err)
        }
    }()

    go func() {
        defer func() {
            if r := recover(); r != nil {
                fmt.Println(&amp;quot;Recovered in f&amp;quot;, r)
            }
        }()

        cookieJar, _ := cookiejar.New(nil)
        cli := &amp;amp;http.Client{
            Timeout: time.Second * 1,
            Jar:     cookieJar,
        }

        apitest.New().
            EnableNetworking(cli).
            Get(&amp;quot;http://localhost:9876/login&amp;quot;).
            Expect(t).
            Status(203).
            End()

        apitest.New().
            EnableNetworking(cli).
            Get(&amp;quot;http://localhost:9876/authenticated_resource&amp;quot;).
            Expect(t).
            Status(204).
            End()

        finish &amp;lt;- struct{}{}
    }()

    &amp;lt;-finish
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;3&#34;&gt;3. 请求&lt;/h3&gt;
&lt;p&gt;要配置对被测系统的初始请求，您可以指定请求参数，例如 http 方法、url、标头和 cookie。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;apitest.New().
    Handler(handler).
    Method(http.MethodGet).
    URL(&amp;quot;/user/12345&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这非常冗长，因此为常见的 http 动作定义了一些快捷方式，这些动作对方法和 URL 进行了封闭。该示例可以更简洁地表示为：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;apitest.Handler(handler).
    Get(&amp;quot;/user/12345&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你还可以用标准的 Go http.Request 来定义请求。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;req := httptest.NewRequest(http.MethodGet, &amp;quot;/user/1234&amp;quot;, nil)
apitest.Handler(handler).
    Request(req)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;31-basic-auth&#34;&gt;3.1. Basic Auth&lt;/h4&gt;
&lt;p&gt;提供了一个向请求添加基本身份验证的方法。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;BasicAuth(&#34;username&#34;, &#34;password&#34;)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;例子&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
    &amp;quot;net/http&amp;quot;
    &amp;quot;testing&amp;quot;

    &amp;quot;github.com/steinfletcher/apitest&amp;quot;
)

func TestRequests_BasicAuth(t *testing.T) {
    handler := func(w http.ResponseWriter, r *http.Request) {
        username, password, ok := r.BasicAuth()
        if !ok {
            w.WriteHeader(http.StatusBadRequest)
            return
        }

        if username != &amp;quot;username&amp;quot; || password != &amp;quot;password&amp;quot; {
            w.WriteHeader(http.StatusBadRequest)
            return
        }

        w.WriteHeader(http.StatusOK)
    }

    apitest.New().
        HandlerFunc(handler).
        Get(&amp;quot;/hello&amp;quot;).
        BasicAuth(&amp;quot;username&amp;quot;, &amp;quot;password&amp;quot;).
        Expect(t).
        Status(http.StatusOK).
        End()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;32-body&#34;&gt;3.2. Body&lt;/h4&gt;
&lt;p&gt;有两个方法去设置请求体--&lt;code&gt;Bady&lt;/code&gt; 和 &lt;code&gt;JSON&lt;/code&gt; 。使用 &lt;code&gt;Body&lt;/code&gt; 将数据复制到原始请求中并包装在 &lt;code&gt;io.Reader&lt;/code&gt;。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;Post(&amp;quot;/message&amp;quot;).Body(&amp;quot;hello&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;JSON&lt;/code&gt; 执行相同的操作并将提供的数据复制到正文，但 &lt;code&gt;JSON&lt;/code&gt; 方法还将内容类型设置为 &lt;code&gt;application/json&lt;/code&gt;。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;Post(&amp;quot;/chat&amp;quot;).JSON(`{&amp;quot;message&amp;quot;: &amp;quot;hi&amp;quot;}`)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果要定义其他内容类型，请使用 &lt;code&gt;Body(data)&lt;/code&gt; 设置包体，使用 &lt;code&gt;header&lt;/code&gt; 设置标头。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;Post(&amp;quot;/path&amp;quot;).
Body(&amp;quot;&amp;lt;html&amp;gt;content&amp;lt;/html&amp;gt;&amp;quot;).
Header(&amp;quot;Content-Type&amp;quot;, &amp;quot;text/html&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;JSON 包体例子&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
    &amp;quot;io/ioutil&amp;quot;
    &amp;quot;net/http&amp;quot;
    &amp;quot;testing&amp;quot;

    &amp;quot;github.com/steinfletcher/apitest&amp;quot;
)

func TestRequests_JSONBody(t *testing.T) {
    handler := func(w http.ResponseWriter, r *http.Request) {
        data, _ := ioutil.ReadAll(r.Body)
        if string(data) != `{&amp;quot;a&amp;quot;: 12345}` {
            w.WriteHeader(http.StatusInternalServerError)
            return
        }
        if r.Header.Get(&amp;quot;Content-Type&amp;quot;) != &amp;quot;application/json&amp;quot; {
            w.WriteHeader(http.StatusBadRequest)
            return
        }
        w.WriteHeader(http.StatusOK)
    }

    apitest.New().
        HandlerFunc(handler).
        Post(&amp;quot;/hello&amp;quot;).
        JSON(`{&amp;quot;a&amp;quot;: 12345}`).
        Expect(t).
        Status(http.StatusOK).
        End()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;文本包体例子&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
    &amp;quot;io/ioutil&amp;quot;
    &amp;quot;net/http&amp;quot;
    &amp;quot;testing&amp;quot;

    &amp;quot;github.com/steinfletcher/apitest&amp;quot;
)

func TestRequests_TextBody(t *testing.T) {
    handler := func(w http.ResponseWriter, r *http.Request) {
        data, _ := ioutil.ReadAll(r.Body)
        if string(data) != `hello` {
            w.WriteHeader(http.StatusInternalServerError)
            return
        }
        w.WriteHeader(http.StatusOK)
    }

    apitest.New().
        HandlerFunc(handler).
        Put(&amp;quot;/hello&amp;quot;).
        Body(`hello`).
        Expect(t).
        Status(http.StatusOK).
        End()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;33-cookies&#34;&gt;3.3. Cookies&lt;/h4&gt;
&lt;p&gt;有多种方法可以指定 http 的请求 cookie。这些方法可以一起使用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;简短形式&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;Cookie(&amp;quot;name&amp;quot;, &amp;quot;value&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;结构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Cookies 是一个被用于获取已定义的不同数量的 cookie 的结构体。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;Cookies(apitest.NewCookie(&amp;quot;name&amp;quot;).
    Value(&amp;quot;value&amp;quot;).
    Path(&amp;quot;/user&amp;quot;).
    Domain(&amp;quot;example.com&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该结构的底层字段都是指针类型。这样，断言库就可以忽略结构体中未定义的字段。&lt;/p&gt;
&lt;h4 id=&#34;34-form&#34;&gt;3.4. Form&lt;/h4&gt;
&lt;p&gt;在请求中创建 URL 表单有多种方法。以下几种方法可以一起使用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;多个值的Form&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;FormData 是一个可变函数，可用于为同一键获取不同数量的值。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;FormData(&amp;quot;name&amp;quot;, &amp;quot;value1&amp;quot;, &amp;quot;value2&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;简短的Form&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;FormData(&amp;quot;name&amp;quot;, &amp;quot;value&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;35-graphql&#34;&gt;3.5. GraphQL&lt;/h4&gt;
&lt;p&gt;以下帮助程序可简化 GraphQL 请求的构建。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;Post(&amp;quot;/graphql&amp;quot;).
GraphQLQuery(`query { todos { text } }`).

Post(&amp;quot;/graphql&amp;quot;).
GraphQLRequest(apitest.GraphQLRequestBody{
    Query: &amp;quot;query someTest($arg: String!) { test(who: $arg) }&amp;quot;,
    Variables: map[string]interface{}{
        &amp;quot;arg&amp;quot;: &amp;quot;myArg&amp;quot;,
    },
    OperationName: &amp;quot;myOperation&amp;quot;,
}).
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例子&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
    &amp;quot;encoding/json&amp;quot;
    &amp;quot;io/ioutil&amp;quot;
    &amp;quot;net/http&amp;quot;
    &amp;quot;testing&amp;quot;

    &amp;quot;github.com/steinfletcher/apitest&amp;quot;
    &amp;quot;github.com/stretchr/testify/assert&amp;quot;
)

func TestRequests_GraphQLQuery(t *testing.T) {
    apitest.New().
        HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            bodyBytes, err := ioutil.ReadAll(r.Body)
            if err != nil {
                t.Fatal(err)
            }

            var req apitest.GraphQLRequestBody
            if err := json.Unmarshal(bodyBytes, &amp;amp;req); err != nil {
                t.Fatal(err)
            }

            assert.Equal(t, apitest.GraphQLRequestBody{
                Query: `query { todos { text } }`,
            }, req)

            w.WriteHeader(http.StatusOK)
        }).
        Post(&amp;quot;/query&amp;quot;).
        GraphQLQuery(`query { todos { text } }`).
        Expect(t).
        Status(http.StatusOK).
        End()
}

func TestRequests_GraphQLRequest(t *testing.T) {
    apitest.New().
        HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            bodyBytes, err := ioutil.ReadAll(r.Body)
            if err != nil {
                t.Fatal(err)
            }

            var req apitest.GraphQLRequestBody
            if err := json.Unmarshal(bodyBytes, &amp;amp;req); err != nil {
                t.Fatal(err)
            }

            expected := apitest.GraphQLRequestBody{
                Query:         `query { todos { text } }`,
                OperationName: &amp;quot;myOperation&amp;quot;,
                Variables: map[string]interface{}{
                    &amp;quot;a&amp;quot;: float64(1),
                    &amp;quot;b&amp;quot;: &amp;quot;2&amp;quot;,
                },
            }

            assert.Equal(t, expected, req)

            w.WriteHeader(http.StatusOK)
        }).
        Post(&amp;quot;/query&amp;quot;).
        GraphQLRequest(apitest.GraphQLRequestBody{
            Query: &amp;quot;query { todos { text } }&amp;quot;,
            Variables: map[string]interface{}{
                &amp;quot;a&amp;quot;: 1,
                &amp;quot;b&amp;quot;: &amp;quot;2&amp;quot;,
            },
            OperationName: &amp;quot;myOperation&amp;quot;,
        }).
        Expect(t).
        Status(http.StatusOK).
        End()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的例子需要下载一些依赖项，如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-shell&#34;&gt;go get github.com/stretchr/testify
go get github.com/davecgh/go-spew
go get github.com/pmezard/go-difflib
go get gopkg.in/yaml.v3
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;36-headers&#34;&gt;3.6. Headers&lt;/h4&gt;
&lt;p&gt;有多种方法可以指定 http 请求头。以下方法可以一起使用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Map&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;Headers(map[string]string{&amp;quot;name1&amp;quot;: &amp;quot;value1&amp;quot;, &amp;quot;name2&amp;quot;: &amp;quot;value2&amp;quot;})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Params&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;Header(&amp;quot;name&amp;quot;, &amp;quot;value&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;37-intercept&#34;&gt;3.7. Intercept&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;Intercept&lt;/code&gt; 会在请求前调用，允许实现者在请求对象发送到被测系统前对其进行更改。在本例中，我们使用自定义方案设置请求参数。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
    &amp;quot;net/http&amp;quot;
    &amp;quot;testing&amp;quot;

    &amp;quot;github.com/steinfletcher/apitest&amp;quot;
)

func TestIntercept(t *testing.T) {
    handler := func(w http.ResponseWriter, r *http.Request) {
        if r.URL.RawQuery != &amp;quot;a[]=xxx&amp;amp;a[]=yyy&amp;quot; {
            t.Fatal(&amp;quot;unexpected query&amp;quot;)
        }
        w.WriteHeader(http.StatusOK)
    }

    apitest.New().
        HandlerFunc(handler).
        Intercept(func(req *http.Request) {
            req.URL.RawQuery = &amp;quot;a[]=xxx&amp;amp;a[]=yyy&amp;quot;
        }).
        Get(&amp;quot;/&amp;quot;).
        Expect(t).
        Status(http.StatusOK).
        End()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;38-query-params&#34;&gt;3.8. Query Params&lt;/h4&gt;
&lt;p&gt;有多种指定查询参数的方法。这些方法可以一起使用。&lt;/p&gt;
&lt;p&gt;例子&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
    &amp;quot;net/http&amp;quot;
    &amp;quot;testing&amp;quot;

    &amp;quot;github.com/steinfletcher/apitest&amp;quot;
)

func TestRequests_Query(t *testing.T) {
    expectedQueryString := &amp;quot;a=1&amp;amp;a=2&amp;amp;a=9&amp;amp;a=22&amp;amp;b=2&amp;quot;
    handler := func(w http.ResponseWriter, r *http.Request) {
        if expectedQueryString != r.URL.RawQuery {
            w.WriteHeader(http.StatusBadRequest)
            return
        }
        w.WriteHeader(http.StatusOK)
    }

    apitest.New().
        HandlerFunc(handler).
        Get(&amp;quot;/foo&amp;quot;).
        Query(&amp;quot;a&amp;quot;, &amp;quot;9&amp;quot;).
        Query(&amp;quot;a&amp;quot;, &amp;quot;22&amp;quot;).
        QueryCollection(map[string][]string{&amp;quot;a&amp;quot;: {&amp;quot;1&amp;quot;, &amp;quot;2&amp;quot;}}).
        QueryParams(map[string]string{&amp;quot;b&amp;quot;: &amp;quot;2&amp;quot;}).
        Expect(t).
        Status(http.StatusOK).
        End()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Collection&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;QueryCollection(map[string][]string{&amp;quot;a&amp;quot;: {&amp;quot;1&amp;quot;, &amp;quot;2&amp;quot;}})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参数的值设置为 &lt;code&gt;a=1&amp;amp;a=2&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Custom&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果所提供的方法不合适，你可以定义自定义一个请求拦截器。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;apitest.New().
    Handler(handler).
    Intercept(func(req *http.Request) {
        req.URL.RawQuery = &amp;quot;a[]=xxx&amp;amp;a[]=yyy&amp;quot;
    }).
    Get(&amp;quot;/path&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Map&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;QueryParams(map[string]string{&amp;quot;param1&amp;quot;: &amp;quot;value1&amp;quot;, &amp;quot;param2&amp;quot;: &amp;quot;value2&amp;quot;})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Params&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;Query(&amp;quot;param&amp;quot;, &amp;quot;value&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;4&#34;&gt;4. 异常&lt;/h3&gt;
&lt;p&gt;我们提供了多种机制来验证响应。如果这些机制都不能满足您的需要，您可以提供自定义的 Assert 函数。定义请求后，必须调用 Expect(t) 去定义期望的结果。&lt;/p&gt;
&lt;h4 id=&#34;41-body&#34;&gt;4.1. Body&lt;/h4&gt;
&lt;p&gt;通过在 &lt;code&gt;Body&lt;/code&gt; 方法中输入字符串去匹配 HTTP 响应体。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;Expect(t).Body(`{&amp;quot;param&amp;quot;: &amp;quot;value&amp;quot;}`)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;断言库会检查内容是否为 JSON，如果是，则使用 testify 的 assert.JSONEq 方法执行断言。如果内容不是 JSON，则使用 testify 的 assert.Equal 方法。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;package body

import (
    &amp;quot;net/http&amp;quot;
    &amp;quot;testing&amp;quot;

    &amp;quot;github.com/steinfletcher/apitest&amp;quot;
)

func TestAssertBody(t *testing.T) {
    apitest.New().
        HandlerFunc(handler).
        Get(&amp;quot;/greeting&amp;quot;).
        Expect(t).
        Body(`{&amp;quot;message&amp;quot;: &amp;quot;hello&amp;quot;}`).
        End()
}

func handler(w http.ResponseWriter, r *http.Request) {
    w.WriteHeader(http.StatusOK)
    w.Header().Set(&amp;quot;Content-Type&amp;quot;, &amp;quot;application/json&amp;quot;)
    _, _ = w.Write([]byte(`{&amp;quot;message&amp;quot;: &amp;quot;hello&amp;quot;}`))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;42-cookies&#34;&gt;4.2. Cookies&lt;/h4&gt;
&lt;p&gt;断言响应 cookie 的最简单方法是将 cookie 名称和值作为参数提供给 Cookie 方法。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;Cookie(&amp;quot;name&amp;quot;, &amp;quot;value&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例子&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
    &amp;quot;net/http&amp;quot;
    &amp;quot;testing&amp;quot;

    &amp;quot;github.com/steinfletcher/apitest&amp;quot;
)

func TestAssertCookies(t *testing.T) {
    apitest.New().
        HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            http.SetCookie(w, &amp;amp;http.Cookie{Name: &amp;quot;name&amp;quot;, Value: &amp;quot;value&amp;quot;})
            w.WriteHeader(http.StatusOK)
        }).
        Get(&amp;quot;/data&amp;quot;).
        Expect(t).
        Cookie(&amp;quot;name&amp;quot;, &amp;quot;value&amp;quot;).
        End()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Cookie Not Present&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这是与 CookiePresent 相反的行为，用于判断断言响应中不存在具有给定名称的 cookie。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;CookieNotPresent(&amp;quot;Session-Token&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例子&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
    &amp;quot;net/http&amp;quot;
    &amp;quot;testing&amp;quot;

    &amp;quot;github.com/steinfletcher/apitest&amp;quot;
)

func TestAssertCookies_NotPresent(t *testing.T) {
    apitest.New().
        HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            http.SetCookie(w, &amp;amp;http.Cookie{Name: &amp;quot;name&amp;quot;, Value: &amp;quot;value&amp;quot;})
            w.WriteHeader(http.StatusOK)
        }).
        Get(&amp;quot;/data&amp;quot;).
        Expect(t).
        CookieNotPresent(&amp;quot;token&amp;quot;).
        End()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Cookie Present&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有时，应用程序会生成一个具有动态值的 cookie。如果不需要断言值，可使用 CookiePresent 方法，它只会断言 cookie 已被设置为给定的键。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;CookiePresent(&amp;quot;Session-Token&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;apitest 会在内部保存 cookie，因此您可以多次调用此方法，对多个 cookie 进行断言。&lt;/p&gt;
&lt;p&gt;例子&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
    &amp;quot;net/http&amp;quot;
    &amp;quot;testing&amp;quot;

    &amp;quot;github.com/steinfletcher/apitest&amp;quot;
)

func TestAssertCookies_Present(t *testing.T) {
    apitest.New().
        HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            http.SetCookie(w, &amp;amp;http.Cookie{Name: &amp;quot;name&amp;quot;, Value: &amp;quot;value&amp;quot;})
            w.WriteHeader(http.StatusOK)
        }).
        Get(&amp;quot;/data&amp;quot;).
        Expect(t).
        CookiePresent(&amp;quot;name&amp;quot;).
        End()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Struct&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Cookies 是一个被用于获取已定义的不同数量的 cookie 的结构体。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;Cookies(apitest.NewCookie(&amp;quot;name&amp;quot;).
    Value(&amp;quot;value&amp;quot;).
    Path(&amp;quot;/user&amp;quot;).
    Domain(&amp;quot;example.com&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该结构的底层字段都是指针类型。这样，断言库就可以忽略结构体中未定义的字段。&lt;/p&gt;
&lt;p&gt;例子&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
    &amp;quot;net/http&amp;quot;
    &amp;quot;testing&amp;quot;

    &amp;quot;github.com/steinfletcher/apitest&amp;quot;
)

func TestAssertCookies_Struct(t *testing.T) {
    apitest.New().
        HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            http.SetCookie(w, &amp;amp;http.Cookie{Name: &amp;quot;name1&amp;quot;, Value: &amp;quot;value1&amp;quot;, Path: &amp;quot;/path1&amp;quot;, Secure: true})
            http.SetCookie(w, &amp;amp;http.Cookie{Name: &amp;quot;name2&amp;quot;, Value: &amp;quot;value2&amp;quot;, Path: &amp;quot;/path2&amp;quot;, Secure: false})
            w.WriteHeader(http.StatusOK)
        }).
        Get(&amp;quot;/data&amp;quot;).
        Expect(t).
        Cookies(
            apitest.NewCookie(&amp;quot;name1&amp;quot;).Value(&amp;quot;value1&amp;quot;).Secure(true).Path(&amp;quot;/path1&amp;quot;),
            apitest.NewCookie(&amp;quot;name2&amp;quot;).Value(&amp;quot;value2&amp;quot;).Secure(false).Path(&amp;quot;/path2&amp;quot;),
        ).
        End()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;43&#34;&gt;4.3. 自定义&lt;/h4&gt;
&lt;p&gt;通过执行签名 &lt;code&gt;fn func(*http.Response, *http.Request) error&lt;/code&gt;，提供自定义断言函数。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;Assert(func(res *http.Response, _ *http.Request) error {
    if res.StatusCode &amp;gt;= 200 &amp;amp;&amp;amp; res.StatusCode &amp;lt; 400 {
        return nil
    }
    return errors.New(&amp;quot;unexpected status code&amp;quot;)
}).
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;自定义断言函数可以是链式的。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;package body

import (
    &amp;quot;errors&amp;quot;
    &amp;quot;net/http&amp;quot;
    &amp;quot;testing&amp;quot;

    &amp;quot;github.com/steinfletcher/apitest&amp;quot;
)

func TestAssert_Custom(t *testing.T) {
    apitest.New().
        HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            w.WriteHeader(http.StatusCreated)
        }).
        Get(&amp;quot;/data&amp;quot;).
        Expect(t).
        Assert(isSuccess).
        End()
}

func isSuccess(res *http.Response, _ *http.Request) error {
    if res.StatusCode &amp;gt;= 200 &amp;amp;&amp;amp; res.StatusCode &amp;lt; 400 {
        return nil
    }
    return errors.New(&amp;quot;unexpected status code&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;44-headers&#34;&gt;4.4. Headers&lt;/h4&gt;
&lt;p&gt;有两种方法可以指定 HTTP 响应头。以下方法可以连锁使用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Map&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;Headers(map[string]string{&amp;quot;name1&amp;quot;: &amp;quot;value1&amp;quot;, &amp;quot;name2&amp;quot;: &amp;quot;value2&amp;quot;})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;头信息在 apitest 内部以规范形式存储。例如，&#34;accept-encoding &#34;的规范键是 &#34;Accept-Encoding&#34;。如果内容是 JSON，则使用 testify 的 assert.JSONEq 方法执行断言。如果内容不是 JSON，则使用 testify 的 assert.Equal 方法。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;package body

import (
    &amp;quot;net/http&amp;quot;
    &amp;quot;testing&amp;quot;

    &amp;quot;github.com/steinfletcher/apitest&amp;quot;
)

func TestAssertHeaders_Map(t *testing.T) {
    apitest.New().
        HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            w.Header().Set(&amp;quot;name1&amp;quot;, &amp;quot;value1&amp;quot;)
            w.Header().Set(&amp;quot;name2&amp;quot;, &amp;quot;value2&amp;quot;)
            w.WriteHeader(http.StatusOK)
        }).
        Get(&amp;quot;/data&amp;quot;).
        Expect(t).
        Headers(map[string]string{&amp;quot;name1&amp;quot;: &amp;quot;value1&amp;quot;, &amp;quot;name2&amp;quot;: &amp;quot;value2&amp;quot;}).
        End()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Params&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;Header(&amp;quot;name&amp;quot;, &amp;quot;value&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例子&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;package body

import (
    &amp;quot;net/http&amp;quot;
    &amp;quot;testing&amp;quot;

    &amp;quot;github.com/steinfletcher/apitest&amp;quot;
)

func TestAssertHeaders_Params(t *testing.T) {
    apitest.New().
        HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            w.Header().Set(&amp;quot;name&amp;quot;, &amp;quot;value&amp;quot;)
            w.WriteHeader(http.StatusOK)
        }).
        Get(&amp;quot;/data&amp;quot;).
        Expect(t).
        Header(&amp;quot;name&amp;quot;, &amp;quot;value&amp;quot;).
        End()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;45-json-path&#34;&gt;4.5. JSON Path&lt;/h4&gt;
&lt;p&gt;您可以使用 JSONPath 来断言响应中的部分内容。当你只对响应中的特定字段感兴趣时，这就很有用了。首先要安装一个单独的模块来提供这些断言，如下：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;get -u github.com/steinfletcher/apitest-jsonpath&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;例子&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;package jsonpath

import (
    &amp;quot;net/http&amp;quot;
    &amp;quot;testing&amp;quot;

    &amp;quot;github.com/steinfletcher/apitest&amp;quot;
    &amp;quot;github.com/steinfletcher/apitest-jsonpath&amp;quot;
)

func TestJSONPath(t *testing.T) {
    handler := http.NewServeMux()
    handler.HandleFunc(&amp;quot;/data&amp;quot;, func(w http.ResponseWriter, r *http.Request) {
        w.WriteHeader(http.StatusOK)
        w.Header().Set(&amp;quot;Content-Type&amp;quot;, &amp;quot;application/json&amp;quot;)
        _, _ = w.Write([]byte(`{
          &amp;quot;aValue&amp;quot;: &amp;quot;0&amp;quot;,
          &amp;quot;anObject&amp;quot;: {&amp;quot;a&amp;quot;: &amp;quot;1&amp;quot;, &amp;quot;b&amp;quot;:  12345},
          &amp;quot;matches&amp;quot;: {
            &amp;quot;anObject&amp;quot;: {
              &amp;quot;aString&amp;quot;: &amp;quot;tom&amp;lt;3Beer&amp;quot;,
              &amp;quot;aNumber&amp;quot;: 7.212,
              &amp;quot;aBool&amp;quot;: true
            },
            &amp;quot;aString&amp;quot;: &amp;quot;tom&amp;lt;3Beer&amp;quot;,
            &amp;quot;aNumber&amp;quot;: 7,
            &amp;quot;aNumberSlice&amp;quot;: [7, 8, 9],
            &amp;quot;aStringSlice&amp;quot;: [&amp;quot;7&amp;quot;, &amp;quot;8&amp;quot;, &amp;quot;9&amp;quot;],
            &amp;quot;anObjectSlice&amp;quot;: [{&amp;quot;key&amp;quot;:  &amp;quot;c&amp;quot;, &amp;quot;value&amp;quot;: &amp;quot;ABC&amp;quot;}]
          }
        }`))
    })

    apitest.New().
        Handler(handler).
        Get(&amp;quot;/data&amp;quot;).
        Expect(t).
        Assert(jsonpath.Equal(&amp;quot;aValue&amp;quot;, &amp;quot;0&amp;quot;)).
        Assert(jsonpath.NotEqual(&amp;quot;aValue&amp;quot;, &amp;quot;1&amp;quot;)).
        Assert(jsonpath.Present(&amp;quot;aValue&amp;quot;)).
        Assert(jsonpath.NotPresent(&amp;quot;x&amp;quot;)).
        Assert(jsonpath.Equal(`$.anObject`, map[string]interface{}{&amp;quot;a&amp;quot;: &amp;quot;1&amp;quot;, &amp;quot;b&amp;quot;: float64(12345)})).
        Assert(jsonpath.Contains(`$.matches.anObjectSlice[? @.key==&amp;quot;c&amp;quot;].value`, &amp;quot;ABC&amp;quot;)).
        Assert(
            jsonpath.Root(&amp;quot;matches&amp;quot;).
                Matches(`aString`, `^[mot]{3}&amp;lt;3[AB][re]{3}$`).
                Matches(`aNumber`, `^\d$`).
                Matches(`anObject.aNumber`, `^\d\.\d{3}$`).
                Matches(`aNumberSlice[1]`, `^[80]$`).
                Matches(`anObject.aBool`, `^true$`).
                End(),
        ).
        Assert(
            jsonpath.Chain().
                NotPresent(&amp;quot;password&amp;quot;).
                NotEqual(&amp;quot;aValue&amp;quot;, &amp;quot;12&amp;quot;).
                End(),
        ).
        End()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的项目需要用到如下依赖，如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-shell&#34;&gt;go get github.com/steinfletcher/apitest-jsonpath
go get github.com/PaesslerAG/jsonpath
go get github.com/PaesslerAG/gval
go get github.com/shopspring/decimal
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Chain&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;同时提供多种解决方案&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;Assert(
    jsonpath.Chain().
        Equal(&amp;quot;a&amp;quot;, &amp;quot;1&amp;quot;).
        NotEqual(&amp;quot;b&amp;quot;, &amp;quot;2&amp;quot;).
        Present(&amp;quot;c&amp;quot;).
        End(),
).
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例子&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;package jsonpath

import (
    &amp;quot;net/http&amp;quot;
    &amp;quot;testing&amp;quot;

    &amp;quot;github.com/steinfletcher/apitest&amp;quot;
    &amp;quot;github.com/steinfletcher/apitest-jsonpath&amp;quot;
)

func TestJSONPath_Chain(t *testing.T) {
    apitest.New().
        HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            w.WriteHeader(http.StatusOK)
            w.Header().Set(&amp;quot;Content-Type&amp;quot;, &amp;quot;application/json&amp;quot;)
            _, _ = w.Write([]byte(`{&amp;quot;a&amp;quot;: &amp;quot;1&amp;quot;, &amp;quot;b&amp;quot;: &amp;quot;3&amp;quot;, &amp;quot;c&amp;quot;: &amp;quot;4&amp;quot;}`))
        }).
        Get(&amp;quot;/data&amp;quot;).
        Expect(t).
        Assert(jsonpath.Chain().
            Equal(&amp;quot;a&amp;quot;, &amp;quot;1&amp;quot;).
            NotEqual(&amp;quot;b&amp;quot;, &amp;quot;2&amp;quot;).
            Present(&amp;quot;c&amp;quot;).
            End()).
        End()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Contains&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当选择器返回使用 &lt;code&gt;Contains&lt;/code&gt; 的数组类型时，假设响应中的 JSON 主体为 {&#34;id&#34;： 12345, &#34;items&#34;： [{&#34;available&#34;: true, &#34;color&#34;: &#34;red&#34;}, {&#34;available&#34;: false, &#34;color&#34;: &#34;blue&#34;}]}, 我们可以选择所有在结果中可用于断言的颜色值。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;Assert(jsonpath.Contains(&amp;quot;$.items[?@.available==true].color&amp;quot;, &amp;quot;red&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例子&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;package jsonpath

import (
    &amp;quot;net/http&amp;quot;
    &amp;quot;testing&amp;quot;

    &amp;quot;github.com/steinfletcher/apitest&amp;quot;
    &amp;quot;github.com/steinfletcher/apitest-jsonpath&amp;quot;
)

func TestJSONPath_Contains(t *testing.T) {
    apitest.New().
        HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            w.WriteHeader(http.StatusOK)
            w.Header().Set(&amp;quot;Content-Type&amp;quot;, &amp;quot;application/json&amp;quot;)
            _, _ = w.Write([]byte(`{
              &amp;quot;items&amp;quot;: [
                {
                  &amp;quot;available&amp;quot;: true,
                  &amp;quot;color&amp;quot;: &amp;quot;red&amp;quot;
                },
                {
                  &amp;quot;available&amp;quot;: false,
                  &amp;quot;color&amp;quot;: &amp;quot;blue&amp;quot;
                }
              ]
            }`))
        }).
        Get(&amp;quot;/data&amp;quot;).
        Expect(t).
        Assert(jsonpath.Contains(&amp;quot;$.items[?@.available==true].color&amp;quot;, &amp;quot;red&amp;quot;)).
        End()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Equal&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当选择器返回单个值时，使用 Equal。假设响应中的 JSON 主体为 {&#34;id&#34;： &#34;12345&#34;}&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;Assert(jsonpath.Equal(&amp;quot;$.id&amp;quot;, &amp;quot;12345&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例子&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;package jsonpath

import (
    &amp;quot;net/http&amp;quot;
    &amp;quot;testing&amp;quot;

    &amp;quot;github.com/steinfletcher/apitest&amp;quot;
    &amp;quot;github.com/steinfletcher/apitest-jsonpath&amp;quot;
)

func TestJSONPath_Equal(t *testing.T) {
    apitest.New().
        HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            w.WriteHeader(http.StatusOK)
            w.Header().Set(&amp;quot;Content-Type&amp;quot;, &amp;quot;application/json&amp;quot;)
            _, _ = w.Write([]byte(`{&amp;quot;message&amp;quot;: &amp;quot;hello&amp;quot;}`))
        }).
        Get(&amp;quot;/data&amp;quot;).
        Expect(t).
        Assert(jsonpath.Equal(&amp;quot;message&amp;quot;, &amp;quot;hello&amp;quot;)).
        End()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Greater Than&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用 &#34;大于 &#34;对返回值执行最小长度限制。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;Assert(jsonpath.GreaterThan(&amp;quot;$.items&amp;quot;, 2))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例子&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;package jsonpath

import (
    &amp;quot;net/http&amp;quot;
    &amp;quot;testing&amp;quot;

    &amp;quot;github.com/steinfletcher/apitest&amp;quot;
    &amp;quot;github.com/steinfletcher/apitest-jsonpath&amp;quot;
)

func TestJSONPath_GreaterThan_LessThan(t *testing.T) {
    apitest.New().
        HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            w.WriteHeader(http.StatusOK)
            w.Header().Set(&amp;quot;Content-Type&amp;quot;, &amp;quot;application/json&amp;quot;)
            _, _ = w.Write([]byte(`{&amp;quot;items&amp;quot;: [3, 4]}`))
        }).
        Get(&amp;quot;/data&amp;quot;).
        Expect(t).
        Assert(jsonpath.GreaterThan(&amp;quot;items&amp;quot;, 1)).
        Assert(jsonpath.LessThan(&amp;quot;items&amp;quot;, 3)).
        End()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;JWT Matchers&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;JWTHeaderEqual&lt;/code&gt; 和 &lt;code&gt;JWTPayloadEqual&lt;/code&gt; 可用于断言响应中的 JWT 内容（不会验证 JWT）。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;func Test(t *testing.T) {
    apitest.New().
        HandlerFunc(myHandler).
        Post(&amp;quot;/login&amp;quot;).
        Expect(t).
        Assert(jsonpath.JWTPayloadEqual(fromAuthHeader, `$.sub`, &amp;quot;1234567890&amp;quot;)).
        Assert(jsonpath.JWTHeaderEqual(fromAuthHeader, `$.alg`, &amp;quot;HS256&amp;quot;)).
        End()
}

func fromAuthHeader(res *http.Response) (string, error) {
    return res.Header.Get(&amp;quot;Authorization&amp;quot;), nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例子&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;func Test(t *testing.T) {
    apitest.New().
        HandlerFunc(myHandler).
        Post(&amp;quot;/login&amp;quot;).
        Expect(t).
        Assert(jsonpath.JWTPayloadEqual(fromAuthHeader, `$.sub`, &amp;quot;1234567890&amp;quot;)).
        Assert(jsonpath.JWTHeaderEqual(fromAuthHeader, `$.alg`, &amp;quot;HS256&amp;quot;)).
        End()
}

func fromAuthHeader(res *http.Response) (string, error) {
    return res.Header.Get(&amp;quot;Authorization&amp;quot;), nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Len&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;Len&lt;/code&gt; 检查返回值的长度。如果响应是 {&#34;items&#34;： [1, 2, 3]}，我们可以这样断言项的长度&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;Assert(jsonpath.Len(&amp;quot;$.items&amp;quot;, 3))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例子&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;package jsonpath

import (
    &amp;quot;net/http&amp;quot;
    &amp;quot;testing&amp;quot;

    &amp;quot;github.com/steinfletcher/apitest&amp;quot;
    &amp;quot;github.com/steinfletcher/apitest-jsonpath&amp;quot;
)

func TestJSONPath_Len(t *testing.T) {
    apitest.New().
        HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            _, _ = w.Write([]byte(`{&amp;quot;items&amp;quot;: [1, 2, 3]}`))
            w.WriteHeader(http.StatusOK)
        }).
        Get(&amp;quot;/hello&amp;quot;).
        Expect(t).
        Assert(jsonpath.Len(`$.items`, 3)).
        End()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Less Than&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;LessThan&lt;/code&gt; 对返回值执行最大长度限制。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;Assert(jsonpath.LessThan(&amp;quot;$.items&amp;quot;, 2))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例子&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;package jsonpath

import (
    &amp;quot;net/http&amp;quot;
    &amp;quot;testing&amp;quot;

    &amp;quot;github.com/steinfletcher/apitest&amp;quot;
    &amp;quot;github.com/steinfletcher/apitest-jsonpath&amp;quot;
)

func TestJSONPath_GreaterThan_LessThan(t *testing.T) {
    apitest.New().
        HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            w.WriteHeader(http.StatusOK)
            w.Header().Set(&amp;quot;Content-Type&amp;quot;, &amp;quot;application/json&amp;quot;)
            _, _ = w.Write([]byte(`{&amp;quot;items&amp;quot;: [3, 4]}`))
        }).
        Get(&amp;quot;/data&amp;quot;).
        Expect(t).
        Assert(jsonpath.GreaterThan(&amp;quot;items&amp;quot;, 1)).
        Assert(jsonpath.LessThan(&amp;quot;items&amp;quot;, 3)).
        End()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Matches&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;Matches&lt;/code&gt; 检查字符串、数字或布尔类型的单个路径元素是否与正则表达式匹配。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;Assert(jsonpath.Matches(&amp;quot;$.a&amp;quot;, &amp;quot;^[abc]{1,3}$&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例子&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;package jsonpath

import (
    &amp;quot;net/http&amp;quot;
    &amp;quot;testing&amp;quot;

    &amp;quot;github.com/steinfletcher/apitest&amp;quot;
    &amp;quot;github.com/steinfletcher/apitest-jsonpath&amp;quot;
)

func TestJSONPath_Matches(t *testing.T) {
    handler := http.NewServeMux()
    handler.HandleFunc(&amp;quot;/data&amp;quot;, func(w http.ResponseWriter, r *http.Request) {
        w.WriteHeader(http.StatusOK)
        w.Header().Set(&amp;quot;Content-Type&amp;quot;, &amp;quot;application/json&amp;quot;)
        _, _ = w.Write([]byte(`{
          &amp;quot;matches&amp;quot;: {
            &amp;quot;anObject&amp;quot;: {
              &amp;quot;aString&amp;quot;: &amp;quot;tom&amp;lt;3Beer&amp;quot;,
              &amp;quot;aNumber&amp;quot;: 7.212,
              &amp;quot;aBool&amp;quot;: true
            },
            &amp;quot;aString&amp;quot;: &amp;quot;tom&amp;lt;3Beer&amp;quot;,
            &amp;quot;aNumber&amp;quot;: 7,
            &amp;quot;aNumberSlice&amp;quot;: [7, 8, 9],
            &amp;quot;aStringSlice&amp;quot;: [&amp;quot;7&amp;quot;, &amp;quot;8&amp;quot;, &amp;quot;9&amp;quot;],
            &amp;quot;anObjectSlice&amp;quot;: [{&amp;quot;key&amp;quot;:  &amp;quot;c&amp;quot;, &amp;quot;value&amp;quot;: &amp;quot;ABC&amp;quot;}]
          }
        }`))
    })

    apitest.New().
        Handler(handler).
        Get(&amp;quot;/data&amp;quot;).
        Expect(t).
        Assert(
            jsonpath.Root(&amp;quot;matches&amp;quot;).
                Matches(`aString`, `^[mot]{3}&amp;lt;3[AB][re]{3}$`).
                Matches(`aNumber`, `^\d$`).
                Matches(`anObject.aNumber`, `^\d\.\d{3}$`).
                Matches(`aNumberSlice[1]`, `^[80]$`).
                Matches(`anObject.aBool`, `^true$`).
                End(),
        ).
        End()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Not Equal&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;NotEqual&lt;/code&gt; 检查 json 路径表达式值是否不等于给定值&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;Assert(jsonpath.NotEqual(&amp;quot;$.id&amp;quot;, &amp;quot;56789&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例子&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;package jsonpath

import (
    &amp;quot;net/http&amp;quot;
    &amp;quot;testing&amp;quot;

    &amp;quot;github.com/steinfletcher/apitest&amp;quot;
    &amp;quot;github.com/steinfletcher/apitest-jsonpath&amp;quot;
)

func TestJSONPath_NotEqual(t *testing.T) {
    apitest.New().
        HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            w.WriteHeader(http.StatusOK)
            w.Header().Set(&amp;quot;Content-Type&amp;quot;, &amp;quot;application/json&amp;quot;)
            _, _ = w.Write([]byte(`{&amp;quot;message&amp;quot;: &amp;quot;hello&amp;quot;}`))
        }).
        Get(&amp;quot;/data&amp;quot;).
        Expect(t).
        Assert(jsonpath.NotEqual(&amp;quot;message&amp;quot;, &amp;quot;hello1&amp;quot;)).
        End()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Not Present&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;NotPresent&lt;/code&gt; 来检查响应中是否缺少某个字段，而不对其值进行评估。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;Assert(jsonpath.NotPresent(&amp;quot;password&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例子&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;package jsonpath

import (
    &amp;quot;net/http&amp;quot;
    &amp;quot;testing&amp;quot;

    &amp;quot;github.com/steinfletcher/apitest&amp;quot;
    &amp;quot;github.com/steinfletcher/apitest-jsonpath&amp;quot;
)

func TestJSONPath_NotPresent(t *testing.T) {
    apitest.New().
        HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            w.WriteHeader(http.StatusOK)
            w.Header().Set(&amp;quot;Content-Type&amp;quot;, &amp;quot;application/json&amp;quot;)
            _, _ = w.Write([]byte(`{&amp;quot;name&amp;quot;: &amp;quot;jan&amp;quot;}`))
        }).
        Get(&amp;quot;/user&amp;quot;).
        Expect(t).
        Assert(jsonpath.NotPresent(&amp;quot;password&amp;quot;)).
        End()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Present&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;检查响应中是否存在字段，但不评估其值。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;Assert(jsonpath.Present(&amp;quot;token&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例子&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;package jsonpath

import (
    &amp;quot;net/http&amp;quot;
    &amp;quot;testing&amp;quot;

    &amp;quot;github.com/steinfletcher/apitest&amp;quot;
    &amp;quot;github.com/steinfletcher/apitest-jsonpath&amp;quot;
)

func TestJSONPath_Present(t *testing.T) {
    apitest.New().
        HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            w.WriteHeader(http.StatusOK)
            w.Header().Set(&amp;quot;Content-Type&amp;quot;, &amp;quot;application/json&amp;quot;)
            _, _ = w.Write([]byte(`{&amp;quot;token&amp;quot;: &amp;quot;f9a5eb123c01de&amp;quot;}`))
        }).
        Post(&amp;quot;/login&amp;quot;).
        Expect(t).
        Assert(jsonpath.Present(&amp;quot;token&amp;quot;)).
        End()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Root&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Root&lt;/code&gt; 用于避免在body中出现重复路径。如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;Assert(jsonpath.Equal(&amp;quot;$.a.b.c.d&amp;quot;, &amp;quot;a&amp;quot;)).
Assert(jsonpath.Equal(&amp;quot;$.a.b.c.e&amp;quot;, &amp;quot;b&amp;quot;)).
Assert(jsonpath.Equal(&amp;quot;$.a.b.c.f&amp;quot;, &amp;quot;c&amp;quot;)).
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也可以这样定义 &lt;code&gt;Root&lt;/code&gt; 路径&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;Assert(
    jsonpath.Root(&amp;quot;a.b.c&amp;quot;).
        Equal(&amp;quot;d&amp;quot;, &amp;quot;a&amp;quot;).
        Equal(&amp;quot;e&amp;quot;, &amp;quot;b&amp;quot;).
        Equal(&amp;quot;f&amp;quot;, &amp;quot;c&amp;quot;).
        End(),
)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;46-status-code&#34;&gt;4.6. Status code&lt;/h4&gt;
&lt;p&gt;使用 &lt;code&gt;status&lt;/code&gt; 方法匹配 http 状态代码。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;Expect(t).Status(http.StatusOK)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例子&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;package jsonpath

import (
    &amp;quot;net/http&amp;quot;
    &amp;quot;testing&amp;quot;

    &amp;quot;github.com/steinfletcher/apitest&amp;quot;
)

func TestAssertions_StatusCode(t *testing.T) {
    apitest.New().
        HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            w.WriteHeader(http.StatusOK)
        }).
        Get(&amp;quot;/ping&amp;quot;).
        Expect(t).
        Status(http.StatusOK).
        End()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;5-mocks&#34;&gt;5. MOCKS&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;我们为什么要用 &lt;code&gt;mocks&lt;/code&gt;？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;应用程序与外部应用程序接口集成的情况非常普遍。在开发阶段运行测试时，最好有一个较短的反馈回路，而且测试必须是可重复和可再现的。与真正的外部应用程序接口集成会增加一些未知因素，这些因素往往会因为无法控制的原因而导致测试失败。&lt;/p&gt;
&lt;p&gt;模拟外部调用可提高开发生命周期测试阶段的稳定性，帮助您更有信心地快速发布功能。这并不能取代集成测试。要不要进行mocks没有硬性规定，因项目而异。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Mocks如何工作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;apitest 中的 mock 在很大程度上受到了 gock 的启发。模拟包劫持了默认的 HTTP 传输，并实现了一个自定义的 RoundTrip 方法。如果发出的 HTTP 请求与定义的模拟集合相匹配，模拟中定义的结果将返回给调用者。&lt;/p&gt;
&lt;h4 id=&#34;51-mocks&#34;&gt;5.1. 定义Mocks&lt;/h4&gt;
&lt;p&gt;调用 &lt;code&gt;apitest.NewMock()&lt;/code&gt; 工厂方法可定义 mock。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;var mock = apitest.NewMock().
    Get(&amp;quot;http://external.com/user/12345&amp;quot;).
    RespondWith().
    Body(`{&amp;quot;name&amp;quot;: &amp;quot;jon&amp;quot;}`).
    Status(http.StatusOK).
    End()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在上例中，当 HTTP 客户向 http://example.com/user/12345 发送 GET 请求时，{&#34;name&#34;： &#34;jon&#34;} 会在响应体中以 HTTP 状态代码 200 返回。&lt;/p&gt;
&lt;p&gt;然后就可以在 apitest 配置部分添加 mock，如下所示：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;apitest.New().
    Mocks(mock).
    Handler(httpHandler).
    Get(&amp;quot;/user&amp;quot;).
    Expect(t).
    Status(http.StatusOK).
    End()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例子&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;package defining_mocks

import (
    &amp;quot;encoding/json&amp;quot;
    &amp;quot;fmt&amp;quot;
    &amp;quot;io/ioutil&amp;quot;
    &amp;quot;net/http&amp;quot;
    &amp;quot;testing&amp;quot;

    &amp;quot;github.com/steinfletcher/apitest&amp;quot;
)

func TestMocks(t *testing.T) {
    getUserMock := apitest.NewMock().
        Get(&amp;quot;/user-api&amp;quot;).
        RespondWith().
        Body(`{&amp;quot;name&amp;quot;: &amp;quot;jon&amp;quot;, &amp;quot;id&amp;quot;: &amp;quot;1234&amp;quot;}`).
        Status(http.StatusOK).
        End()

    getPreferencesMock := apitest.NewMock().
        Get(&amp;quot;/preferences-api&amp;quot;).
        RespondWith().
        Body(`{&amp;quot;is_contactable&amp;quot;: false}`).
        Status(http.StatusOK).
        End()

    apitest.New().
        Mocks(getUserMock, getPreferencesMock).
        Handler(myHandler()).
        Get(&amp;quot;/user&amp;quot;).
        Expect(t).
        Status(http.StatusOK).
        Body(`{&amp;quot;name&amp;quot;: &amp;quot;jon&amp;quot;, &amp;quot;is_contactable&amp;quot;: false}`).
        End()
}

func myHandler() *http.ServeMux {
    handler := http.NewServeMux()
    handler.HandleFunc(&amp;quot;/user&amp;quot;, func(w http.ResponseWriter, r *http.Request) {
        var user user
        if err := httpGet(&amp;quot;/user-api&amp;quot;, &amp;amp;user); err != nil {
            w.WriteHeader(http.StatusInternalServerError)
            return
        }

        var contactPreferences contactPreferences
        if err := httpGet(&amp;quot;/preferences-api&amp;quot;, &amp;amp;contactPreferences); err != nil {
            w.WriteHeader(http.StatusInternalServerError)
            return
        }

        response := userResponse{
            Name:          user.Name,
            IsContactable: contactPreferences.IsContactable,
        }

        bytes, _ := json.Marshal(response)
        _, err := w.Write(bytes)
        if err != nil {
            w.WriteHeader(http.StatusInternalServerError)
            return
        }

        w.WriteHeader(http.StatusOK)
    })
    return handler
}

type user struct {
    Name string `json:&amp;quot;name&amp;quot;`
    ID   string `json:&amp;quot;id&amp;quot;`
}

type contactPreferences struct {
    IsContactable bool `json:&amp;quot;is_contactable&amp;quot;`
}

type userResponse struct {
    Name          string `json:&amp;quot;name&amp;quot;`
    IsContactable bool   `json:&amp;quot;is_contactable&amp;quot;`
}

func httpGet(path string, response interface{}) error {
    res, err := http.DefaultClient.Get(fmt.Sprintf(&amp;quot;http://localhost:8080%s&amp;quot;, path))
    if err != nil {
        return err
    }

    bytes, err := ioutil.ReadAll(res.Body)
    if err != nil {
        return err
    }

    err = json.Unmarshal(bytes, response)
    if err != nil {
        return err
    }

    return nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;52-matchers&#34;&gt;5.2. Matchers&lt;/h4&gt;
&lt;p&gt;您可以为header、cookie、url 查询参数和body添加匹配器。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Body&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Body 允许您为请求报文添加匹配器。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;var getUserMock = apitest.NewMock().
    Post(&amp;quot;http://example.com/user/12345&amp;quot;).
    Body(`{&amp;quot;username&amp;quot;: &amp;quot;John&amp;quot;}`).
    RespondWith().
    Status(http.StatusOK).
    End()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果要处理 URL 编码的表单正文，可以使用 &lt;code&gt;FormData&lt;/code&gt; 来匹配键和值。正则表达式也可以作为值。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;FormData(&amp;quot;name&amp;quot;, &amp;quot;Simon&amp;quot;).
FormData(&amp;quot;name&amp;quot;, &amp;quot;Jo([a-z]+)n&amp;quot;).
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;您还可以要求表单体键存在（FormDataPresent）或不存在（FormDataNotPresent）。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;FormDataPresent(&amp;quot;name&amp;quot;).
FormDataNotPresent(&amp;quot;pets&amp;quot;).
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;JSONPath 扩展提供了一个自定义匹配器，支持在请求正文中进行匹配。这对部分匹配正文非常有用。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;apitest.NewMock().
    Post(&amp;quot;/user-external&amp;quot;).
    AddMatcher(mocks.Equal(&amp;quot;$.name&amp;quot;, &amp;quot;jan&amp;quot;)).
    RespondWith().
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例子&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;package matchers

import (
    &amp;quot;bytes&amp;quot;
    jsonpath &amp;quot;github.com/steinfletcher/apitest-jsonpath/mocks&amp;quot;
    &amp;quot;io/ioutil&amp;quot;
    &amp;quot;net/http&amp;quot;
    &amp;quot;testing&amp;quot;

    &amp;quot;github.com/steinfletcher/apitest&amp;quot;
)

func TestMocks(t *testing.T) {
    createUserMock := apitest.NewMock().
        Post(&amp;quot;/user-external&amp;quot;).
        AddMatcher(jsonpath.Equal(&amp;quot;$.name&amp;quot;, &amp;quot;jan&amp;quot;)).
        RespondWith().
        Status(http.StatusCreated).
        End()

    apitest.New().
        Mocks(createUserMock).
        Handler(myHandler()).
        Post(&amp;quot;/user&amp;quot;).
        JSON(map[string]string{&amp;quot;name&amp;quot;: &amp;quot;jan&amp;quot;}).
        Expect(t).
        Status(http.StatusCreated).
        End()
}

func myHandler() *http.ServeMux {
    handler := http.NewServeMux()
    handler.HandleFunc(&amp;quot;/user&amp;quot;, func(w http.ResponseWriter, r *http.Request) {
        reqBody, err := ioutil.ReadAll(r.Body)
        if err != nil {
            panic(err)
        }

        _, err = http.DefaultClient.Post(&amp;quot;http://localhost:8080/user-external&amp;quot;, &amp;quot;application/json&amp;quot;, bytes.NewReader(reqBody))
        if err != nil {
            panic(err)
        }

        w.WriteHeader(http.StatusCreated)
    })
    return handler
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Cookies&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Cookie&lt;/code&gt; 允许您为 cookie 名称和值添加匹配器。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;var getUserMock = apitest.NewMock().
    Get(&amp;quot;http://example.com/user/12345&amp;quot;).
    Cookie(&amp;quot;sessionid&amp;quot;, &amp;quot;1321&amp;quot;).
    RespondWith().
    Body(`{&amp;quot;name&amp;quot;: &amp;quot;jon&amp;quot;}`).
    Status(http.StatusOK).
    End()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;您还可以要求 cookie 名称存在（&lt;code&gt;CookiePresent&lt;/code&gt;）或不存在（&lt;code&gt;CookieNotPresent&lt;/code&gt;）。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;var getUserMock = apitest.NewMock().
    Get(&amp;quot;http://example.com/user/12345&amp;quot;).
    CookiePresent(&amp;quot;trackingid&amp;quot;).
    CookieNotPresent(&amp;quot;analytics&amp;quot;).
    RespondWith().
    Body(`{&amp;quot;name&amp;quot;: &amp;quot;jon&amp;quot;}`).
    Status(http.StatusOK).
    End()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Custom matchers&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;您可以使用 &lt;code&gt;AddMatcher&lt;/code&gt; 编写自己的自定义匹配器。匹配器函数定义为 &lt;code&gt;func(*http.Request, *MockRequest) error&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;var getUserMock = apitest.NewMock().
    Post(&amp;quot;http://example.com/user/12345&amp;quot;).
    AddMatcher(func(req *http.Request, mockReq *MockRequest) error {
        if req.Method == http.MethodPost {
            return nil
        }
        return errors.New(&amp;quot;invalid http method&amp;quot;)
    }).
    RespondWith().
    Status(http.StatusOK).
    End()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Header&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Header&lt;/code&gt; 允许为头信息键和值添加匹配器。正则表达式也可以作为值&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;var getUserMock = apitest.NewMock().
    Get(&amp;quot;http://example.com/user/12345&amp;quot;).
    Header(&amp;quot;foo&amp;quot;, &amp;quot;bar&amp;quot;).
    Header(&amp;quot;token&amp;quot;, &amp;quot;b([a-z]+)z&amp;quot;).
    Headers(map[string]string{&amp;quot;name&amp;quot;: &amp;quot;John&amp;quot;})
    RespondWith().
    Body(`{&amp;quot;name&amp;quot;: &amp;quot;jon&amp;quot;}`).
    Status(http.StatusOK).
    End()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;您也可以要求头必须存在（&lt;code&gt;HeaderPresent&lt;/code&gt;）或不存在（&lt;code&gt;HeaderNotPresent&lt;/code&gt;）。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;var getUserMock = apitest.NewMock().
    Get(&amp;quot;http://example.com/user/12345&amp;quot;).
    HeaderPresent(&amp;quot;authtoken&amp;quot;).
    HeaderNotPresent(&amp;quot;requestid&amp;quot;).
    RespondWith().
    Body(`{&amp;quot;name&amp;quot;: &amp;quot;jon&amp;quot;}`).
    Status(http.StatusOK).
    End()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Query parameters&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过 &lt;code&gt;Query&lt;/code&gt;，您可以为 url 查询参数的键和值添加匹配器。正则表达式也可以作为值。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;var getUserMock = apitest.NewMock().
    Get(&amp;quot;http://example.com/user/12345&amp;quot;).
    Query(&amp;quot;page&amp;quot;, &amp;quot;1&amp;quot;).
    Query(&amp;quot;name&amp;quot;, &amp;quot;Jo([a-z]+)n&amp;quot;).
    QueryParams(map[string]string{&amp;quot;orderBy&amp;quot;: &amp;quot;ASC&amp;quot;}).
    RespondWith().
    Body(`{&amp;quot;name&amp;quot;: &amp;quot;jon&amp;quot;}`).
    Status(http.StatusOK).
    End()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;您还可以要求查询参数存在（&lt;code&gt;QueryPresent&lt;/code&gt;）或不存在（&lt;code&gt;QueryNotPresent&lt;/code&gt;）。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;var getUserMock = apitest.NewMock().
    Get(&amp;quot;http://example.com/user/12345&amp;quot;).
    QueryPresent(&amp;quot;page&amp;quot;).
    QueryNotPresent(&amp;quot;name&amp;quot;).
    RespondWith().
    Body(`{&amp;quot;name&amp;quot;: &amp;quot;jon&amp;quot;}`).
    Status(http.StatusOK).
    End()
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;53-standalone&#34;&gt;5.3. Standalone&lt;/h4&gt;
&lt;p&gt;通过使用 mock 生成器上的 &lt;code&gt;EndStandalone&lt;/code&gt; 终止方法，可以在 API 测试之外使用 mock。这对于在 API 测试之外测试 http 客户端非常有用。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;func TestMocks_Standalone(t *testing.T) {
    cli := http.Client{Timeout: 5}
    defer NewMock().
        Post(&amp;quot;http://localhost:8080/path&amp;quot;).
        Body(`{&amp;quot;a&amp;quot;, 12345}`).
        RespondWith().
        Status(http.StatusCreated).
        EndStandalone()()

    resp, err := cli.Post(&amp;quot;http://localhost:8080/path&amp;quot;,
        &amp;quot;application/json&amp;quot;,
        strings.NewReader(`{&amp;quot;a&amp;quot;, 12345}`))

    assert.NoError(t, err)
    assert.Equal(t, http.StatusCreated, resp.StatusCode)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;EndStandalone&lt;/code&gt; 会返回一个函数，在测试运行后调用该函数可将 http 传输重置为默认配置。&lt;/p&gt;
&lt;p&gt;如果想在一个测试中注册多个独立模拟，请使用 &lt;code&gt;apitest.NewStandaloneMocks()&lt;/code&gt; 工厂方法。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;resetTransport := apitest.NewStandaloneMocks(
    apitest.NewMock().
        Post(&amp;quot;http://localhost:8080/path&amp;quot;).
        Body(`{&amp;quot;a&amp;quot;: 12345}`).
        RespondWith().
        Status(http.StatusCreated).
        End(),
    apitest.NewMock().
        Get(&amp;quot;http://localhost:8080/path&amp;quot;).
        RespondWith().
        Body(`{&amp;quot;a&amp;quot;: 12345}`).
        Status(http.StatusOK).
        End(),
).End()
defer resetTransport()
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;6-integrations&#34;&gt;6. INTEGRATIONS&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;apitest&lt;/code&gt; 有许多注入点，因此很容易与其他第三方工具和测试库集成。&lt;/p&gt;
&lt;h4 id=&#34;61-ginkgo&#34;&gt;6.1. Ginkgo&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;apitest&lt;/code&gt; 通过接口接受 &lt;code&gt;*testing.T&lt;/code&gt;。这样就可以与其他测试库（如 Ginkgo）集成。您可以通过 &lt;a href=&#34;https://onsi.github.io/ginkgo/#using-other-matcher-libraries&#34;&gt;GinkgoT()&lt;/a&gt; 生成一个模仿 &lt;code&gt;*testing.T&lt;/code&gt; 的对象，并直接与 Ginkgo 通信。请参阅完整示例 &lt;a href=&#34;https://github.com/steinfletcher/apitest/tree/master/examples/ginkgo&#34;&gt;此处&lt;/a&gt;。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;var _ = Describe(&amp;quot;Ginkgo/Server&amp;quot;, func() {

    var (
        t      GinkgoTInterface
        router *mux.Router
    )

    BeforeEach(func() {
        t = GinkgoT()
        router = server.NewApp().Router
    })

    Context(&amp;quot;Successful CookieMatching&amp;quot;, func() {
        It(&amp;quot;cookies should be set correctly&amp;quot;, func() {
            apitest.New().
                Handler(router).
                Get(&amp;quot;/user/1234&amp;quot;).
                Expect(t).
                Cookies(apitest.NewCookie(&amp;quot;TomsFavouriteDrink&amp;quot;).
                    Value(&amp;quot;Beer&amp;quot;).
                    Path(&amp;quot;/&amp;quot;)).
                Status(http.StatusOK).
                End()
        })
    })
})
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;7-reports&#34;&gt;7. REPORTS&lt;/h3&gt;
&lt;p&gt;apitest 包含一种报告机制，可以生成序列图，说明入站请求、最终响应、与模拟的任何交互，甚至数据库查询。您甚至可以实现自己的 &#34;ReportFormatter &#34;来消费报告数据，从而生成自己的报告。&lt;/p&gt;
&lt;p&gt;报告支持的主要组成部分是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Event&lt;/strong&gt; 有两种类型的事件：HTTP 事件和自定义事件。HTTP 事件代表模拟交互、进入应用程序的请求和最终响应。自定义事件用于从任意来源生成数据。自定义事件包含标题和正文。我们在 apitest 中使用这种事件类型来记录数据库交互。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Recorder&lt;/strong&gt; 记录测试执行期间发生的事件，如模拟交互、数据库交互以及与被测应用程序的 HTTP 交互。如果输入自己的记录器，就可以添加自定义事件，然后通过实现 ReportFormatter 来处理这些事件。这对于记录从亚马逊 S3 客户端等来源生成的自定义事件可能很有用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ReportFormatter&lt;/strong&gt; 用户可用于生成自定义报告的接口。接收报告记录器，该记录器会暴露事件。SequenceDiagramFormatter 是 apitest 中包含的此接口的实现，可根据事件数据渲染 HTML 序列图。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;71-sequence-diagrams&#34;&gt;7.1. Sequence diagrams&lt;/h4&gt;
&lt;p&gt;配置报告程序以创建序列图，如下所示&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;apitest.New().
    Report(apitest.SequenceDiagram()).
    Handler(handler).
    Get(&amp;quot;/user&amp;quot;).
    Expect(t).
    Status(http.StatusOK).
    End()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这个 &lt;a href=&#34;https://github.com/steinfletcher/apitest/tree/master/examples/sequence-diagrams&#34;&gt;示例&lt;/a&gt; 中，我们实现了一个 REST API，并生成了一个与 http 交互的序列图。&lt;/p&gt;
&lt;p&gt;生成的下图说明了测试中协作者之间的交互。&lt;code&gt;sut&lt;/code&gt; 块是被测系统。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;sequence diagram report&#34; src=&#34;https://apitest.dev/static/images/seq-diagram.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;对于每次交互，请求/响应的 http 线表示法都会呈现在图表下方的事件日志中&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;sequence diagram report&#34; src=&#34;https://apitest.dev/static/images/seq-diag-log.png&#34; /&gt;&lt;/p&gt;
&lt;h3 id=&#34;8&#34;&gt;8. 例子&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;apitest&lt;/code&gt; 实例：&lt;code&gt;https://github.com/steinfletcher/apitest/tree/master/examples&lt;/code&gt;&lt;/p&gt;</description>  
      <pubDate>2025-10-09 17:54:40</pubDate>  
      <link>https://testpoo.github.io/go测试库apitest简介.html</link>  
      <guid isPermaLink="true">https://testpoo.github.io/go测试库apitest简介.html</guid>
       
      <category>测试</category> 
      
    </item>
    
    <item> 
      <title>go入门</title>  
      <description>&lt;div class=&#34;toc&#34;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1&#34;&gt;1. 简介&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2&#34;&gt;2. 开始&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3&#34;&gt;3. 工作区&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4&#34;&gt;4. 变量&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5&#34;&gt;5. 数据类型&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#51&#34;&gt;5.1 数字，字符串 和 布尔型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#52-arrays-slice-maps&#34;&gt;5.2 数组(Arrays), 切片(Slice) 和 映射(Maps)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#6&#34;&gt;6. 类型转换&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#7&#34;&gt;7. 条件语句&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#71-if-else&#34;&gt;7.1 if else&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#72-switch-case&#34;&gt;7.2 switch case&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#73&#34;&gt;7.3 循环&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#8&#34;&gt;8. 指针&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#9&#34;&gt;9. 函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#10&#34;&gt;10. 方法、结构体和接口&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#101-struct&#34;&gt;10.1 结构体(Struct)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#102-methods&#34;&gt;10.2 方法(Methods)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#103&#34;&gt;10.3 接口&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#11&#34;&gt;11. 包&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#111-go&#34;&gt;11.1 安装一个包go&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#112&#34;&gt;11.2 自定义包&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#113&#34;&gt;11.3 包的文档&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#12-go&#34;&gt;12. Go中的一些内置包&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#121-fmt&#34;&gt;12.1 fmt&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#122-json&#34;&gt;12.2 json&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#13&#34;&gt;13. 错误处理&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#131&#34;&gt;13.1 返回自定义错误&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#132-panic&#34;&gt;13.2 Panic&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#133-defer&#34;&gt;13.3 Defer&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#14&#34;&gt;14. 并发&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#141-go-routine&#34;&gt;14.1 Go routine&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#142-channels&#34;&gt;14.2 Channels&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#143-channel&#34;&gt;14.3 单向channel&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#144-selectgo-routinechannel&#34;&gt;14.4 使用select语句在Go routine中处理多个channel&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#145-buffered-channel&#34;&gt;14.5 Buffered channel&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#15-golang&#34;&gt;15. 为什么 Golang 能够成功呢？&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h3 id=&#34;1&#34;&gt;1. 简介&lt;/h3&gt;
&lt;p&gt;Go由Google工程师Robert Griesemer，Rob Pike和Ken Thompson设计。它是一种静态类型的编译语言。 2012 年 3 月发布了第一个开源版本。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Go 是一种开源编程语言，可以轻松构建简单、可靠和高效的软件”。— GoLang&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在很多计算机语言中，有很多方式可以去解决一个给定的问题。&lt;/p&gt;
&lt;p&gt;程序员花费大量的时间去思考最好的方式去解决它。&lt;/p&gt;
&lt;p&gt;而Go功能简洁，只有一种正确的方式去解决问题。&lt;/p&gt;
&lt;p&gt;这样可以节约程序员的时间，并且使大型代码库易于维护。&lt;/p&gt;
&lt;p&gt;Go里面没有像映射(maps)和过滤器(filters)这样富有表现力的特征。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“当你有增加表现力的功能时，它通常会增加成本”——罗伯·派克&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;2&#34;&gt;2. 开始&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;本文以windows为例，所以只安装windows下的 &lt;code&gt;go&lt;/code&gt;，下载地址为：&lt;code&gt;https://golang.google.cn/dl/go1.21.0.windows-amd64.msi&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Go 是由包组成的。 main 包告诉 Go 编译器，程序被编译为可执行文件，而不是共享库。它是应用程序的入口点。主包定义为：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;package main
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们先写一个简单的 &lt;code&gt;hello world&lt;/code&gt; 示例，方法就是在 Go GOPATH中创建 &lt;code&gt;main.go&lt;/code&gt; 文件。&lt;/p&gt;
&lt;h3 id=&#34;3&#34;&gt;3. 工作区&lt;/h3&gt;
&lt;p&gt;Go的工作区是由环境变量&lt;code&gt;GOPATH&lt;/code&gt;决定的。  &lt;/p&gt;
&lt;p&gt;你可以在工作区里写任意代码，Go会在&lt;code&gt;GOPATH&lt;/code&gt;或者&lt;code&gt;GOROOT&lt;/code&gt;目录下搜索包，这是在安装Go时默认设置的。&lt;code&gt;GOROOT&lt;/code&gt;是Go的安装路径。&lt;/p&gt;
&lt;p&gt;设置&lt;code&gt;GOPATH&lt;/code&gt;为你想要的目录。现在，咱们设置它的目录为 &lt;code&gt;~/workspace&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-shell&#34;&gt;# 环境变量
export GOPATH=~/workspace
# 进入工作区目录
cd ~/workspace
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上是在linux下设置的，但本次分享是在Windows下进行的，所以我们设置Windows下的环境变量，设置的目录为 &lt;code&gt;D:\learn\gocode&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-shell&#34;&gt;# 设置环境变量
go env GOPATH=D:\learn\gocode
# 恢复默认
go env -u GOPATH
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在工作区目录里创建&lt;code&gt;mian.go&lt;/code&gt;文件。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
 &amp;quot;fmt&amp;quot;
)

func main(){
  fmt.Println(&amp;quot;Hello World!&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在上面的例子中，&lt;code&gt;fmt&lt;/code&gt; 是Go中的内置包，主要用来格式化输入/输出。&lt;/p&gt;
&lt;p&gt;在 Go 中我们使用 &lt;code&gt;import&lt;/code&gt; 来导入一个包文件，&lt;code&gt;func main&lt;/code&gt;是执行代码的入口，&lt;code&gt;Println&lt;/code&gt; 是包fmt中的一个函数，它为我们打印 &lt;code&gt;“hello world”&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;让我们运行这个文件来看看。Go有两种运行方式。正如我们所知，Go 是一种编译语言，所以我们首先要在执行之前编译它。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-shell&#34;&gt;go build main.go
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个命令会生成二进制可执行文件 main，然后我们再运行它。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-shell&#34;&gt;main.exe
#Hello World!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还有另外一个简单的方法运行程序。&lt;code&gt;go run&lt;/code&gt;可以抽象编译步骤，你可以简单的使用下面的命令执行程序。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-shell&#34;&gt;go run main.go
# Hello World!
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;4&#34;&gt;4. 变量&lt;/h3&gt;
&lt;p&gt;Go中的变量是显式声明的。Go 是一种静态类型语言。这意味着在变量在声明时会检查变量的类型。变量可以像下面这样声明：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;var a int
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在本例中，该值默认设置为0。也可以直接指定变量的值，如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;var a = 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这里，变量被自动赋值为 &lt;code&gt;int&lt;/code&gt; 型。我们也可以对变量进行一个简短的声明，如下:&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;message := &amp;quot;hello world&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们也可以在一行声明多个变量，如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;var b, c int = 2, 3
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;5&#34;&gt;5. 数据类型&lt;/h3&gt;
&lt;p&gt;像其他一些计算机语言，Go 也支持各种不同的变量类型，如下：&lt;/p&gt;
&lt;h4 id=&#34;51&#34;&gt;5.1 数字，字符串 和 布尔型&lt;/h4&gt;
&lt;p&gt;Go 支持的数字存储类型有很多，比如 &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;int8&lt;/code&gt;, &lt;code&gt;int16&lt;/code&gt;, &lt;code&gt;int32&lt;/code&gt;, &lt;code&gt;int64&lt;/code&gt;,&lt;code&gt;uint&lt;/code&gt;, &lt;code&gt;uint8&lt;/code&gt;, &lt;code&gt;uint16&lt;/code&gt;, &lt;code&gt;uint32&lt;/code&gt;, &lt;code&gt;uint64&lt;/code&gt;, &lt;code&gt;uintptr&lt;/code&gt; 等等。&lt;/p&gt;
&lt;p&gt;字符串类型存储一个字节序列。使用关键字&lt;code&gt;string&lt;/code&gt;来表示和声明。&lt;/p&gt;
&lt;p&gt;布尔型使用&lt;code&gt;bool&lt;/code&gt;声明。&lt;/p&gt;
&lt;p&gt;Go 还支持复数类型的数据类型，可以使用&lt;code&gt;complex64&lt;/code&gt;和&lt;code&gt;complex128&lt;/code&gt;进行声明。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;var a bool = true
var b int = 1
var c string =&amp;quot;hello world&amp;quot;
var d float32 = 1.222
var x complex128 = cmplx.Sqrt(-5+12i)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;52-arrays-slice-maps&#34;&gt;5.2 数组(Arrays), 切片(Slice) 和 映射(Maps)&lt;/h4&gt;
&lt;p&gt;数组是具有相同数据类型的元素的序列。数组在声明时定义了固定长度，因此不能随意扩展超。如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;var s [5]int
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;数组也可以是多维的，声明方式如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;var multiD [2][3]int
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Go 中的数组有一定限制，比如不能修改数组长度、不能添加元素、不能获取子数组。这时候，更适合使用切片(slices)这一类型。&lt;/p&gt;
&lt;p&gt;切片(slices)用于存储一组元素，允许随时扩展其长度。切片(slices)的声明类似数组，只是去掉了长度声明。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;var b []int
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这行代码会创建一个 0容量、0长度的切片。也可以使用以下代码设置切片的容量和长度。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;numbers := make([]int,5,10)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里，切片的初始长度是5，容量是10。&lt;/p&gt;
&lt;p&gt;切片是数组的抽象。切片使用数组作为底层结构。切片包含三个组成部分:容量、长度和指向底层数组的指针。&lt;/p&gt;
&lt;p&gt;切片的容量可以通过&lt;code&gt;append&lt;/code&gt;或&lt;code&gt;copy&lt;/code&gt;函数来增加。&lt;code&gt;append&lt;/code&gt; 函数将值添加到数组的末尾，并在需要时增加容量。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;numbers = append(numbers, 1, 2, 3, 4)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另一个增加切片容量的方法是&lt;code&gt;copy&lt;/code&gt;函数。只需创建另一个容量更大的片，并将原始片复制到新创建的片：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;// 创建一个新的大容量的切片
number2 := make([]int, 15)
// 把原来的切片复制到新切片
copy(number2, numbers)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以创建一个切片的子切片吗？这个可以用如下简单的代码来完成：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;// 初始化一个长度为4并有值的切片
number2 = []int{1,2,3,4}
fmt.Println(number2) // -&amp;gt; [1 2 3 4]
// 创建一个子切片
slice1 := number2[2:]
fmt.Println(slice1) // -&amp;gt; [3 4]
slice2 := number2[:3]
fmt.Println(slice2) // -&amp;gt; [1 2 3]
slice3 := number2[1:4]
fmt.Println(slice3) // -&amp;gt; [2 3 4]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Maps也是Go的一个数据类型，用于记录键值间的映射关系。我们可以用下面的命令定义一个 &lt;code&gt;map&lt;/code&gt; :&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;var m map[string]int
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里 &lt;code&gt;m&lt;/code&gt;是一个新的 &lt;code&gt;map&lt;/code&gt;变量，它有字符型的主键和整型的值，我们可以很容易的给 &lt;code&gt;map&lt;/code&gt; 加主键和值：&lt;/p&gt;
&lt;h3 id=&#34;6&#34;&gt;6. 类型转换&lt;/h3&gt;
&lt;p&gt;可以使用类型转换将一种数据类型转换为另一种数据类型。我们来看一个简单的类型转换:&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;a := 1.1
b := int(a)
fmt.Println(b)
//-&amp;gt; 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;并非所有的数据类型都能转换成其他类型。确保数据类型与转换类型相互兼容。&lt;/p&gt;
&lt;h3 id=&#34;7&#34;&gt;7. 条件语句&lt;/h3&gt;
&lt;h4 id=&#34;71-if-else&#34;&gt;7.1 if else&lt;/h4&gt;
&lt;p&gt;对于条件语句，我们可以使用if-else语句，如下例所示。确保花括号与条件在同一行。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;if num := 9; num &amp;lt; 0 {
 fmt.Println(num, &amp;quot;is negative&amp;quot;)
} else if num &amp;lt; 10 {
 fmt.Println(num, &amp;quot;has 1 digit&amp;quot;)
} else {
 fmt.Println(num, &amp;quot;has multiple digits&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;72-switch-case&#34;&gt;7.2 switch case&lt;/h4&gt;
&lt;p&gt;switch-case用于组织多个条件语句，下面的例子展示了一个简单的switch case语句:&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;i := 2
switch i {
case 1:
 fmt.Println(&amp;quot;one&amp;quot;)
case 2:
 fmt.Println(&amp;quot;two&amp;quot;)
default:
 fmt.Println(&amp;quot;none&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;73&#34;&gt;7.3 循环&lt;/h4&gt;
&lt;p&gt;Go的循环只有一个关键字。&lt;code&gt;for&lt;/code&gt; 循环命令可以帮助实现不同类型的循环:&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;i := 0
sum := 0
for i &amp;lt; 10 {
 sum += 1
  i++
}
fmt.Println(sum)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上代码类似于C语言中的&lt;code&gt;while&lt;/code&gt;循环。相同的语句可以用在普通的 &lt;code&gt;for&lt;/code&gt; 循环：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;sum := 0
for i := 0; i &amp;lt; 10; i++ {
  sum += i
}
fmt.Println(sum)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Go中的死循环&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;for {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;8&#34;&gt;8. 指针&lt;/h3&gt;
&lt;p&gt;Go 提供了指针。指针是保存值的地址的地方。指针由 &lt;code&gt;*&lt;/code&gt; 定义。指针是根据数据类型来定义的。如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;var ap *int
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里&lt;code&gt;ap&lt;/code&gt;是指向整型的指针。&lt;code&gt;&amp;amp;&lt;/code&gt; 操作符用于获取变量的地址。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;a := 12
ap = &amp;amp;a
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;指针所指向的值可以使用 &lt;code&gt;*&lt;/code&gt; 操作符访问:&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;fmt.Println(*ap)
// =&amp;gt; 12
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在将结构体作为参数传递或为已定义的类型声明方法时，通常首选指针。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当传递值时，值实际上被复制，这意味着更多的内存。&lt;/li&gt;
&lt;li&gt;传递指针后，方法/函数可以直接修改指针所指向的值。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;比如：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;func increment(i *int) {
  *i++
}
func main() {
  i := 10
  increment(&amp;amp;i)
  fmt.Println(i)
}
//=&amp;gt; 11
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意：不要忘记在需要的时候写上package main和import fmt或其他包&lt;/p&gt;
&lt;h3 id=&#34;9&#34;&gt;9. 函数&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;main&lt;/code&gt;包中定义的&lt;code&gt;main&lt;/code&gt;函数是go程序执行的入口，我们还可以定义和使用更多其他函数。先来看个例子吧：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;func add(a int, b int) int {
 c := a + b
 return c
}
func main() {
 fmt.Println(add(2, 1))
}
//=&amp;gt; 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如上所示，一个 Go 函数是用 &lt;code&gt;func&lt;/code&gt; 关键字和函数名定义的。函数接受的参数需要根据它的数据类型来定义，最后是返回的数据类型。&lt;/p&gt;
&lt;p&gt;函数的返回值也可以在函数中提前定义：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;func add(a int, b int) (c int) {
  c = a + b
  return
}
func main() {
  fmt.Println(add(2, 1))
}
//=&amp;gt; 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里 &lt;code&gt;c&lt;/code&gt; 被定义为返回变量。因此，定义的变量 &lt;code&gt;c&lt;/code&gt; 将自动返回，而不需要在最后的返回语句中定义。&lt;/p&gt;
&lt;p&gt;您也可以从单个函数返回多个返回值，返回值之间用逗号分隔。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;func add(a int, b int) (int, string) {
  c := a + b
  return c, &amp;quot;successfully added&amp;quot;
}
func main() {
  sum, message := add(2, 1)
  fmt.Println(message)
  fmt.Println(sum)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;10&#34;&gt;10. 方法、结构体和接口&lt;/h3&gt;
&lt;p&gt;Go 并不是一种完全面向对象的语言，但是通过结构、接口和方法，让它有了很多面向对象的支持和效果。&lt;/p&gt;
&lt;h4 id=&#34;101-struct&#34;&gt;10.1 结构体(Struct)&lt;/h4&gt;
&lt;p&gt;结构体包含不同类型的字段，可用来对数据进行分组。例如，如果我们要对Person类型的数据进行分组，那么可以定义一个人的各种属性，包括姓名，年龄，性别等。&lt;/p&gt;
&lt;p&gt;结构体是不同字段的类型化集合。结构体用于将数据进行分组。例如，如果我们想对Person类型的数据进行分组，我们定义一个人的属性，该属性包括姓名、年龄、性别。结构体可以使用以下语法定义:&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;type person struct {
  name string
  age int
  gender string
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Person类型定义后，现在我们来创建一个 Person对象:&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;//方法 1: 指定参数和值
p := person{name: &amp;quot;Bob&amp;quot;, age: 42, gender: &amp;quot;Male&amp;quot;}
//方法 2: 仅指定值
person{&amp;quot;Bob&amp;quot;, 42, &amp;quot;Male&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以容易的使用&lt;code&gt;.&lt;/code&gt;来获取一个对象的参数。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;p.name
//=&amp;gt; Bob
p.age
//=&amp;gt; 42
p.gender
//=&amp;gt; Male
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你也可以通过结构体的指针对象来获取参数。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;pp := &amp;amp;person{name: &amp;quot;Bob&amp;quot;, age: 42, gender: &amp;quot;Male&amp;quot;}
pp.name
//=&amp;gt; Bob
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;102-methods&#34;&gt;10.2 方法(Methods)&lt;/h4&gt;
&lt;p&gt;方法是一种带有接收器的特殊函数。一个接收器可以是一个值或指针。我们可以创建一个叫 &lt;code&gt;describe&lt;/code&gt; 的方法作为刚刚创建的Person类型的接收器，如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;package main
import &amp;quot;fmt&amp;quot;

// 定义结构体
type person struct {
  name   string
  age    int
  gender string
}

// 定义方法
func (p *person) describe() {
  fmt.Printf(&amp;quot;%v is %v years old.&amp;quot;, p.name, p.age)
}
func (p *person) setAge(age int) {
  p.age = age
}

func (p person) setName(name string) {
  p.name = name
}

func main() {
  pp := &amp;amp;person{name: &amp;quot;Bob&amp;quot;, age: 42, gender: &amp;quot;Male&amp;quot;}
  pp.describe()
  // =&amp;gt; Bob is 42 years old
  pp.setAge(45)
  fmt.Println(pp.age)
  //=&amp;gt; 45
  pp.setName(&amp;quot;Hari&amp;quot;)
  fmt.Println(pp.name)
  //=&amp;gt; Bob
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;正如我们在上面的例子中看到的那样，现在可以使用点操作符pp.describe来调用该方法。注意，接收器是一个指针。有了指针，我们传递了一个值的引用，所以如果我们在方法中做了任何改变，它将反映在接收器pp中。它也不会创建对象的新副本，这节省了内存。&lt;/p&gt;
&lt;p&gt;注意，在上面的例子中，&lt;code&gt;age&lt;/code&gt; 的值被改变了，而 &lt;code&gt;name&lt;/code&gt; 的值没有改变，因为 &lt;code&gt;setName&lt;/code&gt;是接收者类型，而 &lt;code&gt;setAge&lt;/code&gt; 是指针类型。&lt;/p&gt;
&lt;h4 id=&#34;103&#34;&gt;10.3 接口&lt;/h4&gt;
&lt;p&gt;在 Go 中，接口是方法的集合。接口可以对一个类型的属性进行分组，我们以动物为例，比如：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;type animal interface {
  description() string
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里&lt;code&gt;animal&lt;/code&gt;是一个接口。现在让我们来创建两种不同类型的动物来实现&lt;code&gt;animal&lt;/code&gt;接口。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
  &amp;quot;fmt&amp;quot;
)

type animal interface {
  description() string
}

type cat struct {
  Type  string
  Sound string
}

type snake struct {
  Type      string
  Poisonous bool
}

func (s snake) description() string {
  return fmt.Sprintf(&amp;quot;Poisonous: %v&amp;quot;, s.Poisonous)
}

func (c cat) description() string {
  return fmt.Sprintf(&amp;quot;Sound: %v&amp;quot;, c.Sound)
}

func main() {
  var a animal
  a = snake{Poisonous: true}
  fmt.Println(a.description())
  a = cat{Sound: &amp;quot;Meow!!!&amp;quot;}
  fmt.Println(a.description())
}

//=&amp;gt; Poisonous: true
//=&amp;gt; Sound: Meow!!!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在main函数中，我们创建了 一个类型为 &lt;code&gt;animal&lt;/code&gt;的变量 &lt;code&gt;a&lt;/code&gt;，然后把蛇和猫分配给类型 &lt;code&gt;animal&lt;/code&gt; ，并且打印&lt;code&gt;a.description&lt;/code&gt;。因此我们用两种类型(猫和蛇)以不同的方式实现了方法，最后我们得到了关于动物类型的描述。&lt;/p&gt;
&lt;h3 id=&#34;11&#34;&gt;11. 包&lt;/h3&gt;
&lt;p&gt;在 Go 中，所有的代码都写在包里面。&lt;code&gt;main&lt;/code&gt;包是程序执行的入口，Go 自带了很多内置包，最有名的就是刚刚用过的&lt;code&gt;fmt&lt;/code&gt;包。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“Go packages in the main mechanism for programming in the large that go provides and they make possible to divvy up a large project into smaller pieces.”&lt;br /&gt;
— Robert Griesemer&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;翻译不出来，感觉大意就是 Go 包是 Go 的特色，可以把大型项目分成很多个小包，好维护。&lt;/p&gt;
&lt;h4 id=&#34;111-go&#34;&gt;11.1 安装一个包go&lt;/h4&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;go get &amp;lt;package-url-github&amp;gt;
// 举个例子
go get github.com/satori/go.uuid
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;包默认安装在&lt;code&gt;GOPATH&lt;/code&gt;环境变量设置的工作区中。可以使用&lt;code&gt;cd $GOPATH/pkg&lt;/code&gt;命令进入目录，查看已安装的包。windows下是&lt;code&gt;cd %GOPATH%\pkg&lt;/code&gt;，目前这个&lt;code&gt;GOPATH&lt;/code&gt;还是在win下不好用。&lt;/p&gt;
&lt;h4 id=&#34;112&#34;&gt;11.2 自定义包&lt;/h4&gt;
&lt;p&gt;首先在 &lt;code&gt;$GOPATH\src&lt;/code&gt;目录下创建一个&lt;code&gt;custom_package&lt;/code&gt;文件夹&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-shell&#34;&gt;mkdir custom_package
cd custom_package
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;要创建自定义包，我们首先要创建一个包含所需包名的文件夹，那我们就创建刚刚提到的&lt;code&gt;person&lt;/code&gt;包，即在&lt;code&gt;custom_package&lt;/code&gt;目录下创建一个&lt;code&gt;person&lt;/code&gt;文件夹，如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-shell&#34;&gt;mkdir person
cd person
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后在 &lt;code&gt;person&lt;/code&gt; 文件夹下创建一个 &lt;code&gt;person.go&lt;/code&gt;文件&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;package person
func Description(name string) string {
  return &amp;quot;The person name is: &amp;quot; + name
}
func secretName(name string) string {
  return &amp;quot;Do not share&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在我们需要安装这个包，以便引入并使用它。现在我们来安装它，如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;&amp;gt; go install person
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后我们回到&lt;code&gt;main&lt;/code&gt;目录下，创建一个&lt;code&gt;20.go&lt;/code&gt;文件。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;package main
import(
  &amp;quot;custom_package/person&amp;quot;
  &amp;quot;fmt&amp;quot;
)
func main(){ 
  p := person.Description(&amp;quot;Milap&amp;quot;)
  fmt.Println(p)
}
// =&amp;gt; The person name is: Milap
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在，我们可以导入我们创建的包 &lt;code&gt;person&lt;/code&gt; 并使用 &lt;code&gt;Description&lt;/code&gt; 函数了。注意，我们在包中创建的函数 &lt;code&gt;secretName&lt;/code&gt; 将不可访问。在 Go 中，不是大写字母开头的方法名是私有的。&lt;/p&gt;
&lt;h4 id=&#34;113&#34;&gt;11.3 包的文档&lt;/h4&gt;
&lt;p&gt;下载 &lt;code&gt;godoc&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-shell&#34;&gt;go env -w GO111MODULE=on
go env -w GOPROXY=https://goproxy.cn,direct
go get golang.org/x/tools/cmd/godoc

go: downloading golang.org/x/tools v0.12.0
go: downloading golang.org/x/sys v0.11.0
go: downloading github.com/yuin/goldmark v1.4.13
go: downloading golang.org/x/mod v0.12.0
go: downloading github.com/yuin/goldmark v1.5.5
go: trying upgrade to github.com/yuin/goldmark@v1.5.5
go: added github.com/yuin/goldmark v1.5.5
go: added golang.org/x/mod v0.12.0
go: added golang.org/x/sys v0.11.0
go: added golang.org/x/tools v0.12.0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Go 内置了对包文档。运行以下命令生成文档:&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;go doc person Description

// 结果
package person // import &amp;quot;custom_package/person&amp;quot;

func Description(name string) string
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这将为包 &lt;code&gt;person&lt;/code&gt; 中的 &lt;code&gt;Description&lt;/code&gt; 函数生成文档。要查看文档，使用以下命令运行web服务器:&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-shell&#34;&gt;godoc -http=&amp;quot;:8080&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;打开这个链接 &lt;a href=&#34;http://localhost:8080/pkg&#34;&gt;http://localhost:8080/pkg&lt;/a&gt;，就能看到文档了。&lt;/p&gt;
&lt;h3 id=&#34;12-go&#34;&gt;12. Go中的一些内置包&lt;/h3&gt;
&lt;h4 id=&#34;121-fmt&#34;&gt;12.1 fmt&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;fmt&lt;/code&gt;包实现了格式化输入输出的功能。我们已经使用过这个包进行标准输出了。&lt;/p&gt;
&lt;h4 id=&#34;122-json&#34;&gt;12.2 json&lt;/h4&gt;
&lt;p&gt;Go 中另外一个很有用的包是&lt;code&gt;json&lt;/code&gt;，它用来编码/解码&lt;code&gt;Json&lt;/code&gt;数据。我们来看一些邓编码/解码的例子：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;// 编码
package main

import (
  &amp;quot;fmt&amp;quot;
  &amp;quot;encoding/json&amp;quot;
)

func main(){
  mapA := map[string]int{&amp;quot;apple&amp;quot;: 5, &amp;quot;lettuce&amp;quot;: 7}
  mapB, _ := json.Marshal(mapA)
  fmt.Println(string(mapB))
}
// 解码
package main

import (
  &amp;quot;fmt&amp;quot;
  &amp;quot;encoding/json&amp;quot;
)

type response struct {
  PageNumber int `json:&amp;quot;page&amp;quot;`
  Fruits []string `json:&amp;quot;fruits&amp;quot;`
}

func main(){
  str := `{&amp;quot;page&amp;quot;: 1, &amp;quot;fruits&amp;quot;: [&amp;quot;apple&amp;quot;, &amp;quot;peach&amp;quot;]}`
  res := response{}
  json.Unmarshal([]byte(str), &amp;amp;res)
  fmt.Println(res.PageNumber)
}
//=&amp;gt; 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当使用&lt;code&gt;Unmarshal&lt;/code&gt;解码json字节时，第一个参数是json字节，第二个参数是我们期望的解码后的结构体指针。注意：&lt;code&gt;json:&#34;page&#34;&lt;/code&gt;负责把&lt;code&gt;page&lt;/code&gt;映射到结构体中的&lt;code&gt;PageNumber&lt;/code&gt;键上。&lt;/p&gt;
&lt;h3 id=&#34;13&#34;&gt;13. 错误处理&lt;/h3&gt;
&lt;p&gt;错误是程序不希望出现的和意想不到的结果。假设我们正在对外部服务进行API调用。此API调用可能成功，也可能失败。当出现错误类型时，可以识别出程序中的错误。我们来看看这个例子:&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;resp, err := http.Get(&amp;quot;http://example.com/&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这里，对错误对象的API调用可能通过，也可能失败。我们可以检查错误是否为nil或者存在错误，并正确地处理响应：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
  &amp;quot;fmt&amp;quot;
  &amp;quot;net/http&amp;quot;
)

func main(){
  resp, err := http.Get(&amp;quot;http://example.com/&amp;quot;)
  if err != nil {
    fmt.Println(err)
    return
  }
  fmt.Println(resp)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;131&#34;&gt;13.1 返回自定义错误&lt;/h4&gt;
&lt;p&gt;在写函数时，我们可能会遇到需要报错的情景，这时可以返回一个自定义的&lt;code&gt;error&lt;/code&gt;对象。&lt;/p&gt;
&lt;p&gt;当我们编写自己的函数时，有时会出现错误。这些错误可以自定义一个 &lt;code&gt;error&lt;/code&gt; 对象返回：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;func Increment(n int) (int, error) {
  if n &amp;lt; 0 {
    // return error object
    return 0, errors.New(&amp;quot;math: cannot process negative number&amp;quot;)
  }
  return (n + 1), nil
}
func main() {
  num := 5

  if inc, err := Increment(num); err != nil {
    fmt.Printf(&amp;quot;Failed Number: %v, error message: %v&amp;quot;, num, err)
  }else {
    fmt.Printf(&amp;quot;Incremented Number: %v&amp;quot;, inc)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Go 内置的大多数包，或者我们使用的外部包，都有错误处理机制。所以我们调用的任何函数都可能有错误。这些错误永远不会被忽略，并且总是在调用时总能被很好地处理，就像我们在上面的例子中所做的那样。&lt;/p&gt;
&lt;h4 id=&#34;132-panic&#34;&gt;13.2 Panic&lt;/h4&gt;
&lt;p&gt;Panic是指在程序执行过程中突然遇到的无法处理的问题。在Go中，panic不是处理程序异常的理想方式。建议使用error对象。当出现panic时，程序会停止运行，但会运行&lt;code&gt;defer&lt;/code&gt;语句代码。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;//Go
package main

import &amp;quot;fmt&amp;quot;

func main() {
    f()
    fmt.Println(&amp;quot;Returned normally from f.&amp;quot;)
}

func f() {
    defer func() {
        if r := recover(); r != nil {
            fmt.Println(&amp;quot;Recovered in f&amp;quot;, r)
        }
    }()
    fmt.Println(&amp;quot;Calling g.&amp;quot;)
    g(0)
    fmt.Println(&amp;quot;Returned normally from g.&amp;quot;)
}

func g(i int) {
    if i &amp;gt; 3 {
        fmt.Println(&amp;quot;Panicking!&amp;quot;)
        panic(fmt.Sprintf(&amp;quot;%v&amp;quot;, i))
    }
    defer fmt.Println(&amp;quot;Defer in g&amp;quot;, i)
    fmt.Println(&amp;quot;Printing in g&amp;quot;, i)
    g(i + 1)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;133-defer&#34;&gt;13.3 Defer&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;Defer&lt;/code&gt; 总是在函数结束时执行。&lt;/p&gt;
&lt;p&gt;在上面的例子中，我们使用panic()来执行panic。如你所注见，有一个总是需要在函数结束执行后执行的defer语句。当我们需要在函数末尾执行某些操作时，例如关闭文件，就可以使用Defer。&lt;/p&gt;
&lt;h3 id=&#34;14&#34;&gt;14. 并发&lt;/h3&gt;
&lt;p&gt;Go 在设计时就考虑了并发性。 Go 中的并发可以通过轻量级线程&lt;code&gt;Go routines&lt;/code&gt;来实现。&lt;/p&gt;
&lt;h4 id=&#34;141-go-routine&#34;&gt;14.1 Go routine&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;Go routine&lt;/code&gt;是可以与另一个函数并行或并发运行的函数。创建一个&lt;code&gt;Go routine&lt;/code&gt;非常简单。只需在函数前面添加关键字Go，就可以使其并行执行。&lt;code&gt;Go routine&lt;/code&gt;非常轻量级，因此我们可以创建数千个&lt;code&gt;routine&lt;/code&gt;。让我们来看一个简单的例子:&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;package main
import (
  &amp;quot;fmt&amp;quot;
  &amp;quot;time&amp;quot;
)
func main() {
  go c()
  fmt.Println(&amp;quot;I am main&amp;quot;)
  time.Sleep(time.Second * 2)
}
func c() {
  time.Sleep(time.Second * 2)
  fmt.Println(&amp;quot;I am concurrent&amp;quot;)
}
//=&amp;gt; I am main
//=&amp;gt; I am concurrent
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;正如你在上面的例子中看到的，函数c是一个与Go主线程并行执行的 &lt;code&gt;Go routine&lt;/code&gt;。有时我们希望在多个线程之间共享资源。Go不喜欢与另一个线程共享一个线程的变量，因为这会增加死锁和资源等待的机会。还有另一种方法可以在 &lt;code&gt;Go routine&lt;/code&gt; 之间共享资源：那就是 &lt;code&gt;go channels&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id=&#34;142-channels&#34;&gt;14.2 Channels&lt;/h4&gt;
&lt;p&gt;我们可以使用通道在两个 &lt;code&gt;Go routine&lt;/code&gt; 之间传递数据。在创建通道时，有必要指定通道接收的数据类型。让我们创建一个字符串类型的通道，如下所示:&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;c := make(chan string)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有了这个通道，我们可以发送字符串类型的数据。我们可以在这个通道中发送和接收数据:&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func main(){
  c := make(chan string)
  go func(){ c &amp;lt;- &amp;quot;hello&amp;quot; }()
  msg := &amp;lt;-c
  fmt.Println(msg)
}
//=&amp;gt;&amp;quot;hello&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接收方&lt;code&gt;channel&lt;/code&gt;会一直等待，直到发送方将数据发数据到&lt;code&gt;channel&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id=&#34;143-channel&#34;&gt;14.3 单向channel&lt;/h4&gt;
&lt;p&gt;在某些情况下，我们希望 &lt;code&gt;Go routine&lt;/code&gt; 通过通道接收数据但不发送数据，反之亦然。为此，我们还可以创建一个单向通道。让我们来看一个简单的例子:&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
 &amp;quot;fmt&amp;quot;
)

func main() {
 ch := make(chan string)

 go sc(ch)
 fmt.Println(&amp;lt;-ch)
}

func sc(ch chan&amp;lt;- string) {
 ch &amp;lt;- &amp;quot;hello&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在上面的例子中，sc是一个 &lt;code&gt;Go routine&lt;/code&gt; 例程，它只能向通道发送消息，但不能接收消息。&lt;/p&gt;
&lt;h4 id=&#34;144-selectgo-routinechannel&#34;&gt;14.4 使用&lt;code&gt;select&lt;/code&gt;语句在&lt;code&gt;Go routine&lt;/code&gt;中处理多个&lt;code&gt;channel&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;一个函数可能正在等待多个通道。这时，我们可以使用&lt;code&gt;select&lt;/code&gt;语句。让我们看一个更清楚的例子：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
 &amp;quot;fmt&amp;quot;
 &amp;quot;time&amp;quot;
)

func main() {
 c1 := make(chan string)
 c2 := make(chan string)
 go speed1(c1)
 go speed2(c2)
 fmt.Println(&amp;quot;Th first to arrive is:&amp;quot;)
 select {
 case s1 := &amp;lt;-c1:
  fmt.Println(s1)
 case s2 := &amp;lt;-c2:
  fmt.Println(s2)
 }
}

func speed1(ch chan string) {
 time.Sleep(2 * time.Second)
 ch &amp;lt;- &amp;quot;speed 1&amp;quot;
}

func speed2(ch chan string) {
 time.Sleep(1 * time.Second)
 ch &amp;lt;- &amp;quot;speed 2&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在上面的示例中，主进程正在等待两个通道c1和c2。对于主函数打印的select case语句，消息从第一个接收到的通道发送。&lt;/p&gt;
&lt;h4 id=&#34;145-buffered-channel&#34;&gt;14.5 Buffered channel&lt;/h4&gt;
&lt;p&gt;您可以在go中创建缓冲通道。对于缓冲通道，如果缓冲区已满，则发送到该通道的消息将被阻塞。让我们来看看这个例子：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func main(){
  ch := make(chan string, 2)
  ch &amp;lt;- &amp;quot;hello&amp;quot;
  ch &amp;lt;- &amp;quot;world&amp;quot;
  ch &amp;lt;- &amp;quot;!&amp;quot; // extra message in buffer
  fmt.Println(&amp;lt;-ch)
}

// =&amp;gt; fatal error: all goroutines are asleep - deadlock!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;正如我们在上面看到的，一个通道不能接受超过2个消息。&lt;/p&gt;
&lt;h3 id=&#34;15-golang&#34;&gt;15. 为什么 &lt;code&gt;Golang&lt;/code&gt; 能够成功呢？&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Simplicity… — Rob-pike  &lt;/p&gt;
&lt;p&gt;因为简单...&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;好了，我们今天学习了Go的一些主要组件和特性。希望大家能有一些收获吧~！&lt;/p&gt;</description>  
      <pubDate>2025-10-09 17:54:40</pubDate>  
      <link>https://testpoo.github.io/go入门.html</link>  
      <guid isPermaLink="true">https://testpoo.github.io/go入门.html</guid>
       
      <category>技术</category> 
      
    </item>
    
    <item> 
      <title>Arch手动安装过程</title>  
      <description>&lt;div class=&#34;toc&#34;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1&#34;&gt;1.连接网络&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2&#34;&gt;2.更新系统时间&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3&#34;&gt;3.建立硬盘分区&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4&#34;&gt;4.格式化分区&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5&#34;&gt;5.挂载分区&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#6&#34;&gt;6.安装必需的软件包&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#7&#34;&gt;7.配置系统&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#8&#34;&gt;8.本地化&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#9&#34;&gt;9.网络配置&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#10root&#34;&gt;10.修改root密码&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#11&#34;&gt;11.安装引导程序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#12&#34;&gt;12.创建用户&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#6-wm&#34;&gt;6. 安装桌面/WM&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#61-openbox&#34;&gt;6.1 安装openbox&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#62-deepin&#34;&gt;6.2 安装deepin&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#63-xfce4&#34;&gt;6.3 安装xfce4&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#7_1&#34;&gt;7 网络问题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#8-nm&#34;&gt;8. nm连接网络命令&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h3 id=&#34;1&#34;&gt;1.连接网络&lt;/h3&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;#iwctl
[iwd]# device list
[iwd]# station [device] scan
[iwd]# station [device] get-networks
[iwd]# station [device] connect [SSID]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2&#34;&gt;2.更新系统时间&lt;/h3&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;# timedatectl set-ntp true 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;3&#34;&gt;3.建立硬盘分区&lt;/h3&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;# fdisk -l
# cfdisk /dev/sda
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;4&#34;&gt;4.格式化分区&lt;/h3&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;# mkfs.fat -F 32 /dev/sda1   --boot分区
# mkfs.ext4 /dev/sda2  --根分区
# mkswap /dev/sda3  --交换空间分区
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;5&#34;&gt;5.挂载分区&lt;/h3&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;mount /dev/sda2 /mnt
mkdir /mnt/boot
mount /dev/sda1 /mnt/boot
swapon /dev/sda3
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;6&#34;&gt;6.安装必需的软件包&lt;/h3&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;# 换源：reflector -c China -a 6 --sort rate --save /etc/pacman.d/mirrorlist
# 检查硬盘：lsblk
# 安装系统：pacstrap /mnt base linux linux-firmware
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;7&#34;&gt;7.配置系统&lt;/h3&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;# 生成 fstab 文件: genfstab -U /mnt &amp;gt;&amp;gt; /mnt/etc/fstab
# 切换到新系统: arch-chroot /mnt
# 修改时区: ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime
# 时间同步: hwclock --systohc
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;8&#34;&gt;8.本地化&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;编辑 /etc/locale.gen，然后取消掉 en_US.UTF-8 UTF-8, zh_CN.UTF-8 UTF-8前面的&lt;code&gt;#&lt;/code&gt;号&lt;/li&gt;
&lt;li&gt;然后执行 &lt;code&gt;locale-gen&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;然后创建/etc/locale.conf,添加LANG=en_US.UTF-8,中文需要zh_CN.UTF-8&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;9&#34;&gt;9.网络配置&lt;/h3&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;# /etc/hosts添加以下内容
/etc/hostname  arch
/etc/hosts
127.0.0.1 localhost
::1       localhost
127.0.0.1 arch.localdomain arch
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;10root&#34;&gt;10.修改root密码&lt;/h3&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;# passwd
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;11&#34;&gt;11.安装引导程序&lt;/h3&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;# pacman -S grub efibootmgr
# grub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=GRUB
# grub-mkconfig -o /boot/grub/grub.cfg
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;12&#34;&gt;12.创建用户&lt;/h3&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;# useradd -m -G wheel poo
# useradd poo
# passwd poo
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;6-wm&#34;&gt;6. 安装桌面/WM&lt;/h3&gt;
&lt;h4 id=&#34;61-openbox&#34;&gt;6.1 安装openbox&lt;/h4&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;pacman -S xorg-xinit install openbox obconf tint2 sakura pcmanfm ristretto fcitx-rime librime-data-wubi lxappearance xarchiver pulseaudio blueman sudo git intel-microcode fonts-noto-cjk slock light jgmenu chromium chromium-l10n webext-ublock-origin-chromium
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;62-deepin&#34;&gt;6.2 安装deepin&lt;/h4&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;pacman -S xorg-server lightdm networkmanager deepin deepin-extra
systemctl enable lightdm
systemctl enable NetworkManager
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;63-xfce4&#34;&gt;6.3 安装xfce4&lt;/h4&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;pacman -S xfce4 xfce4-goodies nano sudo lightdm lightdm-gtk-greeter networkmanager xf86-video-intel network-manager-applet alsa-utils pulseaudio pulseaudio-alsa pavucontrol

声音问题
sudo pacman -S alsa-utils
sudo pacman -S pulseaudio
sudo pacman -S pulseaudio-alsa
sudo pacman -S pavucontrol      #与xfce4 panel里面的插件配合使用,必须要有这个进程
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;7_1&#34;&gt;7 网络问题&lt;/h3&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;# 安装nm: pacman -S networkmanager
# 安装nm图形界面: nm-connection-editor
# 安装nm系统托盘图标: network-manager-applet（nm-applet）
# 开机启动nm: systemctl enable NetworkManager
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;8-nm&#34;&gt;8. nm连接网络命令&lt;/h3&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;nmcli 示例
显示附近的 Wi-Fi 网络：

$ nmcli device wifi list
连接到 Wi-Fi 网络：

$ nmcli device wifi connect SSID_或_BSSID password 密码
连接到隐藏的 Wi-Fi 网络：

$ nmcli device wifi connect SSID_或_BSSID password 密码 hidden yes
连接到 wlan1 网络接口上的 Wi-Fi：

$ nmcli device wifi connect SSID_或_BSSID password 密码 ifname wlan1 profile_name
断开网络接口上的连接：

$ nmcli device disconnect ifname eth0
显示连接列表及其名称、UUID、类型和支持设备：

$ nmcli connection show
激活连接（即使用现有配置文件连接到网络）：

$ nmcli connection up name_或_uuid
删除连接：

$ nmcli connection delete name_或_uuid
显示所有网络设备及其状态：

$ nmcli device
关闭 Wi-Fi：

$ nmcli radio wifi off
&lt;/code&gt;&lt;/pre&gt;</description>  
      <pubDate>2025-10-09 17:54:40</pubDate>  
      <link>https://testpoo.github.io/Arch手动安装过程.html</link>  
      <guid isPermaLink="true">https://testpoo.github.io/Arch手动安装过程.html</guid>
       
      <category>系统安装</category> 
      
    </item>
    
    <item> 
      <title>BeautifulSoup简介</title>  
      <description>&lt;div class=&#34;toc&#34;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-beautiful-soup&#34;&gt;1. Beautiful Soup简介&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#11&#34;&gt;1.1 举个例子&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-beautiful-soup&#34;&gt;2. 安装 Beautiful Soup&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3&#34;&gt;3. 安装解析器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4&#34;&gt;4. 使用方法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5&#34;&gt;5. 对象的种类&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#51-tag&#34;&gt;5.1 Tag&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#52&#34;&gt;5.2 可遍历的字符串&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#53-beautifulsoup&#34;&gt;5.3 BeautifulSoup&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#54&#34;&gt;5.4 注释及特殊字符串&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#6&#34;&gt;6. 遍历方法&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#61&#34;&gt;6.1 子节点&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#62&#34;&gt;6.2 父节点&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#63&#34;&gt;6.3 兄弟节点&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#64&#34;&gt;6.4 回退和前进&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#7&#34;&gt;7. 搜索方法&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#71&#34;&gt;7.1 过滤器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#72-find_all&#34;&gt;7.2 find_all()&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#73-find&#34;&gt;7.3 find()&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#74-find_parentsfind_parent&#34;&gt;7.4 find_parents()和find_parent()&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#75-find_next_siblingfind_next_sibling&#34;&gt;7.5 find_next_sibling()和find_next_sibling()&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#76-find_previous_sibingsfind_previous_sibing&#34;&gt;7.6 find_previous_sibings()和find_previous_sibing()&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#77-find_all_nextfind_next&#34;&gt;7.7 find_all_next()和find_next()&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#78-find_all_previousfind_previous&#34;&gt;7.8 find_all_previous()和find_previous()&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#79-css&#34;&gt;7.9 CSS选择器&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#8&#34;&gt;8. 修改方法&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#81-tag&#34;&gt;8.1 修改tag的名称和属性&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#82-string&#34;&gt;8.2 修改 .string&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#83-append&#34;&gt;8.3 append()&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#84-navigablestring-new_tag&#34;&gt;8.4 NavigableString() 和 .new_tag()&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#85-insert&#34;&gt;8.5 insert()&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#86-insert_before-insert_after&#34;&gt;8.6 insert_before() 和 insert_after()&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#87-clear&#34;&gt;8.7 clear()&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#88-extract&#34;&gt;8.8 extract()&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#89-decompose&#34;&gt;8.9 decompose()&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#810-replace_with&#34;&gt;8.10 replace_with()&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#811-wrap&#34;&gt;8.11 wrap()&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#812-unwrap&#34;&gt;8.12 unwrap()&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#9&#34;&gt;9. 输出&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#91&#34;&gt;9.1 格式化输出&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#92&#34;&gt;9.2 压缩输出&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#93&#34;&gt;9.3 输出格式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#94-get_text&#34;&gt;9.4 get_text()&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h3 id=&#34;1-beautiful-soup&#34;&gt;1. Beautiful Soup简介&lt;/h3&gt;
&lt;p&gt;Beautiful Soup 是一个可以从HTML或XML文件中提取数据的Python库.&lt;/p&gt;
&lt;h4 id=&#34;11&#34;&gt;1.1 举个例子&lt;/h4&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;html_doc = &amp;quot;&amp;quot;&amp;quot;
&amp;lt;html&amp;gt;&amp;lt;head&amp;gt;&amp;lt;title&amp;gt;这是一个例子&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;p class=&amp;quot;title&amp;quot;&amp;gt;&amp;lt;b&amp;gt;这是一个例子&amp;lt;/b&amp;gt;&amp;lt;/p&amp;gt;

&amp;lt;p class=&amp;quot;story&amp;quot;&amp;gt;从前有三个人;他们的名字是
&amp;lt;a href=&amp;quot;http://example.com/zhangsan&amp;quot; class=&amp;quot;peopele&amp;quot; id=&amp;quot;link1&amp;quot;&amp;gt;张三&amp;lt;/a&amp;gt;,
&amp;lt;a href=&amp;quot;http://example.com/lisi&amp;quot; class=&amp;quot;peopele&amp;quot; id=&amp;quot;link2&amp;quot;&amp;gt;李四&amp;lt;/a&amp;gt; 和
&amp;lt;a href=&amp;quot;http://example.com/wangwu&amp;quot; class=&amp;quot;peopele&amp;quot; id=&amp;quot;link3&amp;quot;&amp;gt;王五&amp;lt;/a&amp;gt;;
他们住在一个四合院。&amp;lt;/p&amp;gt;

&amp;lt;p class=&amp;quot;example&amp;quot;&amp;gt;...&amp;lt;/p&amp;gt;
&amp;quot;&amp;quot;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;格式化输出&lt;code&gt;html_doc&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;from bs4 import BeautifulSoup
soup = BeautifulSoup(html_doc, &#39;html.parser&#39;)
print(soup.prettify)

# 输出结果：
&amp;lt;bound method Tag.prettify of 
&amp;lt;html&amp;gt;&amp;lt;head&amp;gt;&amp;lt;title&amp;gt;这是一个例子&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;p class=&amp;quot;title&amp;quot;&amp;gt;&amp;lt;b&amp;gt;这是一个例子&amp;lt;/b&amp;gt;&amp;lt;/p&amp;gt;
&amp;lt;p class=&amp;quot;story&amp;quot;&amp;gt;从前有三个人;他们的名字是
&amp;lt;a class=&amp;quot;peopele&amp;quot; href=&amp;quot;http://example.com/zhangsan&amp;quot; id=&amp;quot;link1&amp;quot;&amp;gt;张三&amp;lt;/a&amp;gt;,
&amp;lt;a class=&amp;quot;peopele&amp;quot; href=&amp;quot;http://example.com/lisi&amp;quot; id=&amp;quot;link2&amp;quot;&amp;gt;李四&amp;lt;/a&amp;gt; 和
&amp;lt;a class=&amp;quot;peopele&amp;quot; href=&amp;quot;http://example.com/wangwu&amp;quot; id=&amp;quot;link3&amp;quot;&amp;gt;王五&amp;lt;/a&amp;gt;;
他们住在一个四合院。&amp;lt;/p&amp;gt;
&amp;lt;p class=&amp;quot;example&amp;quot;&amp;gt;...&amp;lt;/p&amp;gt;
&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;输出标题&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;print(soup.title)

# 输出结果：
&amp;lt;title&amp;gt;这是一个例子&amp;lt;/title&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;输出标题标签&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;print(soup.title.name)

# 输出结果：
title
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;输出标题内容&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;print(soup.title.string)

# 输出结果：
这是一个例子
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;输出标题的父标签&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;print(soup.title.parent.name)

# 输出结果：
head
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;查找第一个&lt;code&gt;p&lt;/code&gt;元素&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;print(soup.p)

# 输出结果：
&amp;lt;p class=&amp;quot;title&amp;quot;&amp;gt;&amp;lt;b&amp;gt;这是一个例子&amp;lt;/b&amp;gt;&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;查找第一个&lt;code&gt;p&lt;/code&gt;元素的&lt;code&gt;class&lt;/code&gt;属性内容&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;print(soup.p[&#39;class&#39;])

# 输出结果：
[&#39;title&#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;查找第一个&lt;code&gt;a&lt;/code&gt;元素&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;print(soup.a)

# 输出结果：
&amp;lt;a class=&amp;quot;people&amp;quot; href=&amp;quot;http://example.com/zhangsan&amp;quot; id=&amp;quot;link1&amp;quot;&amp;gt;张三&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;查找所有&lt;code&gt;a&lt;/code&gt;元素&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;print(soup.find_all(&#39;a&#39;))

# 输出结果：
[&amp;lt;a class=&amp;quot;people&amp;quot; href=&amp;quot;http://example.com/zhangsan&amp;quot; id=&amp;quot;link1&amp;quot;&amp;gt;张三&amp;lt;/a&amp;gt;, &amp;lt;a class=&amp;quot;people&amp;quot; href=&amp;quot;http://example.com/lisi&amp;quot; id=&amp;quot;link2&amp;quot;&amp;gt;李四&amp;lt;/a&amp;gt;, &amp;lt;a class=&amp;quot;people&amp;quot; href=&amp;quot;http://example.com/wangwu&amp;quot; id=&amp;quot;link3&amp;quot;&amp;gt;王五&amp;lt;/a&amp;gt;]
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;查找&lt;code&gt;id&lt;/code&gt;为&lt;code&gt;link3&lt;/code&gt;的元素&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;print(soup.find(id=&amp;quot;link3&amp;quot;))

# 输出结果：
&amp;lt;a class=&amp;quot;people&amp;quot; href=&amp;quot;http://example.com/wangwu&amp;quot; id=&amp;quot;link3&amp;quot;&amp;gt;王五&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-beautiful-soup&#34;&gt;2. 安装 Beautiful Soup&lt;/h3&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;$ pip install beautifulsoup4 -i https://pypi.tuna.tsinghua.edu.cn/simple/

Looking in indexes: https://pypi.tuna.tsinghua.edu.cn/simple/
Collecting beautifulsoup4
  Downloading https://pypi.tuna.tsinghua.edu.cn/packages/9c/d8/909c4089dbe4ade9f9705f143c9f13f065049a9d5e7d34c828aefdd0a97c/beautifulsoup4-4.11.1-py3-none-any.whl (128 kB)
     ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 128.2/128.2 kB 1.3 MB/s eta 0:00:00
Collecting soupsieve&amp;gt;1.2
  Downloading https://pypi.tuna.tsinghua.edu.cn/packages/16/e3/4ad79882b92617e3a4a0df1960d6bce08edfb637737ac5c3f3ba29022e25/soupsieve-2.3.2.post1-py3-none-any.whl (37 kB)
Installing collected packages: soupsieve, beautifulsoup4
Successfully installed beautifulsoup4-4.11.1 soupsieve-2.3.2.post1
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;3&#34;&gt;3. 安装解析器&lt;/h3&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;pip install lxml
pip install html5lib
&lt;/code&gt;&lt;/pre&gt;

&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;$ pip install lxml  -i https://pypi.tuna.tsinghua.edu.cn/simple/
Looking in indexes: https://pypi.tuna.tsinghua.edu.cn/simple/
Collecting lxml
  Downloading https://pypi.tuna.tsinghua.edu.cn/packages/b9/bb/00637cce419a958a8254ee4371b15446fd5cd41d8f53513aed52a1fbbe20/lxml-4.9.1-cp310-cp310-win_amd64.whl (3.6 MB)
     ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 3.6/3.6 MB 2.1 MB/s eta 0:00:00
Installing collected packages: lxml
Successfully installed lxml-4.9.1
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;4&#34;&gt;4. 使用方法&lt;/h3&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;# Python标准库

BeautifulSoup(markup,&amp;quot;html.parser&amp;quot;)

# lxml HTML解析器

BeautifulSoup(markup,&amp;quot;lxml&amp;quot;)

# lxml XML解析器

BeautifulSoup(markup,&amp;quot;lxml-xml&amp;quot;) or BeautifulSoup(markup,&amp;quot;xml&amp;quot;)

# html5lib

BeautifulSoup(markup,&amp;quot;html5lib&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;5&#34;&gt;5. 对象的种类&lt;/h3&gt;
&lt;p&gt;Beautiful Soup将复杂HTML文档转换成一个复杂的树形结构,每个节点都是Python对象,所有对象可以归纳为4种:&lt;code&gt;Tag&lt;/code&gt;,&lt;code&gt;NavigableString&lt;/code&gt;,&lt;code&gt;BeautifulSoup&lt;/code&gt;,&lt;code&gt;Comment&lt;/code&gt;.&lt;/p&gt;
&lt;h4 id=&#34;51-tag&#34;&gt;5.1 Tag&lt;/h4&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;from bs4 import BeautifulSoup

soup = BeautifulSoup(&#39;&amp;lt;b class=&amp;quot;test&amp;quot;&amp;gt;测试一下&amp;lt;/b&amp;gt;&#39;,&amp;quot;html.parser&amp;quot;)
tag = soup.b
print(tag)
print(type(tag))

# 输出结果：
&amp;lt;b class=&amp;quot;test&amp;quot;&amp;gt;测试一下&amp;lt;/b&amp;gt;
&amp;lt;class &#39;bs4.element.Tag&#39;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Tag有很多方法和属性,后面会详细解释.现在主要说一下&lt;code&gt;name&lt;/code&gt;和&lt;code&gt;attributes&lt;/code&gt;两个属性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Name&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;每个tag都有自己的名字,通过&lt;code&gt;.name&lt;/code&gt;来获取:&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;from bs4 import BeautifulSoup

soup = BeautifulSoup(&#39;&amp;lt;b class=&amp;quot;test&amp;quot;&amp;gt;测试一下&amp;lt;/b&amp;gt;&#39;,&amp;quot;html.parser&amp;quot;)
tag = soup.b
print(tag.name)

# 输出结果
b
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果改变了tag的name,那将影响所有通过当前Beautiful Soup对象生成的HTML文档:&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;from bs4 import BeautifulSoup

soup = BeautifulSoup(&#39;&amp;lt;b class=&amp;quot;test&amp;quot;&amp;gt;测试一下&amp;lt;/b&amp;gt;&#39;,&amp;quot;html.parser&amp;quot;)
tag = soup.b
tag.name = &amp;quot;blockquote&amp;quot;
print(tag)

# 输出结果
&amp;lt;blockquote class=&amp;quot;test&amp;quot;&amp;gt;测试一下&amp;lt;/blockquote&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Attributes&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一个tag可能有很多个属性. tag&lt;code&gt;&amp;lt;b class=&#34;test&#34;&amp;gt;&lt;/code&gt;有一个 “class” 的属性,值为 “test” . tag的属性的操作方法与字典相同，也可以直接”点”取属性, 比如:&lt;code&gt;.attrs&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;# coding=utf-8

from bs4 import BeautifulSoup

soup = BeautifulSoup(&#39;&amp;lt;b class=&amp;quot;test&amp;quot;&amp;gt;测试一下&amp;lt;/b&amp;gt;&#39;,&amp;quot;html.parser&amp;quot;)
tag = soup.b
print(tag[&#39;class&#39;])
print(tag.attrs)

# 输出结果
[&#39;test&#39;]
{&#39;class&#39;: [&#39;test&#39;]}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;tag的属性可以被添加,删除或修改:&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;# coding=utf-8

from bs4 import BeautifulSoup

soup = BeautifulSoup(&#39;&amp;lt;b class=&amp;quot;test&amp;quot;&amp;gt;测试一下&amp;lt;/b&amp;gt;&#39;,&amp;quot;html.parser&amp;quot;)
tag = soup.b

tag[&#39;class&#39;] = &#39;tester&#39;
tag[&#39;id&#39;] = 1
print(tag)

del tag[&#39;class&#39;]
del tag[&#39;id&#39;]
print(tag)

tag[&#39;class&#39;]
print(tag.get(&#39;class&#39;))

# 输出结果
&amp;lt;b class=&amp;quot;tester&amp;quot; id=&amp;quot;1&amp;quot;&amp;gt;测试一下&amp;lt;/b&amp;gt;
&amp;lt;b&amp;gt;测试一下&amp;lt;/b&amp;gt;
KeyError: &#39;class&#39;
None
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;多值属性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一个&lt;code&gt;tag&lt;/code&gt;可以有多个&lt;code&gt;class&lt;/code&gt;，还有一些属性&lt;code&gt;rel&lt;/code&gt;，&lt;code&gt;rev&lt;/code&gt;，&lt;code&gt;accept-charset&lt;/code&gt;，&lt;code&gt;headers&lt;/code&gt;，&lt;code&gt;accesskey&lt;/code&gt;，多值属性返回的类型是&lt;code&gt;list&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;from bs4 import BeautifulSoup

soup = BeautifulSoup(&#39;&amp;lt;p class=&amp;quot;test dev&amp;quot;&amp;gt;&amp;lt;/p&amp;gt;&#39;,&amp;quot;html.parser&amp;quot;)
print(soup.p[&#39;class&#39;])

soup = BeautifulSoup(&#39;&amp;lt;p class=&amp;quot;test&amp;quot;&amp;gt;&amp;lt;/p&amp;gt;&#39;,&amp;quot;html.parser&amp;quot;)
print(soup.p[&#39;class&#39;])

# 输出结果
[&#39;test&#39;, &#39;dev&#39;]
[&#39;test&#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一些属性只能有单个值，那么其以字符串返回：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;from bs4 import BeautifulSoup

soup = BeautifulSoup(&#39;&amp;lt;p id=&amp;quot;test&amp;quot;&amp;gt;&amp;lt;/p&amp;gt;&#39;,&amp;quot;html.parser&amp;quot;)
print(soup.p[&#39;id&#39;])

# 输出结果
test
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将tag转换成字符串时,多值属性会合并为一个值&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;from bs4 import BeautifulSoup

soup = BeautifulSoup(&#39;&amp;lt;p&amp;gt;Back to the &amp;lt;a rel=&amp;quot;index&amp;quot;&amp;gt;homepage&amp;lt;/a&amp;gt;&amp;lt;/p&amp;gt;&#39;,&amp;quot;html.parser&amp;quot;)
print(soup.a[&#39;rel&#39;])
soup.a[&#39;rel&#39;] = [&#39;index&#39;, &#39;contents&#39;]
print(soup.p)

# 输出结果
[&#39;index&#39;]
&amp;lt;p&amp;gt;Back to the &amp;lt;a rel=&amp;quot;index contents&amp;quot;&amp;gt;homepage&amp;lt;/a&amp;gt;&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果转换的文档是XML格式,那么tag中不包含多值属性&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;from bs4 import BeautifulSoup

soup = BeautifulSoup(&#39;&amp;lt;p class=&amp;quot;test dev&amp;quot;&amp;gt;&amp;lt;/p&amp;gt;&#39;, &#39;lxml-xml&#39;)
print(soup.p[&#39;class&#39;])

# 输出结果
test dev
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;52&#34;&gt;5.2 可遍历的字符串&lt;/h4&gt;
&lt;p&gt;字符串常被包含在tag内.Beautiful Soup用 NavigableString 类来包装tag中的字符串:&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;from bs4 import BeautifulSoup

soup = BeautifulSoup(&#39;&amp;lt;p class=&amp;quot;test&amp;quot;&amp;gt;测试一下&amp;lt;/p&amp;gt;&#39;, &amp;quot;html.parser&amp;quot;)
tag = soup.p
print(tag.string)
print(type(tag.string))

# 输出结果
测试一下
&amp;lt;class &#39;bs4.element.NavigableString&#39;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过 str() 方法可以直接将 NavigableString 对象转换成字符串:&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;from bs4 import BeautifulSoup

soup = BeautifulSoup(&#39;&amp;lt;p class=&amp;quot;test&amp;quot;&amp;gt;测试一下&amp;lt;/p&amp;gt;&#39;, &amp;quot;html.parser&amp;quot;)
tag = soup.p
print(type(tag.string))
str_string = str(tag.string)
print(str_string)
print(type(str_string))

# 输出结果
&amp;lt;class &#39;bs4.element.NavigableString&#39;&amp;gt;
测试一下
&amp;lt;class &#39;str&#39;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;tag中包含的字符串不能编辑,但是可以被替换成其它的字符串,用 replace_with() 方法:&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;from bs4 import BeautifulSoup

soup = BeautifulSoup(&#39;&amp;lt;p class=&amp;quot;test&amp;quot;&amp;gt;测试一下&amp;lt;/p&amp;gt;&#39;, &amp;quot;html.parser&amp;quot;)
tag = soup.p
tag.string.replace_with(&amp;quot;洗洗睡吧&amp;quot;)
print(tag)

# 输出结果
&amp;lt;p class=&amp;quot;test&amp;quot;&amp;gt;洗洗睡吧&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果想在Beautiful Soup之外使用 NavigableString 对象，需要用str()方法将其转换成字符串。&lt;/p&gt;
&lt;h4 id=&#34;53-beautifulsoup&#34;&gt;5.3 BeautifulSoup&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;BeautifulSoup&lt;/code&gt;对象表示的是一个文档的全部内容。大部分时候，可以把他当作&lt;code&gt;tag&lt;/code&gt;对象。因为&lt;code&gt;BeautifulSoup&lt;/code&gt;对象并不是真正的HTML或XML的tag，所以它没有&lt;code&gt;name&lt;/code&gt;和&lt;code&gt;attribute&lt;/code&gt;属性，但为了查看方便，给&lt;code&gt;BeautifulSoup&lt;/code&gt;对象一个&lt;code&gt;[document]&lt;/code&gt;的特殊属性。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;from bs4 import BeautifulSoup

soup = BeautifulSoup(&#39;&amp;lt;p class=&amp;quot;test&amp;quot;&amp;gt;测试一下&amp;lt;/p&amp;gt;&#39;, &amp;quot;html.parser&amp;quot;)
print(soup.name)

# 输出结果
[document]
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;54&#34;&gt;5.4 注释及特殊字符串&lt;/h4&gt;
&lt;p&gt;除&lt;code&gt;Tag&lt;/code&gt;，&lt;code&gt;NavigableString&lt;/code&gt;，&lt;code&gt;BeautifulSoup&lt;/code&gt;外，还有一些特殊对象，是文档的注释部分:&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;from bs4 import BeautifulSoup

markup = &amp;quot;&amp;lt;b&amp;gt;&amp;lt;!--你好，兄弟。这里有一个缺陷不要乱动？--&amp;gt;&amp;lt;/b&amp;gt;&amp;quot;
soup = BeautifulSoup(markup, &amp;quot;html.parser&amp;quot;)
comment = soup.b.string
print(type(comment))

# 输出结果
&amp;lt;class &#39;bs4.element.Comment&#39;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Comment 对象是一个特殊类型的 NavigableString 对象:&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;print(comment)

# 输出结果
你好，兄弟。这里有一个缺陷不要乱动？
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当它出现在HTML文档中时，&lt;code&gt;Comment&lt;/code&gt;可以格式化输出：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;print(soup.b.prettify())

# 输出结果
&amp;lt;b&amp;gt;
 &amp;lt;!--你好，兄弟。这里有一个缺陷不要乱动？--&amp;gt;
&amp;lt;/b&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Beautiful Soup中定义的&lt;code&gt;CData&lt;/code&gt;，&lt;code&gt;ProcessingInstruction&lt;/code&gt;，&lt;code&gt;Declaration&lt;/code&gt;，&lt;code&gt;Doctype&lt;/code&gt;与&lt;code&gt;Comment&lt;/code&gt;对象类似,这些类都是 &lt;code&gt;NavigableString&lt;/code&gt;的子类,下面是用CDATA来替代注释的例子:&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;from bs4 import BeautifulSoup
from bs4 import CData

cdata = CData(&amp;quot;A CDATA block&amp;quot;)
markup = &amp;quot;&amp;lt;b&amp;gt;&amp;lt;!--你好，兄弟。这里有一个缺陷不要乱动？--&amp;gt;&amp;lt;/b&amp;gt;&amp;quot;
soup = BeautifulSoup(markup, &amp;quot;html.parser&amp;quot;)
comment = soup.b.string
comment.replace_with(cdata)
print(soup.b.prettify())

# 输出结果
&amp;lt;b&amp;gt;
 &amp;lt;![CDATA[A CDATA block]]&amp;gt;
&amp;lt;/b&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;6&#34;&gt;6. 遍历方法&lt;/h3&gt;
&lt;p&gt;从文档的一段内容中查找另一段内容&lt;/p&gt;
&lt;p&gt;举个例子：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;html_doc = &amp;quot;&amp;quot;&amp;quot;
&amp;lt;html&amp;gt;&amp;lt;head&amp;gt;&amp;lt;title&amp;gt;这是一个例子&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;p class=&amp;quot;title&amp;quot;&amp;gt;&amp;lt;b&amp;gt;这是一个例子&amp;lt;/b&amp;gt;&amp;lt;/p&amp;gt;

&amp;lt;p class=&amp;quot;story&amp;quot;&amp;gt;从前有三个人;他们的名字是
&amp;lt;a href=&amp;quot;http://example.com/zhangsan&amp;quot; class=&amp;quot;people&amp;quot; id=&amp;quot;link1&amp;quot;&amp;gt;张三&amp;lt;/a&amp;gt;,
&amp;lt;a href=&amp;quot;http://example.com/lisi&amp;quot; class=&amp;quot;people&amp;quot; id=&amp;quot;link2&amp;quot;&amp;gt;李四&amp;lt;/a&amp;gt; 和
&amp;lt;a href=&amp;quot;http://example.com/wangwu&amp;quot; class=&amp;quot;people&amp;quot; id=&amp;quot;link3&amp;quot;&amp;gt;王五&amp;lt;/a&amp;gt;;
他们住在一个四合院。&amp;lt;/p&amp;gt;

&amp;lt;p class=&amp;quot;example&amp;quot;&amp;gt;...&amp;lt;/p&amp;gt;
&amp;quot;&amp;quot;&amp;quot;

from bs4 import BeautifulSoup
soup = BeautifulSoup(html_doc, &#39;html.parser&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;61&#34;&gt;6.1 子节点&lt;/h4&gt;
&lt;p&gt;一个&lt;code&gt;Tag&lt;/code&gt;下的字符串或&lt;code&gt;Tag&lt;/code&gt;，都是其子节点。注：字符串子节点不支持这些属性。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;tag的属性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;获取tag的head：&lt;code&gt;soup.head&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;print(soup.head)

# 输出结果：
&amp;lt;head&amp;gt;&amp;lt;title&amp;gt;这是一个例子&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;获取tag的title：&lt;code&gt;soup.title&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;print(soup.title)

# 输出结果：
&amp;lt;title&amp;gt;这是一个例子&amp;lt;/title&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;获取&lt;body&gt;标签下第一个&lt;b&gt;标签：&lt;code&gt;soup.body.b&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;print(soup.body.b)

# 输出结果：
&amp;lt;b&amp;gt;这是一个例子&amp;lt;/b&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;获取tag下第一个&lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt;标签：&lt;code&gt;soup.a&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;print(soup.a)

# 输出结果：
&amp;lt;a class=&amp;quot;people&amp;quot; href=&amp;quot;http://example.com/zhangsan&amp;quot; id=&amp;quot;link1&amp;quot;&amp;gt;张三&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;获取tag下所有&lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt;标签：&lt;code&gt;soup.find_all(&#39;a&#39;)&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;print(soup.find_all(&#39;a&#39;))

# 输出结果：
[&amp;lt;a class=&amp;quot;people&amp;quot; href=&amp;quot;http://example.com/zhangsan&amp;quot; id=&amp;quot;link1&amp;quot;&amp;gt;张三&amp;lt;/a&amp;gt;, &amp;lt;a class=&amp;quot;people&amp;quot; href=&amp;quot;http://example.com/lisi&amp;quot; id=&amp;quot;link2&amp;quot;&amp;gt;李四&amp;lt;/a&amp;gt;, &amp;lt;a class=&amp;quot;people&amp;quot; href=&amp;quot;http://example.com/wangwu&amp;quot; id=&amp;quot;link3&amp;quot;&amp;gt;王五&amp;lt;/a&amp;gt;]
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;.contents 和 .children&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;tag的&lt;code&gt;.contents&lt;/code&gt;属性可以将tag的子节点以列表方式输出：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;head_tag = soup.head
print(head_tag)
print(head_tag.contents)

title_tag = head_tag.contents[0]
print(title_tag)
print(title_tag.contents)

# 输出结果
&amp;lt;head&amp;gt;&amp;lt;title&amp;gt;这是一个例子&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;
[&amp;lt;title&amp;gt;这是一个例子&amp;lt;/title&amp;gt;]
&amp;lt;title&amp;gt;这是一个例子&amp;lt;/title&amp;gt;
[&#39;这是一个例子&#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;BeautifulSoup对象一定包含子节点,也就是说&lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt;标签也是 BeautifulSoup 对象的子节点:&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;print(len(soup.contents))
print(soup.contents[0].name)

# 输出结果
1
html
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;字符串没有 .contents 属性,因为字符串没有子节点:&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;head_tag = soup.head
title_tag = head_tag.contents[0]
text = title_tag.contents[0]
print(text.contents)

# 输出结果
AttributeError: &#39;NavigableString&#39; object has no attribute &#39;contents&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过tag的 .children 生成器,可以对tag的子节点进行循环:&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;head_tag = soup.head
title_tag = head_tag.contents[0]
for child in title_tag.children:
    print(child)

# 输出结果
这是一个例子
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;.descendants&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;.contents 和 .children 属性仅包含tag的直接子节点.例如,&lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt;标签只有一个直接子节点&lt;code&gt;&amp;lt;title&amp;gt;&lt;/code&gt;,但是&lt;code&gt;&amp;lt;title&amp;gt;&lt;/code&gt;标签也包含一个子节点:字符串 “这是一个例子”, 其也属于&lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt;标签的子孙节点. .descendants 属性可以对所有tag的子孙节点进行递归循环:&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;for child in head_tag.descendants:
    print(child)

# 输出结果
&amp;lt;title&amp;gt;这是一个例子&amp;lt;/title&amp;gt;
这是一个例子
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的例子中, &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt;标签只有一个子节点,但是有2个子孙节点:&lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt;节点和&lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt;的子节点, BeautifulSoup 有一个直接子节点(&lt;html&gt;节点),也有很多子孙节点:&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;print(len(list(soup.children)))
print(len(list(soup.descendants)))

# 输出结果：
1
26
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;.string&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果tag只有一个 NavigableString 类型子节点,那么这个tag可以使用 .string 得到子节点:&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;head_tag = soup.head
title_tag = head_tag.contents[0]
print(title_tag.string)

# 输出结果：
这是一个例子
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果一个tag仅有一个子节点,那么这个tag也可以使用 .string 方法,输出结果与当前唯一子节点的 .string 结果相同:&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;head_tag = soup.head
print(head_tag.contents)
print(head_tag.string)

# 输出结果：
[&amp;lt;title&amp;gt;这是一个例子&amp;lt;/title&amp;gt;]
这是一个例子
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果tag包含了多个子节点,tag就无法确定 .string 方法应该调用哪个子节点的内容, .string 的输出结果是 None :&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;print(soup.html.string)
# 输出结果：
None
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;.strings 和 stripped_strings&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果tag中包含多个字符串,可以使用 .strings 来循环获取:&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;for string in soup.strings:
    print(repr(string))

# 输出结果
&#39;这是一个例子&#39;
&#39;\n&#39;
&#39;\n&#39;
&#39;这是一个例子&#39;
&#39;\n&#39;
&#39;从前有三个人;他们的名字是\n&#39;
&#39;张三&#39;
&#39;,\n&#39;
&#39;李四&#39;
&#39; 和\n&#39;
&#39;王五&#39;
&#39;;\n他们住在一个四合院。&#39;
&#39;\n&#39;
&#39;...&#39;
&#39;\n&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出的字符串中可能包含了很多空格或空行,使用 .stripped_strings 可以去除多余空白内容:&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;for string in soup.stripped_strings:
    print(repr(string))

# 输出结果
&#39;这是一个例子&#39;
&#39;这是一个例子&#39;
&#39;从前有三个人;他们的名字是&#39;
&#39;张三&#39;
&#39;,&#39;
&#39;李四&#39;
&#39;和&#39;
&#39;王五&#39;
&#39;;\n他们住在一个四合院。&#39;
&#39;...&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;62&#34;&gt;6.2 父节点&lt;/h4&gt;
&lt;p&gt;每个tag或字符串都有父节点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;.parent&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过 .parent 属性来获取某个元素的父节点.在上面例子中,&lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt;标签是&lt;code&gt;&amp;lt;title&amp;gt;&lt;/code&gt;标签的父节点:&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;title_tag = soup.title
print(title_tag)
print(title_tag.parent)

# 输出结果
&amp;lt;title&amp;gt;这是一个例子&amp;lt;/title&amp;gt;
&amp;lt;head&amp;gt;&amp;lt;title&amp;gt;这是一个例子&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;title标签下的字符串也有父节点:&lt;code&gt;&amp;lt;title&amp;gt;&lt;/code&gt;标签&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;title_tag = soup.title
print(title_tag.string.parent)

# 输出结果
&amp;lt;title&amp;gt;这是一个例子&amp;lt;/title&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;文档的顶层节点比如&lt;html&gt;的父节点是 BeautifulSoup 对象:&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;html_tag = soup.html
print(type(html_tag.parent))

# 输出结果
&amp;lt;class &#39;bs4.BeautifulSoup&#39;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;BeautifulSoup 对象的 .parent 是None:&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;print(soup.parent)

# 输出结果
None
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;.parents&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过元素的 .parents 属性可以递归得到元素的所有父辈节点&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;link = soup.a
print(link)
for parent in link.parents:
    print(parent.name)

# 输出结果
&amp;lt;a class=&amp;quot;people&amp;quot; href=&amp;quot;http://example.com/zhangsan&amp;quot; id=&amp;quot;link1&amp;quot;&amp;gt;张三&amp;lt;/a&amp;gt;
p
body
html
[document]
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;63&#34;&gt;6.3 兄弟节点&lt;/h4&gt;
&lt;p&gt;如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;sibling_soup = BeautifulSoup(&amp;quot;&amp;lt;a&amp;gt;&amp;lt;b&amp;gt;text1&amp;lt;/b&amp;gt;&amp;lt;c&amp;gt;text2&amp;lt;/c&amp;gt;&amp;lt;/b&amp;gt;&amp;lt;/a&amp;gt;&amp;quot;, &#39;html.parser&#39;)
print(sibling_soup.prettify())

# 输出结果
&amp;lt;html&amp;gt;
 &amp;lt;body&amp;gt;
  &amp;lt;a&amp;gt;
   &amp;lt;b&amp;gt;
    text1
   &amp;lt;/b&amp;gt;
   &amp;lt;c&amp;gt;
    text2
   &amp;lt;/c&amp;gt;
  &amp;lt;/a&amp;gt;
 &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同一个缩进级别的称为兄弟节点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;.next_sibling 和 .previous_sibling&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用 .next_sibling 和 .previous_sibling 属性来查询兄弟节点:&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;sibling_soup = BeautifulSoup(&amp;quot;&amp;lt;a&amp;gt;&amp;lt;b&amp;gt;text1&amp;lt;/b&amp;gt;&amp;lt;c&amp;gt;text2&amp;lt;/c&amp;gt;&amp;lt;/b&amp;gt;&amp;lt;/a&amp;gt;&amp;quot;,&#39;html.parser&#39;)
print(sibling_soup.b.next_sibling)
print(sibling_soup.c.previous_sibling)

# 输出结果
&amp;lt;c&amp;gt;text2&amp;lt;/c&amp;gt; # b的下一个节点是c
&amp;lt;b&amp;gt;text1&amp;lt;/b&amp;gt; # c的上一个节点是b
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果没有上一节点或下一节点，则显示&lt;code&gt;None&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;sibling_soup = BeautifulSoup(&amp;quot;&amp;lt;a&amp;gt;&amp;lt;b&amp;gt;text1&amp;lt;/b&amp;gt;&amp;lt;c&amp;gt;text2&amp;lt;/c&amp;gt;&amp;lt;/b&amp;gt;&amp;lt;/a&amp;gt;&amp;quot;,&#39;html.parser&#39;)
print(sibling_soup.c.next_sibling)
print(sibling_soup.b.previous_sibling)

# 输出结果
None
None
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;tag的 .next_sibling 和 .previous_sibling 属性通常是字符串或空白,如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;link = soup.a
print(link)
print(link.next_sibling)

# 输出结果
&amp;lt;a class=&amp;quot;people&amp;quot; href=&amp;quot;http://example.com/zhangsan&amp;quot; id=&amp;quot;link1&amp;quot;&amp;gt;张三&amp;lt;/a&amp;gt;
,\n
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;link&lt;/code&gt;的下一个兄弟结点是&lt;code&gt;,\n&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;.next_siblings 和 .previous_siblings&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过 .next_siblings 和 .previous_siblings 属性可以对当前节点的兄弟节点迭代输出:&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;for sibling in soup.a.next_siblings:
    print(repr(sibling))

# 输出结果
&#39;,\n&#39;
&amp;lt;a class=&amp;quot;people&amp;quot; href=&amp;quot;http://example.com/lisi&amp;quot; id=&amp;quot;link2&amp;quot;&amp;gt;李四&amp;lt;/a&amp;gt;
&#39; 和\n&#39;
&amp;lt;a class=&amp;quot;people&amp;quot; href=&amp;quot;http://example.com/wangwu&amp;quot; id=&amp;quot;link3&amp;quot;&amp;gt;王五&amp;lt;/a&amp;gt;
&#39;;\n他们住在一个四合院。&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;for sibling in soup.find(id=&amp;quot;link3&amp;quot;).previous_siblings:
    print(repr(sibling))

# 输出结果
&#39; 和\n&#39;
&amp;lt;a class=&amp;quot;people&amp;quot; href=&amp;quot;http://example.com/lisi&amp;quot; id=&amp;quot;link2&amp;quot;&amp;gt;李四&amp;lt;/a&amp;gt;
&#39;,\n&#39;
&amp;lt;a class=&amp;quot;people&amp;quot; href=&amp;quot;http://example.com/zhangsan&amp;quot; id=&amp;quot;link1&amp;quot;&amp;gt;张三&amp;lt;/a&amp;gt;
&#39;从前有三个人;他们的名字是\n&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;64&#34;&gt;6.4 回退和前进&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;.next_element 和 .previous_element&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;.next_element 和 .next_sibling 相似，但通常输出结果不一致&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;last_a_tag = soup.find(&amp;quot;a&amp;quot;, id=&amp;quot;link3&amp;quot;)
print(last_a_tag)
print(last_a_tag.next_sibling)
print(last_a_tag.next_element)

# 输出结果
&amp;lt;a class=&amp;quot;people&amp;quot; href=&amp;quot;http://example.com/wangwu&amp;quot; id=&amp;quot;link3&amp;quot;&amp;gt;王五&amp;lt;/a&amp;gt;
;
他们住在一个四合院。
王五
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对比一下，.next_sibling输出的是闭合区间的下一个，.next_element输出的是非闭合区间的下一个&lt;/p&gt;
&lt;p&gt;.previous_element 属性刚好与 .next_element 相反,它指向当前被解析的对象的前一个解析对象:&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;last_a_tag = soup.find(&amp;quot;a&amp;quot;, id=&amp;quot;link3&amp;quot;)
print(last_a_tag)
print(last_a_tag.previous_sibling)
print(last_a_tag.previous_element)

# 输出结果
 和\n
 和\n
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;.next_elements 和 .previous_elements&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;last_a_tag = soup.find(&amp;quot;a&amp;quot;, id=&amp;quot;link3&amp;quot;)
for element in last_a_tag.next_elements:
    print(repr(element))

# 输出结果
&#39;王五&#39;
&#39;;\n他们住在一个四合院。&#39;
&#39;\n&#39;
&amp;lt;p class=&amp;quot;example&amp;quot;&amp;gt;...&amp;lt;/p&amp;gt;
&#39;...&#39;
&#39;\n&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;7&#34;&gt;7. 搜索方法&lt;/h3&gt;
&lt;p&gt;Beautiful Soup有很多搜索方法，这里主要说一下: &lt;code&gt;find()&lt;/code&gt;和&lt;code&gt;find_all()&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;举个例子：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;html_doc = &amp;quot;&amp;quot;&amp;quot;
&amp;lt;html&amp;gt;&amp;lt;head&amp;gt;&amp;lt;title&amp;gt;这是一个例子&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;p class=&amp;quot;title&amp;quot;&amp;gt;&amp;lt;b&amp;gt;这是一个例子&amp;lt;/b&amp;gt;&amp;lt;/p&amp;gt;

&amp;lt;p class=&amp;quot;story&amp;quot;&amp;gt;从前有三个人;他们的名字是
&amp;lt;a href=&amp;quot;http://example.com/zhangsan&amp;quot; class=&amp;quot;people&amp;quot; id=&amp;quot;link1&amp;quot;&amp;gt;张三&amp;lt;/a&amp;gt;,
&amp;lt;a href=&amp;quot;http://example.com/lisi&amp;quot; class=&amp;quot;people&amp;quot; id=&amp;quot;link2&amp;quot;&amp;gt;李四&amp;lt;/a&amp;gt; 和
&amp;lt;a href=&amp;quot;http://example.com/wangwu&amp;quot; class=&amp;quot;people&amp;quot; id=&amp;quot;link3&amp;quot;&amp;gt;王五&amp;lt;/a&amp;gt;;
他们住在一个四合院。&amp;lt;/p&amp;gt;

&amp;lt;p class=&amp;quot;example&amp;quot;&amp;gt;...&amp;lt;/p&amp;gt;
&amp;quot;&amp;quot;&amp;quot;

from bs4 import BeautifulSoup
soup = BeautifulSoup(html_doc, &#39;html.parser&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;71&#34;&gt;7.1 过滤器&lt;/h4&gt;
&lt;p&gt;过滤器主要有字符串、正则表达式、列表、True、方法等&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;字符串&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在Beautiful Soup中传入一个字符串，查找与字符串完整匹配的内容，如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;print(soup.find_all(&#39;b&#39;))

# 输出结果
[&amp;lt;b&amp;gt;这是一个例子&amp;lt;/b&amp;gt;]
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;正则表达式&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在Beautiful Soup中传入正则表达式，则通过search()来匹配内容，如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;import re

for tag in soup.find_all(re.compile(&amp;quot;b&amp;quot;)):
    print(tag.name)

# 输出结果
body
b
&lt;/code&gt;&lt;/pre&gt;

&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;import re

for tag in soup.find_all(re.compile(&amp;quot;t&amp;quot;)):
    print(tag.name)

# 输出结果
html
title
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;列表&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在Beautiful Soup中传入列表，则匹配列表中任一元素的内容，如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;print(soup.find_all([&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;]))

# 输出结果
[&amp;lt;b&amp;gt;这是一个例子&amp;lt;/b&amp;gt;, &amp;lt;a class=&amp;quot;people&amp;quot; href=&amp;quot;http://example.com/zhangsan&amp;quot; id=&amp;quot;link1&amp;quot;&amp;gt;张三&amp;lt;/a&amp;gt;, &amp;lt;a class=&amp;quot;people&amp;quot; href=&amp;quot;http://example.com/lisi&amp;quot; id=&amp;quot;link2&amp;quot;&amp;gt;李四&amp;lt;/a&amp;gt;, &amp;lt;a class=&amp;quot;people&amp;quot; href=&amp;quot;http://example.com/wangwu&amp;quot; id=&amp;quot;link3&amp;quot;&amp;gt;王五&amp;lt;/a&amp;gt;]
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;True&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;True或以匹配任何值，如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;for tag in soup.find_all(True):
    print(tag.name)

# 输出结果
html
head
title
body
p
b
p
a
a
a
p
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;方法&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果没有合适的过滤器，那就自定义一个方法，方法只接受一个参数，如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;def not_zhangsan(href):
    return href and not re.compile(&amp;quot;zhangsan&amp;quot;).search(href)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用这个方法可以得到链接中没有&lt;code&gt;zhangsan&lt;/code&gt;的其他链接，如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;print(soup.find_all(href=not_zhangsan))

# 输出结果
[&amp;lt;a class=&amp;quot;people&amp;quot; href=&amp;quot;http://example.com/lisi&amp;quot; id=&amp;quot;link2&amp;quot;&amp;gt;李四&amp;lt;/a&amp;gt;, &amp;lt;a class=&amp;quot;people&amp;quot; href=&amp;quot;http://example.com/wangwu&amp;quot; id=&amp;quot;link3&amp;quot;&amp;gt;王五&amp;lt;/a&amp;gt;]
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;72-find_all&#34;&gt;7.2 find_all()&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;find_all()&lt;/code&gt;格式如下：&lt;code&gt;find_all( name , attrs , recursive , string , **kwargs )&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;find_all&lt;/code&gt;方法搜索当前tag的所有符合过滤器条件的子节点，如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;name参数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;name&lt;/code&gt;参数可以查找所有名字为&lt;code&gt;name&lt;/code&gt;的tag，如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;print(soup.find_all(&amp;quot;title&amp;quot;))

# 输出结果
[&amp;lt;title&amp;gt;这是一个例子&amp;lt;/title&amp;gt;]
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;keyword参数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;查找指定参数包含的关键字的tag，如下：&lt;/p&gt;
&lt;p&gt;查找id为link2的tag&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;print(soup.find_all(id=&amp;quot;link2&amp;quot;))

# 输出结果
[&amp;lt;a class=&amp;quot;people&amp;quot; href=&amp;quot;http://example.com/lisi&amp;quot; id=&amp;quot;link2&amp;quot;&amp;gt;李四&amp;lt;/a&amp;gt;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查找href中包含zhangsan的tag, 如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;import re
print(soup.find_all(href=re.compile(&amp;quot;zhangsan&amp;quot;)))

# 输出结果
[&amp;lt;a class=&amp;quot;people&amp;quot; href=&amp;quot;http://example.com/zhangsan&amp;quot; id=&amp;quot;link1&amp;quot;&amp;gt;张三&amp;lt;/a&amp;gt;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查找有id属性的tag, 如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;print(soup.find_all(id=True))

# 输出结果
[&amp;lt;a class=&amp;quot;people&amp;quot; href=&amp;quot;http://example.com/zhangsan&amp;quot; id=&amp;quot;link1&amp;quot;&amp;gt;张三&amp;lt;/a&amp;gt;, &amp;lt;a class=&amp;quot;people&amp;quot; href=&amp;quot;http://example.com/lisi&amp;quot; id=&amp;quot;link2&amp;quot;&amp;gt;李四&amp;lt;/a&amp;gt;, &amp;lt;a class=&amp;quot;people&amp;quot; href=&amp;quot;http://example.com/wangwu&amp;quot; id=&amp;quot;link3&amp;quot;&amp;gt;王五&amp;lt;/a&amp;gt;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同时指定多个过滤属性，如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;print(soup.find_all(href=re.compile(&amp;quot;example.com&amp;quot;), id=&#39;link1&#39;))

# 输出结果
[&amp;lt;a class=&amp;quot;people&amp;quot; href=&amp;quot;http://example.com/zhangsan&amp;quot; id=&amp;quot;link1&amp;quot;&amp;gt;张三&amp;lt;/a&amp;gt;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有些tag属性在搜索不能使用,比如HTML5中的 data-* 属性, 但是可以通过 find_all() 方法的 attrs 参数定义一个字典参数来搜索包含特殊属性的tag::&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;data_soup = BeautifulSoup(&#39;&amp;lt;div data-foo=&amp;quot;value&amp;quot;&amp;gt;foo!&amp;lt;/div&amp;gt;&#39;, &#39;html.parser&#39;)
print(data_soup.find_all(attrs={&amp;quot;data-foo&amp;quot;: &amp;quot;value&amp;quot;}))

# 输出结果
[&amp;lt;div data-foo=&amp;quot;value&amp;quot;&amp;gt;foo!&amp;lt;/div&amp;gt;]
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;按CSS搜索&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过&lt;code&gt;class_&lt;/code&gt;参数搜索指定的CSS类名tag, 如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;print(soup.find_all(&amp;quot;a&amp;quot;, class_=&amp;quot;people&amp;quot;))

# 输出结果
[&amp;lt;a class=&amp;quot;people&amp;quot; href=&amp;quot;http://example.com/zhangsan&amp;quot; id=&amp;quot;link1&amp;quot;&amp;gt;张三&amp;lt;/a&amp;gt;, &amp;lt;a class=&amp;quot;people&amp;quot; href=&amp;quot;http://example.com/lisi&amp;quot; id=&amp;quot;link2&amp;quot;&amp;gt;李四&amp;lt;/a&amp;gt;, &amp;lt;a class=&amp;quot;people&amp;quot; href=&amp;quot;http://example.com/wangwu&amp;quot; id=&amp;quot;link3&amp;quot;&amp;gt;王五&amp;lt;/a&amp;gt;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;class_&lt;/code&gt;参数可接受各种类型的过滤器，如字符串、正则表达式、方法和True:&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;print(soup.find_all(class_=re.compile(&amp;quot;itl&amp;quot;)))
# 输出结果
[&amp;lt;p class=&amp;quot;title&amp;quot;&amp;gt;&amp;lt;b&amp;gt;这是一个例子&amp;lt;/b&amp;gt;&amp;lt;/p&amp;gt;]

def has_six_characters(css_class):
    return css_class is not None and len(css_class) == 6
print(soup.find_all(class_=has_six_characters))
# 输出结果
[&amp;lt;p class=&amp;quot;title&amp;quot;&amp;gt;&amp;lt;b&amp;gt;这是一个例子&amp;lt;/b&amp;gt;&amp;lt;/p&amp;gt;]
[&amp;lt;a class=&amp;quot;people&amp;quot; href=&amp;quot;http://example.com/zhangsan&amp;quot; id=&amp;quot;link1&amp;quot;&amp;gt;张三&amp;lt;/a&amp;gt;, &amp;lt;a class=&amp;quot;people&amp;quot; href=&amp;quot;http://example.com/lisi&amp;quot; id=&amp;quot;link2&amp;quot;&amp;gt;李四&amp;lt;/a&amp;gt;, &amp;lt;a class=&amp;quot;people&amp;quot; href=&amp;quot;http://example.com/wangwu&amp;quot; id=&amp;quot;link3&amp;quot;&amp;gt;王五&amp;lt;/a&amp;gt;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;tag的&lt;code&gt;class&lt;/code&gt;可以是多个，每个都能用，也可以完全匹配，完全匹配时类名顺序不可变，如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;css_soup = BeautifulSoup(&#39;&amp;lt;p class=&amp;quot;dev test&amp;quot;&amp;gt;&amp;lt;/p&amp;gt;&#39;, &#39;html.parser&#39;)
print(css_soup.find_all(&amp;quot;p&amp;quot;, class_=&amp;quot;dev&amp;quot;))
print(css_soup.find_all(&amp;quot;p&amp;quot;, class_=&amp;quot;test&amp;quot;))
print(css_soup.find_all(&amp;quot;p&amp;quot;, class_=&amp;quot;dev test&amp;quot;))

# 输出结果
[&amp;lt;p class=&amp;quot;dev test&amp;quot;&amp;gt;&amp;lt;/p&amp;gt;]
[&amp;lt;p class=&amp;quot;dev test&amp;quot;&amp;gt;&amp;lt;/p&amp;gt;]
[&amp;lt;p class=&amp;quot;dev test&amp;quot;&amp;gt;&amp;lt;/p&amp;gt;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还可以通过&lt;code&gt;attrs&lt;/code&gt;来查找相关的内容，如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;print(soup.find_all(&amp;quot;a&amp;quot;, attrs={&amp;quot;class&amp;quot;: &amp;quot;people&amp;quot;}))

# 输出结果
[&amp;lt;a class=&amp;quot;people&amp;quot; href=&amp;quot;http://example.com/zhangsan&amp;quot; id=&amp;quot;link1&amp;quot;&amp;gt;张三&amp;lt;/a&amp;gt;, &amp;lt;a class=&amp;quot;people&amp;quot; href=&amp;quot;http://example.com/lisi&amp;quot; id=&amp;quot;link2&amp;quot;&amp;gt;李四&amp;lt;/a&amp;gt;, &amp;lt;a class=&amp;quot;people&amp;quot; href=&amp;quot;http://example.com/wangwu&amp;quot; id=&amp;quot;link3&amp;quot;&amp;gt;王五&amp;lt;/a&amp;gt;]
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;string参数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过 string 参数可以搜搜文档中的字符串内容，如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;print(soup.find_all(string=&amp;quot;张三&amp;quot;))
# 输出结果
[&#39;张三&#39;]

print(soup.find_all(string=[&amp;quot;张三&amp;quot;, &amp;quot;李四&amp;quot;, &amp;quot;王五&amp;quot;]))
# 输出结果
[&#39;张三&#39;, &#39;李四&#39;, &#39;王五&#39;]

print(soup.find_all(string=re.compile(&amp;quot;例子&amp;quot;)))
# 输出结果
[&#39;这是一个例子&#39;, &#39;这是一个例子&#39;]

def is_the_only_string_within_a_tag(s):
    return (s == s.parent.string)
print(soup.find_all(string=is_the_only_string_within_a_tag))
# 输出结果
[&#39;这是一个例子&#39;, &#39;这是一个例子&#39;, &#39;张三&#39;, &#39;李四&#39;, &#39;王五&#39;, &#39;...&#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;string参数还可以与其它参数混合使用，如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;print(soup.find_all(&amp;quot;a&amp;quot;, string=&amp;quot;张三&amp;quot;))

# 输出结果
[&amp;lt;a class=&amp;quot;people&amp;quot; href=&amp;quot;http://example.com/zhangsan&amp;quot; id=&amp;quot;link1&amp;quot;&amp;gt;张三&amp;lt;/a&amp;gt;]
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;limit参数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;limit参数可限制搜索的量，与mysql中的limit有些相似，如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;print(soup.find_all(&amp;quot;a&amp;quot;, limit=1))

# 输出结果
[&amp;lt;a class=&amp;quot;people&amp;quot; href=&amp;quot;http://example.com/zhangsan&amp;quot; id=&amp;quot;link1&amp;quot;&amp;gt;张三&amp;lt;/a&amp;gt;]
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;recursive参数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;recursive=False&lt;/code&gt;只搜索tag的直接子节点，如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;print(soup.html.find_all(&amp;quot;title&amp;quot;))
print(soup.html.find_all(&amp;quot;title&amp;quot;, recursive=False))

输出结果：
[&amp;lt;title&amp;gt;这是一个例子&amp;lt;/title&amp;gt;]
[]
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;find_all()&lt;/code&gt;的简写方法&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面的代码是等价的，如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;soup.find_all(&amp;quot;a&amp;quot;)
soup(&amp;quot;a&amp;quot;)

soup.title.find_all(string=True)
soup.title(string=True)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;73-find&#34;&gt;7.3 find()&lt;/h4&gt;
&lt;p&gt;find函数格式，如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;find( name , attrs , recursive , string , **kwargs )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;find()函数返回找到的第一个结果，等同于find_all()方法设置limit=1的情况，如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;print(soup.find_all(&#39;title&#39;, limit=1))
print(soup.find(&#39;title&#39;))

# 输出结果
[&amp;lt;title&amp;gt;这是一个例子&amp;lt;/title&amp;gt;]
&amp;lt;title&amp;gt;这是一个例子&amp;lt;/title&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不同的是，find_all()返回的是列表，find()返回的是字符串。&lt;/p&gt;
&lt;p&gt;目标为空时，find_all()返回[]，find()返回None。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;print(soup.find_all(&#39;test&#39;))
print(soup.find(&#39;test&#39;))

# 输出结果
[]
None
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;find()函数的简写：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;soup.head.title 等同于soup.find(&amp;quot;head&amp;quot;).find(&amp;quot;title&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;74-find_parentsfind_parent&#34;&gt;7.4 find_parents()和find_parent()&lt;/h4&gt;
&lt;p&gt;find_parents()格式如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;find_parents( name , attrs , recursive , string , **kwargs )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;find_parent()格式如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;find_parent( name , attrs , recursive , string , **kwargs )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;find_parents()用来搜索当前节点的父辈节点，find_parent() 用来搜索当前节点的父辈节点的第一个结果, 如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;string = soup.find(string=&amp;quot;张三&amp;quot;)
print(string)
print(string.find_parents(&amp;quot;a&amp;quot;))
print(string.find_parent(&amp;quot;a&amp;quot;))
print(string.find_parents(&amp;quot;p&amp;quot;, id = &amp;quot;link1&amp;quot;))

# 输出结果
张三
[&amp;lt;a class=&amp;quot;people&amp;quot; href=&amp;quot;http://example.com/zhangsan&amp;quot; id=&amp;quot;link1&amp;quot;&amp;gt;张三&amp;lt;/a&amp;gt;]
&amp;lt;a class=&amp;quot;people&amp;quot; href=&amp;quot;http://example.com/zhangsan&amp;quot; id=&amp;quot;link1&amp;quot;&amp;gt;张三&amp;lt;/a&amp;gt;
[]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从上面的结果看出，&lt;code&gt;find_parents()&lt;/code&gt;输出的是列表，&lt;code&gt;find_parent()&lt;/code&gt;输出的是字符串。还有包含id值为link1的&lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt;标签找不到。&lt;/p&gt;
&lt;h4 id=&#34;75-find_next_siblingfind_next_sibling&#34;&gt;7.5 find_next_sibling()和find_next_sibling()&lt;/h4&gt;
&lt;p&gt;find_next_sibling()格式如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;find_next_siblings( name , attrs , recursive , string , **kwargs )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;find_next_sibling()格式如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;find_next_sibling( name , attrs , recursive , string , **kwargs )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;find_next_siblings()&lt;/code&gt;方法返回所有符合条件的后面的兄弟节点, &lt;code&gt;find_next_sibling()&lt;/code&gt;只返回符合条件的后面的第一个tag节点, 举例如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;first_link = soup.a
print(first_link)
print(first_link.find_next_siblings(&amp;quot;a&amp;quot;))
first_story_paragraph = soup.find(&amp;quot;p&amp;quot;, &amp;quot;story&amp;quot;)
print(first_story_paragraph.find_next_sibling(&amp;quot;p&amp;quot;))

# 输出结果
&amp;lt;a class=&amp;quot;people&amp;quot; href=&amp;quot;http://example.com/zhangsan&amp;quot; id=&amp;quot;link1&amp;quot;&amp;gt;张三&amp;lt;/a&amp;gt;
[&amp;lt;a class=&amp;quot;people&amp;quot; href=&amp;quot;http://example.com/lisi&amp;quot; id=&amp;quot;link2&amp;quot;&amp;gt;李四&amp;lt;/a&amp;gt;, &amp;lt;a class=&amp;quot;people&amp;quot; href=&amp;quot;http://example.com/wangwu&amp;quot; id=&amp;quot;link3&amp;quot;&amp;gt;王五&amp;lt;/a&amp;gt;]
&amp;lt;p class=&amp;quot;example&amp;quot;&amp;gt;...&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;76-find_previous_sibingsfind_previous_sibing&#34;&gt;7.6 find_previous_sibings()和find_previous_sibing()&lt;/h4&gt;
&lt;p&gt;find_previous_sibings()格式如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;find_previous_siblings( name , attrs , recursive , string , **kwargs )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;find_previous_sibing()格式如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;find_previous_sibling( name , attrs , recursive , string , **kwargs )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;find_previous_siblings()&lt;/code&gt;方法返回所有符合条件的前面的兄弟节点, &lt;code&gt;find_previous_sibling()&lt;/code&gt;方法返回第一个符合条件的前面的兄弟节点, 举例如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;last_link = soup.find(&amp;quot;a&amp;quot;, id=&amp;quot;link3&amp;quot;)
print(last_link)
print(last_link.find_previous_siblings(&amp;quot;a&amp;quot;))
first_story_paragraph = soup.find(&amp;quot;p&amp;quot;, &amp;quot;story&amp;quot;)
print(first_story_paragraph.find_previous_sibling(&amp;quot;p&amp;quot;))

# 输出结果
&amp;lt;a class=&amp;quot;people&amp;quot; href=&amp;quot;http://example.com/wangwu&amp;quot; id=&amp;quot;link3&amp;quot;&amp;gt;王五&amp;lt;/a&amp;gt;
[&amp;lt;a class=&amp;quot;people&amp;quot; href=&amp;quot;http://example.com/lisi&amp;quot; id=&amp;quot;link2&amp;quot;&amp;gt;李四&amp;lt;/a&amp;gt;, &amp;lt;a class=&amp;quot;people&amp;quot; href=&amp;quot;http://example.com/zhangsan&amp;quot; id=&amp;quot;link1&amp;quot;&amp;gt;张三&amp;lt;/a&amp;gt;]
&amp;lt;p class=&amp;quot;title&amp;quot;&amp;gt;&amp;lt;b&amp;gt;这是一个例子&amp;lt;/b&amp;gt;&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;77-find_all_nextfind_next&#34;&gt;7.7 find_all_next()和find_next()&lt;/h4&gt;
&lt;p&gt;find_all_next()格式如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;find_all_next( name , attrs , recursive , string , **kwargs )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;find_next()格式如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;find_next( name , attrs , recursive , string , **kwargs )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;find_all_next()&lt;/code&gt;方法返回所有符合条件的节点, &lt;code&gt;find_next()&lt;/code&gt;方法返回第一个符合条件的节点，举例如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;first_link = soup.a
print(first_link)
print(first_link.find_all_next(string=True))
print(first_link.find_next(&amp;quot;p&amp;quot;))

# 输出结果
&amp;lt;a class=&amp;quot;people&amp;quot; href=&amp;quot;http://example.com/zhangsan&amp;quot; id=&amp;quot;link1&amp;quot;&amp;gt;张三&amp;lt;/a&amp;gt;
[&#39;张三&#39;, &#39;,\n&#39;, &#39;李四&#39;, &#39; 和\n&#39;, &#39;王五&#39;, &#39;;\n他们住在一个四合院。&#39;, &#39;\n&#39;, &#39;...&#39;, &#39;\n&#39;]
&amp;lt;p class=&amp;quot;example&amp;quot;&amp;gt;...&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;78-find_all_previousfind_previous&#34;&gt;7.8 find_all_previous()和find_previous()&lt;/h4&gt;
&lt;p&gt;find_all_previous()格式如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;find_all_previous( name , attrs , recursive , string , **kwargs )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;find_previous()格式如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;find_previous( name , attrs , recursive , string , **kwargs )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;find_all_previous()&lt;/code&gt;方法返回所有符合条件的节点, &lt;code&gt;find_previous()&lt;/code&gt;方法返回第一个符合条件的节点，举例如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;first_link = soup.a
print(first_link)
print(first_link.find_all_previous(&amp;quot;p&amp;quot;))
print(first_link.find_previous(&amp;quot;title&amp;quot;))

# 输出结果
&amp;lt;a class=&amp;quot;people&amp;quot; href=&amp;quot;http://example.com/zhangsan&amp;quot; id=&amp;quot;link1&amp;quot;&amp;gt;张三&amp;lt;/a&amp;gt;
[&amp;lt;p class=&amp;quot;story&amp;quot;&amp;gt;从前有三个人;他们的名字是
&amp;lt;a class=&amp;quot;people&amp;quot; href=&amp;quot;http://example.com/zhangsan&amp;quot; id=&amp;quot;link1&amp;quot;&amp;gt;张三&amp;lt;/a&amp;gt;,
&amp;lt;a class=&amp;quot;people&amp;quot; href=&amp;quot;http://example.com/lisi&amp;quot; id=&amp;quot;link2&amp;quot;&amp;gt;李四&amp;lt;/a&amp;gt; 和
&amp;lt;a class=&amp;quot;people&amp;quot; href=&amp;quot;http://example.com/wangwu&amp;quot; id=&amp;quot;link3&amp;quot;&amp;gt;王五&amp;lt;/a&amp;gt;;
他们住在一个四合院。&amp;lt;/p&amp;gt;, &amp;lt;p class=&amp;quot;title&amp;quot;&amp;gt;&amp;lt;b&amp;gt;这是一个例子&amp;lt;/b&amp;gt;&amp;lt;/p&amp;gt;]
&amp;lt;title&amp;gt;这是一个例子&amp;lt;/title&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;79-css&#34;&gt;7.9 CSS选择器&lt;/h4&gt;
&lt;p&gt;在 Tag 或 BeautifulSoup 对象的 .select() 方法中传入字符串参数, 即可使用CSS选择器的语法找到tag，举例如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;print(soup.select(&amp;quot;title&amp;quot;))
print(soup.select(&amp;quot;p:nth-of-type(3)&amp;quot;))

# 输出结果
[&amp;lt;title&amp;gt;这是一个例子&amp;lt;/title&amp;gt;]
[&amp;lt;p class=&amp;quot;example&amp;quot;&amp;gt;...&amp;lt;/p&amp;gt;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;找到兄弟节点标签:&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;print(soup.select(&amp;quot;#link1 ~ .people&amp;quot;))
print(soup.select(&amp;quot;#link1 + .people&amp;quot;))

# 输出结果
[&amp;lt;a class=&amp;quot;people&amp;quot; href=&amp;quot;http://example.com/lisi&amp;quot; id=&amp;quot;link2&amp;quot;&amp;gt;李四&amp;lt;/a&amp;gt;, &amp;lt;a class=&amp;quot;people&amp;quot; href=&amp;quot;http://example.com/wangwu&amp;quot; id=&amp;quot;link3&amp;quot;&amp;gt;王五&amp;lt;/a&amp;gt;]
[&amp;lt;a class=&amp;quot;people&amp;quot; href=&amp;quot;http://example.com/lisi&amp;quot; id=&amp;quot;link2&amp;quot;&amp;gt;李四&amp;lt;/a&amp;gt;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过CSS的类名查找:&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;print(soup.select(&amp;quot;.people&amp;quot;))
print(soup.select(&amp;quot;[class~=people]&amp;quot;))

# 输出结果
[&amp;lt;a class=&amp;quot;people&amp;quot; href=&amp;quot;http://example.com/zhangsan&amp;quot; id=&amp;quot;link1&amp;quot;&amp;gt;张三&amp;lt;/a&amp;gt;, &amp;lt;a class=&amp;quot;people&amp;quot; href=&amp;quot;http://example.com/lisi&amp;quot; id=&amp;quot;link2&amp;quot;&amp;gt;李四&amp;lt;/a&amp;gt;, &amp;lt;a class=&amp;quot;people&amp;quot; href=&amp;quot;http://example.com/wangwu&amp;quot; id=&amp;quot;link3&amp;quot;&amp;gt;王五&amp;lt;/a&amp;gt;]
[&amp;lt;a class=&amp;quot;people&amp;quot; href=&amp;quot;http://example.com/zhangsan&amp;quot; id=&amp;quot;link1&amp;quot;&amp;gt;张三&amp;lt;/a&amp;gt;, &amp;lt;a class=&amp;quot;people&amp;quot; href=&amp;quot;http://example.com/lisi&amp;quot; id=&amp;quot;link2&amp;quot;&amp;gt;李四&amp;lt;/a&amp;gt;, &amp;lt;a class=&amp;quot;people&amp;quot; href=&amp;quot;http://example.com/wangwu&amp;quot; id=&amp;quot;link3&amp;quot;&amp;gt;王五&amp;lt;/a&amp;gt;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过tag的id查找:&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;print(soup.select(&amp;quot;#link1&amp;quot;))
print(soup.select(&amp;quot;a#link2&amp;quot;))

# 输出结果
[&amp;lt;a class=&amp;quot;people&amp;quot; href=&amp;quot;http://example.com/zhangsan&amp;quot; id=&amp;quot;link1&amp;quot;&amp;gt;张三&amp;lt;/a&amp;gt;]
[&amp;lt;a class=&amp;quot;people&amp;quot; href=&amp;quot;http://example.com/lisi&amp;quot; id=&amp;quot;link2&amp;quot;&amp;gt;李四&amp;lt;/a&amp;gt;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同时用多种CSS选择器查询元素:&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;print(soup.select(&amp;quot;#link1,#link2&amp;quot;))

# 输出结果
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过是否存在某个属性来查找:&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;print(soup.select(&#39;a[href]&#39;))

# 输出结果
[&amp;lt;a class=&amp;quot;people&amp;quot; href=&amp;quot;http://example.com/zhangsan&amp;quot; id=&amp;quot;link1&amp;quot;&amp;gt;张三&amp;lt;/a&amp;gt;, &amp;lt;a class=&amp;quot;people&amp;quot; href=&amp;quot;http://example.com/lisi&amp;quot; id=&amp;quot;link2&amp;quot;&amp;gt;李四&amp;lt;/a&amp;gt;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过属性的值来查找:&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;print(soup.select(&#39;a[href=&amp;quot;http://example.com/zhangsan&amp;quot;]&#39;))
print(soup.select(&#39;a[href^=&amp;quot;http://example.com/&amp;quot;]&#39;))
print(soup.select(&#39;a[href$=&amp;quot;lisi&amp;quot;]&#39;))
print(soup.select(&#39;a[href*=&amp;quot;.com/wa&amp;quot;]&#39;))

# 输出结果
[&amp;lt;a class=&amp;quot;people&amp;quot; href=&amp;quot;http://example.com/zhangsan&amp;quot; id=&amp;quot;link1&amp;quot;&amp;gt;张三&amp;lt;/a&amp;gt;]
[&amp;lt;a class=&amp;quot;people&amp;quot; href=&amp;quot;http://example.com/zhangsan&amp;quot; id=&amp;quot;link1&amp;quot;&amp;gt;张三&amp;lt;/a&amp;gt;, &amp;lt;a class=&amp;quot;people&amp;quot; href=&amp;quot;http://example.com/lisi&amp;quot; id=&amp;quot;link2&amp;quot;&amp;gt;李四&amp;lt;/a&amp;gt;, &amp;lt;a class=&amp;quot;people&amp;quot; href=&amp;quot;http://example.com/wangwu&amp;quot; id=&amp;quot;link3&amp;quot;&amp;gt;王五&amp;lt;/a&amp;gt;]
[&amp;lt;a class=&amp;quot;people&amp;quot; href=&amp;quot;http://example.com/lisi&amp;quot; id=&amp;quot;link2&amp;quot;&amp;gt;李四&amp;lt;/a&amp;gt;]
[&amp;lt;a class=&amp;quot;people&amp;quot; href=&amp;quot;http://example.com/wangwu&amp;quot; id=&amp;quot;link3&amp;quot;&amp;gt;王五&amp;lt;/a&amp;gt;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;返回查找到的元素的第一个&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;print(soup.select_one(&amp;quot;.people&amp;quot;))

# 输出结果
&amp;lt;a class=&amp;quot;people&amp;quot; href=&amp;quot;http://example.com/zhangsan&amp;quot; id=&amp;quot;link1&amp;quot;&amp;gt;张三&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;8&#34;&gt;8. 修改方法&lt;/h3&gt;
&lt;h4 id=&#34;81-tag&#34;&gt;8.1 修改tag的名称和属性&lt;/h4&gt;
&lt;p&gt;修改tag的名字，改变属性的值，添加或者删除属性&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;soup = BeautifulSoup(&#39;&amp;lt;b class=&amp;quot;test&amp;quot;&amp;gt;这是一个例子&amp;lt;/b&amp;gt;&#39;, &#39;html.parser&#39;)
tag = soup.b

tag.name = &amp;quot;blockquote&amp;quot;
tag[&#39;class&#39;] = &#39;dev&#39;
tag[&#39;id&#39;] = 1
print(tag)

del tag[&#39;class&#39;]
del tag[&#39;id&#39;]
print(tag)

# 输出结果
&amp;lt;blockquote class=&amp;quot;dev&amp;quot; id=&amp;quot;1&amp;quot;&amp;gt;这是一个例子&amp;lt;/blockquote&amp;gt;
&amp;lt;blockquote&amp;gt;这是一个例子&amp;lt;/blockquote&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;82-string&#34;&gt;8.2 修改 .string&lt;/h4&gt;
&lt;p&gt;给tag的 .string 属性赋值，替代原来的内容：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;markup = &#39;&amp;lt;a href=&amp;quot;http://example.com/&amp;quot;&amp;gt;这是一个链接&amp;lt;/a&amp;gt;&#39;
soup = BeautifulSoup(markup, &#39;html.parser&#39;)

tag = soup.a
print(tag)
tag.string = &amp;quot;新链接&amp;quot;
print(tag)

# 输出结果
&amp;lt;a href=&amp;quot;http://example.com/&amp;quot;&amp;gt;这是一个链接&amp;lt;/a&amp;gt;
&amp;lt;a href=&amp;quot;http://example.com/&amp;quot;&amp;gt;新链接&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;83-append&#34;&gt;8.3 append()&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;append()&lt;/code&gt;给tag添加内容，同python append()方法：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;soup = BeautifulSoup(&amp;quot;&amp;lt;a&amp;gt;测试&amp;lt;/a&amp;gt;&amp;quot;, &#39;html.parser&#39;)
soup.a.append(&amp;quot;开发&amp;quot;)

print(soup)
print(soup.a.contents)

# 输出结果
&amp;lt;a&amp;gt;测试开发&amp;lt;/a&amp;gt;
[&#39;测试&#39;, &#39;开发&#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;84-navigablestring-new_tag&#34;&gt;8.4 NavigableString() 和 .new_tag()&lt;/h4&gt;
&lt;p&gt;添加一段文本内容或注释，用&lt;code&gt;NavigableString()&lt;/code&gt;, 如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;from bs4 import NavigableString
soup = BeautifulSoup(&amp;quot;&amp;lt;b&amp;gt;&amp;lt;/b&amp;gt;&amp;quot;, &#39;html.parser&#39;)
tag = soup.b
tag.append(&amp;quot;你好&amp;quot;)
new_string = NavigableString(&amp;quot; 我是谁&amp;quot;)
tag.append(new_string)
print(tag)
print(tag.contents)

from bs4 import Comment
new_comment = soup.new_string(&amp;quot;这是一个注释。&amp;quot;, Comment)
tag.append(new_comment)
print(tag)
print(tag.contents)

# 输出结果
&amp;lt;b&amp;gt;你好 我是谁&amp;lt;/b&amp;gt;
[&#39;你好&#39;, &#39; 我是谁&#39;]
&amp;lt;b&amp;gt;你好 我是谁&amp;lt;!--这是一个注释。--&amp;gt;&amp;lt;/b&amp;gt;
[&#39;你好&#39;, &#39; 我是谁&#39;, &#39;这是一个注释。&#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;创建一个tag用&lt;code&gt;.new_tag()&lt;/code&gt;, 如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;soup = BeautifulSoup(&amp;quot;&amp;lt;b&amp;gt;&amp;lt;/b&amp;gt;&amp;quot;, &#39;html.parser&#39;)
tag = soup.b

new_tag = soup.new_tag(&amp;quot;a&amp;quot;, href=&amp;quot;http://www.example.com&amp;quot;)
print(new_tag)
tag.append(new_tag)
print(tag)

new_tag.string = &amp;quot;看这里&amp;quot;
print(tag)

# 输出结果
&amp;lt;a href=&amp;quot;http://www.example.com&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;
&amp;lt;b&amp;gt;&amp;lt;a href=&amp;quot;http://www.example.com&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;/b&amp;gt;
&amp;lt;b&amp;gt;&amp;lt;a href=&amp;quot;http://www.example.com&amp;quot;&amp;gt;看这里&amp;lt;/a&amp;gt;&amp;lt;/b&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;85-insert&#34;&gt;8.5 insert()&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;insert()&lt;/code&gt;将内容插入到指定位置，如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;markup = &#39;&amp;lt;a href=&amp;quot;http://example.com/&amp;quot;&amp;gt;这&amp;lt;i&amp;gt;是&amp;lt;/i&amp;gt;一个例子&amp;lt;/i&amp;gt;&amp;lt;/a&amp;gt;&#39;
soup = BeautifulSoup(markup, &#39;html.parser&#39;)
tag = soup.a

tag.insert(1, &amp;quot;不&amp;quot;)
print(tag)
print(tag.contents)

# 输出结果
&amp;lt;a href=&amp;quot;http://example.com/&amp;quot;&amp;gt;这不&amp;lt;i&amp;gt;是&amp;lt;/i&amp;gt;一个例子&amp;lt;/a&amp;gt;
[&#39;这&#39;, &#39;不&#39;, &amp;lt;i&amp;gt;是&amp;lt;/i&amp;gt;, &#39;一个例子&#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;86-insert_before-insert_after&#34;&gt;8.6 insert_before() 和 insert_after()&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;insert_before()&lt;/code&gt;在当前tag或文本节点前插入内容，&lt;code&gt;insert_after()&lt;/code&gt;方法在当前tag或文本节点后插入内容，如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;soup = BeautifulSoup(&amp;quot;&amp;lt;b&amp;gt;吃苹果&amp;lt;/b&amp;gt;&amp;quot;, &#39;html.parser&#39;)
tag = soup.new_tag(&amp;quot;i&amp;quot;)
tag.string = &amp;quot;不要&amp;quot;
soup.b.string.insert_before(tag)
print(soup.b)
soup.b.i.insert_after(soup.new_string(&amp;quot;不要&amp;quot;))
print(soup.b)

# 输出结果
&amp;lt;b&amp;gt;&amp;lt;i&amp;gt;不要&amp;lt;/i&amp;gt;吃苹果&amp;lt;/b&amp;gt;
&amp;lt;b&amp;gt;&amp;lt;i&amp;gt;不要&amp;lt;/i&amp;gt;不要吃苹果&amp;lt;/b&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;87-clear&#34;&gt;8.7 clear()&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;clear()&lt;/code&gt;方法移除当前tag的内容:&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;markup = &#39;&amp;lt;a href=&amp;quot;http://example.com/&amp;quot;&amp;gt;这是一个例子&amp;lt;/a&amp;gt;&#39;
soup = BeautifulSoup(markup, &#39;html.parser&#39;)
tag = soup.a
print(tag)
tag.clear()
print(tag)

# 输出结果
&amp;lt;a href=&amp;quot;http://example.com/&amp;quot;&amp;gt;这是一个例子&amp;lt;/a&amp;gt;
&amp;lt;a href=&amp;quot;http://example.com/&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;88-extract&#34;&gt;8.8 extract()&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;extract()&lt;/code&gt;方法将当前tag移除,并作为方法结果返回:&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;markup = &#39;&amp;lt;a href=&amp;quot;http://example.com/&amp;quot;&amp;gt;这是一个&amp;lt;i&amp;gt;例子&amp;lt;/i&amp;gt;&amp;lt;/a&amp;gt;&#39;
soup = BeautifulSoup(markup, &#39;html.parser&#39;)
a_tag = soup.a
i_tag = soup.i.extract()
print(a_tag)
print(i_tag)
print(i_tag.parent)

# 输出结果
&amp;lt;a href=&amp;quot;http://example.com/&amp;quot;&amp;gt;这是一个&amp;lt;/a&amp;gt;
&amp;lt;i&amp;gt;例子&amp;lt;/i&amp;gt;
None
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;89-decompose&#34;&gt;8.9 decompose()&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;decompose()&lt;/code&gt;方法将当前节点移除并完全销毁:&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;markup = &#39;&amp;lt;a href=&amp;quot;http://example.com/&amp;quot;&amp;gt;这是一个&amp;lt;i&amp;gt;例子&amp;lt;/i&amp;gt;&amp;lt;/a&amp;gt;&#39;
soup = BeautifulSoup(markup, &#39;html.parser&#39;)
a_tag = soup.a
i_tag = soup.i.decompose()
print(a_tag)
print(i_tag)

# 输出结果
&amp;lt;a href=&amp;quot;http://example.com/&amp;quot;&amp;gt;这是一个&amp;lt;/a&amp;gt;
None
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;810-replace_with&#34;&gt;8.10 replace_with()&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;replace_with()&lt;/code&gt;方法移除某段内容,并用新tag或文本节点替代它:&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;markup = &#39;&amp;lt;a href=&amp;quot;http://example.com/&amp;quot;&amp;gt;这是一个&amp;lt;i&amp;gt;例子&amp;lt;/i&amp;gt;&amp;lt;/a&amp;gt;&#39;
soup = BeautifulSoup(markup, &#39;html.parser&#39;)
a_tag = soup.a
new_tag = soup.new_tag(&amp;quot;b&amp;quot;)
new_tag.string = &amp;quot;错误&amp;quot;
a_tag.i.replace_with(new_tag)
print(a_tag)

# 输出结果
&amp;lt;a href=&amp;quot;http://example.com/&amp;quot;&amp;gt;这是一个&amp;lt;b&amp;gt;错误&amp;lt;/b&amp;gt;&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;811-wrap&#34;&gt;8.11 wrap()&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;wrap()&lt;/code&gt;方法可以对指定的tag元素进行包装,并返回包装后的结果:&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;soup = BeautifulSoup(&amp;quot;&amp;lt;p&amp;gt;这是一个例子&amp;lt;/p&amp;gt;&amp;quot;, &#39;html.parser&#39;)
print(soup.p.string.wrap(soup.new_tag(&amp;quot;b&amp;quot;)))
print(soup.p.wrap(soup.new_tag(&amp;quot;div&amp;quot;)))

# 输出结果
&amp;lt;b&amp;gt;这是一个例子&amp;lt;/b&amp;gt;
&amp;lt;div&amp;gt;&amp;lt;p&amp;gt;&amp;lt;b&amp;gt;这是一个例子&amp;lt;/b&amp;gt;&amp;lt;/p&amp;gt;&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;812-unwrap&#34;&gt;8.12 unwrap()&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;wrap()&lt;/code&gt;方法将移除tag内的所有tag标签:&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;markup = &#39;&amp;lt;a href=&amp;quot;http://example.com/&amp;quot;&amp;gt;这是一个&amp;lt;i&amp;gt;例子&amp;lt;/i&amp;gt;&amp;lt;/a&amp;gt;&#39;
soup = BeautifulSoup(markup, &#39;html.parser&#39;)
a_tag = soup.a
i_tag = a_tag.i.unwrap()
print(a_tag)
print(i_tag)

# 输出结果
&amp;lt;a href=&amp;quot;http://example.com/&amp;quot;&amp;gt;这是一个例子&amp;lt;/a&amp;gt;
&amp;lt;i&amp;gt;&amp;lt;/i&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;9&#34;&gt;9. 输出&lt;/h3&gt;
&lt;h4 id=&#34;91&#34;&gt;9.1 格式化输出&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;prettify()&lt;/code&gt;方法将Beautiful Soup格式化输出，如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;markup = &#39;&amp;lt;a href=&amp;quot;http://example.com/&amp;quot;&amp;gt;这是一个&amp;lt;i&amp;gt;例子&amp;lt;/i&amp;gt;&amp;lt;/a&amp;gt;&#39;
soup = BeautifulSoup(markup, &#39;html.parser&#39;)
print(soup.prettify())

# 输出结果
&amp;lt;a href=&amp;quot;http://example.com/&amp;quot;&amp;gt;
 这是一个
 &amp;lt;i&amp;gt;
  例子
 &amp;lt;/i&amp;gt;
&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;92&#34;&gt;9.2 压缩输出&lt;/h4&gt;
&lt;p&gt;使用&lt;code&gt;str()&lt;/code&gt;得到一个字符串，如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;markup = &#39;&amp;lt;a href=&amp;quot;http://example.com/&amp;quot;&amp;gt;这是一个&amp;lt;i&amp;gt;例子&amp;lt;/i&amp;gt;&amp;lt;/a&amp;gt;&#39;
soup = BeautifulSoup(markup, &#39;html.parser&#39;)
print(str(soup))

# 输出结果
&amp;lt;a href=&amp;quot;http://example.com/&amp;quot;&amp;gt;这是一个&amp;lt;i&amp;gt;例子&amp;lt;/i&amp;gt;&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;93&#34;&gt;9.3 输出格式&lt;/h4&gt;
&lt;p&gt;转化Beautiful Soup中的HTML特殊字符，如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;soup = BeautifulSoup(&amp;quot;&amp;amp;ldquo;Dammit!&amp;amp;rdquo; he said.&amp;quot;,&#39;html.parser&#39;)
print(str(soup))

# 输出结果
“Dammit!” he said.
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;94-get_text&#34;&gt;9.4 get_text()&lt;/h4&gt;
&lt;p&gt;得到tag中的文本内容，使用&lt;code&gt;get_text()&lt;/code&gt;, 如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;markup = &#39;&amp;lt;a href=&amp;quot;http://example.com/&amp;quot;&amp;gt; 这是一个&amp;lt;i&amp;gt;例子&amp;lt;/i&amp;gt; &amp;lt;/a&amp;gt;&#39;
soup = BeautifulSoup(markup, &#39;html.parser&#39;)
print(soup.get_text())
print(soup.i.get_text())

# 输出结果
 这是一个例子 
例子
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以通过参数指定tag的文本内容的分隔符:&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;print(soup.get_text(&amp;quot;|&amp;quot;))

# 输出结果
 这是一个|例子| 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还可以去除获得文本内容的前后空格:&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;print(soup.get_text(&amp;quot;|&amp;quot;, strip=True))

# 输出结果
这是一个|例子
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用&lt;code&gt;stripped_strings&lt;/code&gt;生成器,以列表存储获得的文本:&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;print([text for text in soup.stripped_strings])

# 输出结果
[&#39;这是一个&#39;, &#39;例子&#39;]
&lt;/code&gt;&lt;/pre&gt;</description>  
      <pubDate>2025-10-09 17:54:40</pubDate>  
      <link>https://testpoo.github.io/BeautifulSoup简介.html</link>  
      <guid isPermaLink="true">https://testpoo.github.io/BeautifulSoup简介.html</guid>
       
      <category>测试</category> 
      
    </item>
    
    <item> 
      <title>tkinter教程</title>  
      <description>&lt;div class=&#34;toc&#34;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#tkinter&#34;&gt;Tkinter简介&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#tkinter_1&#34;&gt;Tkinter用法详解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_1&#34;&gt;常用控件和属性&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#_2&#34;&gt;控件类型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_3&#34;&gt;控件基本属性&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_4&#34;&gt;主窗口&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#_5&#34;&gt;窗口常用方法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_6&#34;&gt;设置窗的位置&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#label&#34;&gt;Label标签控件&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#_7&#34;&gt;标签添加背景图&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#message&#34;&gt;Message控件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#button&#34;&gt;Button按钮控件&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#button_1&#34;&gt;Button 控件的常用属性&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_8&#34;&gt;扩展：按钮的布局&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#entry&#34;&gt;Entry输入控件&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#_9&#34;&gt;基本属性&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_10&#34;&gt;动态数据类型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_11&#34;&gt;常用方法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#entry_1&#34;&gt;Entry控件验证功能&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#spinbox&#34;&gt;Spinbox 高级输入框&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#values&#34;&gt;若不是数字，而是字符串形式的选项值，则采用values参数以元组的形式进行传参，如下所示：&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#text&#34;&gt;Text 文本控件&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#_12&#34;&gt;基本属性&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_13&#34;&gt;基本方法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#listboxcombobox&#34;&gt;列表框(ListBox)和组合框(Combobox)&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#listbox&#34;&gt;Listbox控件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_14&#34;&gt;增加滚动条和删除功能&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#stringvar&#34;&gt;StringVar() 添加列表选项&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#combobox&#34;&gt;Combobox控件&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#radiobuttoncheckbutton&#34;&gt;单选框(Radiobutton)和多选框按钮(Checkbutton)&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#radiobutton&#34;&gt;Radiobutton单选框按钮控件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#checkbutton&#34;&gt;Checkbutton复选框控件&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#scale&#34;&gt;Scale控件&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#scale_1&#34;&gt;Scale 控件常用基本属性&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#scale_2&#34;&gt;Scale 常用方法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#canvas&#34;&gt;Canvas画布控件&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#canvas_1&#34;&gt;Canvas控件基本属性&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#canvas_2&#34;&gt;Canvas控件绘图常用方法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_15&#34;&gt;绘制直线&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#menu&#34;&gt;Menu菜单控件&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#_16&#34;&gt;创建主目录菜单&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_17&#34;&gt;创建下拉菜单&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_18&#34;&gt;创建弹出菜单栏&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#scrollbar&#34;&gt;Scrollbar滚动条控件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#event&#34;&gt;Event事件处理&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#_19&#34;&gt;事件绑定方法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_20&#34;&gt;常用事件类型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#event_1&#34;&gt;Event事件对象&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#packgridplace&#34;&gt;布局管理器（pack，grid，place）&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#pack&#34;&gt;pack()&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#grid&#34;&gt;grid()&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#place&#34;&gt;place()&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_21&#34;&gt;布局管理控件&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#frame&#34;&gt;Frame控件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#labelframe&#34;&gt;LabelFrame控件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#panedwindow&#34;&gt;PanedWindow控件&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_22&#34;&gt;对话框控件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#notebook&#34;&gt;Notebook&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_23&#34;&gt;构建桌面软件模板&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_24&#34;&gt;附录&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h3 id=&#34;tkinter&#34;&gt;Tkinter简介&lt;/h3&gt;
&lt;p&gt;tkinter（Tk interface）是 Python 的标准 GUI 库，支持跨平台的 GUI 程序开发。tkinter 适合小型的 GUI 程序编写，也特别适合初学者学习 GUI 编程。&lt;/p&gt;
&lt;h3 id=&#34;tkinter_1&#34;&gt;Tkinter用法详解&lt;/h3&gt;
&lt;p&gt;一个最简单的 Tkinter 程序至少应包含以下四个部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;导入 tkinter 模块&lt;/li&gt;
&lt;li&gt;创建主窗口，也称 root 窗口（即根窗口）&lt;/li&gt;
&lt;li&gt;添加人机交互控件，同时编写相应的事件函数&lt;/li&gt;
&lt;li&gt;通过主循环（mainloop）来显示主窗口&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以下是一个简单的例子： &lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;# coding=utf-8

import tkinter as tk

root_window =tk.Tk()
# 设置窗口title
root_window.title(&#39;我的第一个Tkinter程序&#39;)
# 设置窗口大小:宽x高,注,此处不能为 &amp;quot;*&amp;quot;,必须使用 &amp;quot;x&amp;quot;
root_window.geometry(&#39;450x300&#39;)
# 更改左上角窗口的的icon图标
root_window.iconbitmap(&#39;favicon.ico&#39;)
# 设置主窗口的背景颜色,颜色值可以是英文单词，或者颜色值的16进制数,除此之外还可以使用Tk内置的颜色常量
root_window[&amp;quot;background&amp;quot;] = &amp;quot;#C9C9C9&amp;quot;
# 添加文本内,设置字体的前景色和背景色，和字体类型、大小
text=tk.Label(root_window,text=&amp;quot;破污噗，欢迎您&amp;quot;,bg=&amp;quot;yellow&amp;quot;,fg=&amp;quot;red&amp;quot;,font=(&#39;Times&#39;, 20, &#39;bold italic&#39;))
# 将文本内容放置在主窗口内
text.pack()
# 添加按钮，以及按钮的文本，并通过command 参数设置关闭窗口的功能
button=tk.Button(root_window,text=&amp;quot;关闭&amp;quot;,command=root_window.quit)
# 将按钮放置在主窗口内
button.pack(side=&amp;quot;bottom&amp;quot;)
#进入主循环，显示主窗口
root_window.mainloop()
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;_1&#34;&gt;常用控件和属性&lt;/h3&gt;
&lt;h4 id=&#34;_2&#34;&gt;控件类型&lt;/h4&gt;
&lt;p&gt;下表列出了 Tkinter 中常用的控件：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;控件类型&lt;/th&gt;
&lt;th&gt;控件名称&lt;/th&gt;
&lt;th&gt;控件作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Button&lt;/td&gt;
&lt;td&gt;按钮&lt;/td&gt;
&lt;td&gt;点击按钮时触发/执行一些事件（函数）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Canvas&lt;/td&gt;
&lt;td&gt;画布&lt;/td&gt;
&lt;td&gt;提供绘制图，比如直线、矩形、多边形等&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Checkbutton&lt;/td&gt;
&lt;td&gt;复选框&lt;/td&gt;
&lt;td&gt;多项选择按钮，用于在程序中提供多项选择框&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Entry&lt;/td&gt;
&lt;td&gt;文本框输入框&lt;/td&gt;
&lt;td&gt;用于接收单行文本输入&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Frame&lt;/td&gt;
&lt;td&gt;框架（容器）控件&lt;/td&gt;
&lt;td&gt;定义一个窗体（根窗口也是一个窗体），用于承载其他控件，即作为其他控件的容器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Lable&lt;/td&gt;
&lt;td&gt;标签控件&lt;/td&gt;
&lt;td&gt;用于显示单行文本或者图片&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;LableFrame&lt;/td&gt;
&lt;td&gt;容器控件&lt;/td&gt;
&lt;td&gt;一个简单的容器控件，常用于复杂的窗口布局。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Listbox&lt;/td&gt;
&lt;td&gt;列表框控件&lt;/td&gt;
&lt;td&gt;以列表的形式显示文本&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Menu&lt;/td&gt;
&lt;td&gt;菜单控件&lt;/td&gt;
&lt;td&gt;菜单组件（下拉菜单和弹出菜单）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Menubutton&lt;/td&gt;
&lt;td&gt;菜单按钮控件&lt;/td&gt;
&lt;td&gt;用于显示菜单项&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Message&lt;/td&gt;
&lt;td&gt;信息控件&lt;/td&gt;
&lt;td&gt;用于显示多行不可编辑的文本，与 Label控件类似，增加了自动分行的功能&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;messageBox&lt;/td&gt;
&lt;td&gt;消息框控件&lt;/td&gt;
&lt;td&gt;定义与用户交互的消息对话框&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;OptionMenu&lt;/td&gt;
&lt;td&gt;选项菜单&lt;/td&gt;
&lt;td&gt;下拉菜单&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;PanedWindow&lt;/td&gt;
&lt;td&gt;窗口布局管理组件&lt;/td&gt;
&lt;td&gt;为组件提供一个框架，允许用户自己划分窗口空间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Radiobutton&lt;/td&gt;
&lt;td&gt;单选框&lt;/td&gt;
&lt;td&gt;单项选择按钮，只允许从多个选项中选择一项&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Scale&lt;/td&gt;
&lt;td&gt;进度条控件&lt;/td&gt;
&lt;td&gt;定义一个线性“滑块”用来控制范围，可以设定起始值和结束值，并显示当前位置的精确值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Spinbox&lt;/td&gt;
&lt;td&gt;高级输入框&lt;/td&gt;
&lt;td&gt;Entry 控件的升级版，可以通过该组件的上、下箭头选择不同的值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Scrollbar&lt;/td&gt;
&lt;td&gt;滚动条&lt;/td&gt;
&lt;td&gt;默认垂直方向，鼠标拖动改变数值，可以和 Text、Listbox、Canvas等控件配合使用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Text&lt;/td&gt;
&lt;td&gt;多行文本框&lt;/td&gt;
&lt;td&gt;接收或输出多行文本内容&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Toplevel&lt;/td&gt;
&lt;td&gt;子窗口&lt;/td&gt;
&lt;td&gt;在创建一个独立于主窗口之外的子窗口，位于主窗口的上一层，可作为其他控件的容器&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;_3&#34;&gt;控件基本属性&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性名称&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;anchor&lt;/td&gt;
&lt;td&gt;定义控件或者文字信息在窗口内的位置&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;bg&lt;/td&gt;
&lt;td&gt;bg 是 background 的缩写，用来定义控件的背景颜色，参数值可以颜色的十六进制数，或者颜色英文单词&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;bitmap&lt;/td&gt;
&lt;td&gt;定义显示在控件内的位图文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;borderwidth&lt;/td&gt;
&lt;td&gt;定于控件的边框宽度，单位是像素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;command&lt;/td&gt;
&lt;td&gt;该参数用于执行事件函数，比如单击按钮时执行特定的动作，可将执行用户自定义的函数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;cursor&lt;/td&gt;
&lt;td&gt;当鼠标指针移动到控件上时，定义鼠标指针的类型，字符换格式，参数值有 crosshair（十字光标）watch（待加载圆圈）plus（加号）arrow（箭头）等&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;font&lt;/td&gt;
&lt;td&gt;若控件支持设置标题文字，就可以使用此属性来定义，它是一个数组格式的参数 (字体,大小，字体样式)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;fg&lt;/td&gt;
&lt;td&gt;fg 是 foreground 的缩写，用来定义控件的前景色，也就是字体的颜色&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;height&lt;/td&gt;
&lt;td&gt;该参数值用来设置控件的高度，文本控件以字符的数目为高度（px），其他控件则以像素为单位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;image&lt;/td&gt;
&lt;td&gt;定义显示在控件内的图片文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;justify&lt;/td&gt;
&lt;td&gt;定义多行文字的排列方式，此属性可以是 LEFT/CENTER/RIGHT&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;padx/pady&lt;/td&gt;
&lt;td&gt;定义控件内的文字或者图片与控件边框之间的水平/垂直距离&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;relief&lt;/td&gt;
&lt;td&gt;定义控件的边框样式，参数值为FLAT（平的）/RAISED（凸起的）/SUNKEN（凹陷的）/GROOVE（沟槽桩边缘）/RIDGE（脊状边缘）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;text&lt;/td&gt;
&lt;td&gt;定义控件的标题文字&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;state&lt;/td&gt;
&lt;td&gt;控制控件是否处于可用状态，参数值默认为 NORMAL/DISABLED，默认为 NORMAL（正常的）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;width&lt;/td&gt;
&lt;td&gt;用于设置控件的宽度，使用方法与 height 相同&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;_4&#34;&gt;主窗口&lt;/h3&gt;
&lt;h4 id=&#34;_5&#34;&gt;窗口常用方法&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;window.title(&#34;my title&#34;)&lt;/td&gt;
&lt;td&gt;接受一个字符串参数，为窗口起一个标题&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;window.resizable()&lt;/td&gt;
&lt;td&gt;是否允许用户拉伸主窗口大小，默认为可更改，当设置为 resizable(0,0)或者resizable(False,False)时不可更改&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;window.geometry()&lt;/td&gt;
&lt;td&gt;设定主窗口的大小以及位置，当参数值为 None 时表示获取窗口的大小和位置信息。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;window.quit()&lt;/td&gt;
&lt;td&gt;关闭当前窗口&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;window.update()&lt;/td&gt;
&lt;td&gt;刷新当前窗口&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;window.mainloop()&lt;/td&gt;
&lt;td&gt;设置窗口主循环，使窗口循环显示（一直显示，直到窗口被关闭）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;window.iconbitmap()&lt;/td&gt;
&lt;td&gt;设置窗口左上角的图标（图标是.ico文件类型）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;window.config(background =&#34;red&#34;)&lt;/td&gt;
&lt;td&gt;设置窗口的背景色为红色，也可以接受 16 进制的颜色值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;window.minsize(50,50)&lt;/td&gt;
&lt;td&gt;设置窗口被允许调整的最小范围，即宽和高各50&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;window.maxsize(400,400)&lt;/td&gt;
&lt;td&gt;设置窗口被允许调整的最大范围，即宽和高各400&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;window.attributes(&#34;-alpha&#34;,0.5)&lt;/td&gt;
&lt;td&gt;用来设置窗口的一些属性，比如透明度（-alpha）、是否置顶（-topmost）即将主屏置于其他图标之上、是否全屏（-fullscreen）全屏显示等&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;window.state(&#34;normal&#34;)&lt;/td&gt;
&lt;td&gt;用来设置窗口的显示状态，参数值 normal（正常显示），icon（最小化），zoomed（最大化），&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;window.withdraw()&lt;/td&gt;
&lt;td&gt;用来隐藏主窗口，但不会销毁窗口。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;window.iconify()&lt;/td&gt;
&lt;td&gt;设置窗口最小化&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;window.deiconify()&lt;/td&gt;
&lt;td&gt;将窗口从隐藏状态还原&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;window.winfo_screenwidth()&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;window.winfo_screenheight()&lt;/td&gt;
&lt;td&gt;获取电脑屏幕的分辨率（尺寸）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;window.winfo_width()&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;window.winfo_height()&lt;/td&gt;
&lt;td&gt;获取窗口的大小，同样也适用于其他控件，但是使用前需要使用 window.update() 刷新屏幕，否则返回值为1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;window.protocol(&#34;协议名&#34;,回调函数)&lt;/td&gt;
&lt;td&gt;启用协议处理机制，常用协议有 WN_DELETE_WINDOW，当用户点击关闭窗口时，窗口不会关闭，而是触发回调函数。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;下面是一个简单地例子：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;import tkinter as tk

window =tk.Tk()
#设置窗口title
window.title(&#39;破污噗&#39;)
#设置窗口大小:宽x高,注,此处不能为 &amp;quot;*&amp;quot;,必须使用 &amp;quot;x&amp;quot;
window.geometry(&#39;450x300&#39;)
# 获取电脑屏幕的大小
print(&amp;quot;电脑的分辨率是%dx%d&amp;quot;%(window.winfo_screenwidth(),window.winfo_screenheight()))
# 要求窗口的大小，必须先刷新一下屏幕
window.update()
print(&amp;quot;窗口的分辨率是%dx%d&amp;quot;%(window.winfo_width(),window.winfo_height()))
# 如使用该函数则窗口不能被拉伸
# window.resizable(0,0)
# 改变背景颜色
window.config(background=&amp;quot;#6fb765&amp;quot;)
# 设置窗口处于顶层
window.attributes(&#39;-topmost&#39;,True)
# 设置窗口的透明度
window.attributes(&#39;-alpha&#39;,1)
# 设置窗口被允许最大调整的范围，与resizble()冲突
window.maxsize(600,600)
# 设置窗口被允许最小调整的范围，与resizble()冲突
window.minsize(50,50)
#更改左上角窗口的的icon图标,加载C语言中文网logo标
window.iconbitmap(&#39;favicon.ico&#39;)
#添加文本内容,并对字体添加相应的格式 font(字体,字号,&amp;quot;字体类型&amp;quot;)
text=tk.Label(window,text=&amp;quot;亲爱的读者,你好~&amp;quot;,bg=&amp;quot;yellow&amp;quot;,fg=&amp;quot;red&amp;quot;,font=(&#39;Times&#39;, 15, &#39;bold italic underline&#39;))
#将文本内容放置在主窗口内
text.pack()
# 添加按钮，以及按钮的文本，并通过command 参数设置关闭窗口的功能
button=tk.Button(window,text=&amp;quot;关闭&amp;quot;,command=window.quit)
# 将按钮放置在主窗口内
button.pack(side=&amp;quot;bottom&amp;quot;)
#进入主循环，显示主窗口
window.mainloop()

程序输出结果：

电脑的分辨率是1536x864
窗口的分辨率是450x300
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;_6&#34;&gt;设置窗的位置&lt;/h4&gt;
&lt;p&gt;通过窗口对象的 geometry() 方法即可改变主窗口的位置，其语法格式如下： &lt;/p&gt;
&lt;p&gt;&lt;code&gt;geometry(&#39;450x400+300+200&#39;)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;上述代码表示，设置主窗口的宽度为 450，高度为 400，同时窗口距离左边屏幕的距离为 300（以像素为单位），距离屏幕顶部的距离为 200，这里我们将带“+”的参数值称为“位置参数”，当然，您也可以将它们设置为负数，如下所示：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;geometry(&#39;+-1500+-2000&#39;)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;当设置了一个超过屏幕的负参数值时，主窗口会被移动至“屏幕之外”，此时就看不到主窗口了，这也是隐藏窗口的一种方法。&lt;/p&gt;
&lt;h3 id=&#34;label&#34;&gt;Label标签控件&lt;/h3&gt;
&lt;p&gt;Label（标签）控件，主要用来显示窗口中的文本或者图像，并且不同的 Lable（标签）允许设置各自不同的背景图片。下面对 Label（标签）的常用属性做简单介绍：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性名称&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;anchor&lt;/td&gt;
&lt;td&gt;控制文本（或图像）在 Label 中显示的位置（方位），通过方位的英文字符串缩写（n、ne、e、se、s、sw、w、nw、center）实现定位，默认为居中（center）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;bg&lt;/td&gt;
&lt;td&gt;用来设置背景色&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;bd&lt;/td&gt;
&lt;td&gt;即 borderwidth 用来指定 Label 控件的边框宽度，单位为像素，默认为 2 个像素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;bitmap&lt;/td&gt;
&lt;td&gt;指定显示在 Label 控件上的位图，若指定了 image 参数，则该参数会被忽略&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;compound&lt;/td&gt;
&lt;td&gt;控制 Lable 中文本和图像的混合模式，若选项设置为 CENTER，则文本显示在图像上，如果将选项设置为 BOTTOM、LEFT、RIGHT、TOP，则图像显示在文本旁边。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;cursor&lt;/td&gt;
&lt;td&gt;指定当鼠标在 Label 上掠过的时候，鼠标的的显示样式，参数值为 arrow、circle、cross、plus&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;disableforeground&lt;/td&gt;
&lt;td&gt;指定当 Label 设置为不可用状态的时候前景色的颜色&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;font&lt;/td&gt;
&lt;td&gt;指定 Lable 中文本的 (字体,大小,样式）元组参数格式，一个 Lable 只能设置一种字体&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;fg&lt;/td&gt;
&lt;td&gt;设置 Label 的前景色&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;height/width&lt;/td&gt;
&lt;td&gt;设置 Lable 的高度/宽度，如果 Lable 显示的是文本，那么单位是文本单元，如果 Label 显示的是图像，那么单位就是像素，如果不设置，Label 会自动根据内容来计算出标签的高度&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;highlightbackground&lt;/td&gt;
&lt;td&gt;当 Label 没有获得焦点的时候高亮边框的颜色，系统的默认是标准背景色&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;highlightcolor&lt;/td&gt;
&lt;td&gt;指定当 Lable 获得焦点的话时候高亮边框的颜色，系统默认为0，不带高亮边框&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;image&lt;/td&gt;
&lt;td&gt;指定 Label 显示的图片，一般是 PhotoImage、BitmapImage 的对象&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;justify&lt;/td&gt;
&lt;td&gt;表示多行文本的对齐方式，参数值为 left、right、center，注意文本的位置取决于 anchor 选项&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;padx/pady&lt;/td&gt;
&lt;td&gt;padx 指定 Label 水平方向上的间距（即内容和边框间），pady 指定 Lable 水平方向上的间距（内容和边框间的距离）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;relief&lt;/td&gt;
&lt;td&gt;指定边框样式，默认值是 &#34;flat&#34;，其他参数值有 &#34;groove&#34;、&#34;raised&#34;、&#34;ridge&#34;、&#34;solid&#34;或者&#34;sunken&#34;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;state&lt;/td&gt;
&lt;td&gt;该参数用来指定 Lable 的状态，默认值为&#34;normal&#34;（正常状态），其他可选参数值有&#34;active&#34;和&#34;disabled&#34;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;takefocus&lt;/td&gt;
&lt;td&gt;默认值为False，如果是 True，表示该标签接受输入焦点&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;text&lt;/td&gt;
&lt;td&gt;用来指定 Lable 显示的文本，注意文本内可以包含换行符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;underline&lt;/td&gt;
&lt;td&gt;给指定的字符添加下划线，默认值为 -1 表示不添加，当设置为 1 时，表示给第二个文本字符添加下划线。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;wraplength&lt;/td&gt;
&lt;td&gt;将 Label 显示的文本分行，该参数指定了分行后每一行的长度，默认值为 0&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;下面是一个简单的例子：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;import tkinter as tk
win = tk.Tk()
win.title(&amp;quot;破污噗&amp;quot;)
win.geometry(&#39;400x200&#39;)
win.iconbitmap(&#39;favicon.ico&#39;)
# 若内容是文字则以字符为单位，图像则以像素为单位
label = tk.Label(win, text=&amp;quot;网址：www.baidu.com&amp;quot;,font=(&#39;宋体&#39;,20, &#39;bold italic&#39;),bg=&amp;quot;#7CCD7C&amp;quot;,
                 # 设置标签内容区大小
                 width=30,height=5,
                 # 设置填充区距离、边框宽度和其样式（凹陷式）
                 padx=10, pady=15, borderwidth=10, relief=&amp;quot;sunken&amp;quot;)
label.pack()
win.mainloop()
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;_7&#34;&gt;标签添加背景图&lt;/h4&gt;
&lt;p&gt;下面是一个简单的例子： &lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;import tkinter as  tk

win = tk.Tk()
win.title(&amp;quot;破污噗&amp;quot;)
win.iconbitmap(&#39;favicon.ico&#39;)

#显示图片
photo = tk.PhotoImage(file = &#39;pic.png&#39;)
# 将图片放在主窗口的右边
lab =tk.Label(win,image=photo).pack(side=&amp;quot;right&amp;quot;)

# 显示文字，设置文本格式
text = &amp;quot;小姐姐,\n&amp;quot;\
       &amp;quot;今天天气不错,\n &amp;quot;\
       &amp;quot;出来吃个饭吧~&amp;quot;
lab_text =tk.Label(win,text=text,fg =&#39;#7CCD7C&#39;,font=(&#39;微软雅黑&#39;,15,&#39;italic&#39;),justify=&#39;left&#39;,padx=10).pack(side=&#39;left&#39;)
win.mainloop()
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;message&#34;&gt;Message控件&lt;/h3&gt;
&lt;p&gt;Message 控件与 Label 控件的功能类似，它主要用来显示多行不可编辑的文本信息，与 Label 的不同之处在于该控件增加了自动分行的功能。下面对它做简单的介绍，示例如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;from tkinter import *
#创建主窗口
win = Tk()
win.config(bg=&#39;#8DB6CD&#39;)
win.title(&amp;quot;破污噗&amp;quot;)
win.geometry(&#39;400x300&#39;)
win.iconbitmap(&#39;favicon.ico&#39;)
txt = &amp;quot;小姐姐，今天天气不错，出来吃个饭吧~&amp;quot;
msg = Message (win, text=txt,width =60,font=(&#39;微软雅黑&#39;,10,&#39;bold&#39;))
msg .pack(side=LEFT)
#开始程序循环
win .mainloop ()
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;button&#34;&gt;Button按钮控件&lt;/h3&gt;
&lt;p&gt;Button 控件通过用户点击按钮的行为来执行回调函数，是 Button 控件的主要功用。它可以包含文本、图像、位图，并通过command参数回调函数。&lt;/p&gt;
&lt;h4 id=&#34;button_1&#34;&gt;Button 控件的常用属性&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;anchor&lt;/td&gt;
&lt;td&gt;控制文本所在的位置，默认为中心位置（CENTER）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;activebackground&lt;/td&gt;
&lt;td&gt;当鼠标放在按钮上时候，按钮的背景颜色&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;activeforeground&lt;/td&gt;
&lt;td&gt;当鼠标放在按钮上时候，按钮的前景色&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;bd&lt;/td&gt;
&lt;td&gt;按钮边框的大小，默认为 2 个像素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;bg&lt;/td&gt;
&lt;td&gt;按钮的背景色&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;command&lt;/td&gt;
&lt;td&gt;用来执行按钮关联的回调函数。当按钮被点击时，执行该函数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;fg&lt;/td&gt;
&lt;td&gt;按钮的前景色&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;font&lt;/td&gt;
&lt;td&gt;按钮文本的字体样样式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;height&lt;/td&gt;
&lt;td&gt;按钮的高度&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;highlightcolor&lt;/td&gt;
&lt;td&gt;按钮控件高亮处要显示的颜色&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;image&lt;/td&gt;
&lt;td&gt;按钮上要显示的图片&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;justify&lt;/td&gt;
&lt;td&gt;按钮显示多行文本时，用来指定文本的对齐方式，参数值有 LEFT/RIGHT/CENTER&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;padx/pady&lt;/td&gt;
&lt;td&gt;padx 指定 x 轴（水平方向）的间距大小，pady 则表示 y轴（垂直方向）的间距大小&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ipadx/ipady&lt;/td&gt;
&lt;td&gt;ipadx 指标签文字与标签容器之间的横向距离；ipady 则表示标签文字与标签容器之间的纵向距离&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;state&lt;/td&gt;
&lt;td&gt;设置按钮的可用状态，可选参数有NORMAL/ACTIVE/DISABLED，默认为 NORMAL&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;text&lt;/td&gt;
&lt;td&gt;按钮控件要显示的文本&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;下面是一个简单的例子：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;import tkinter as tk
from tkinter import messagebox

window = tk.Tk()
# 设置窗口的标题
window.title(&#39;破污噗&#39;)
# 设置并调整窗口的大小、位置
window.geometry(&#39;400x300+300+200&#39;)
# 当按钮被点击的时候执行click_button()函数
def click_button():
    # 使用消息对话框控件，showinfo()表示温馨提示
    messagebox.showinfo(title=&#39;温馨提示&#39;, message=&#39;恭喜你发现了宝藏文章！&#39;)

# 点击按钮时执行的函数
button = tk.Button(window,text=&#39;点击前往&#39;,bg=&#39;#7CCD7C&#39;,width=20, height=5,command=click_button).pack()
# 显示窗口
window.mainloop()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面为 Button 控件添加一张背景图片，实现代码如下所示： &lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;import tkinter as tk
from tkinter import messagebox

window = tk.Tk()
# 设置窗口的标题
window.title(&#39;破污噗&#39;)
# 设置并调整窗口的大小、位置
window.geometry(&#39;400x300+300+200&#39;)
# 当按钮被点击的时候执行click_button()函数
def click_button():
    # 使用消息对话框控件，showinfo()表示温馨提示
    messagebox.showinfo(title=&#39;温馨提示&#39;, message=&#39;恭喜你发现了宝藏文章！&#39;)
# 创建图片对象
im = tk.PhotoImage(file=&#39;agree.png&#39;)
# 点击按钮时执行的函数
button = tk.Button(window,image=im,command=click_button).pack()
# 显示窗口
window.mainloop()
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;_8&#34;&gt;扩展：按钮的布局&lt;/h4&gt;
&lt;p&gt;按钮在主窗口中的布局，通常使用 grid() 函数来完成，该函数以网格状的形式（即行和列）来管理窗口的布局。grid() 布局管理器提供了一个sticky参数，通过该参数可以设置按钮的方位，该参数默认将控件设置居中，其他参数值有 N/S/W/E（上/下/左/右），而且可以组合在一起使用，比如 NW/WE/SE/SW/NE 等，这与anchor参数控制文本的显示位置，有着异曲同工之妙。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;下面看一组简单的示例：

import tkinter as tk
from tkinter import messagebox

win = tk.Tk()
win.title(&amp;quot;破污噗&amp;quot;)
win.iconbitmap(&#39;favicon.ico&#39;)
win.geometry(&#39;400x200+100+100&#39;)
win.resizable(0,0)
# 将俩个标签分别布置在第一行、第二行
tk.Label(win, text=&amp;quot;账号：&amp;quot;).grid(row=0)
tk.Label(win, text=&amp;quot;密码：&amp;quot;).grid(row=1)
# 创建输入框控件
e1 = tk.Entry(win)
# 以 * 的形式显示密码
e2 = tk.Entry(win,show=&#39;*&#39;)
e1.grid(row=0, column=1, padx=10, pady=5)
e2.grid(row=1, column=1, padx=10, pady=5)

# 编写一个简单的回调函数
def login():
    messagebox.showinfo(title=&#39;登录成功&#39;,message=&#39;欢迎来到tkinter的世界~&#39;)

# 使用 grid()的函数来布局，并控制按钮的显示位置
tk.Button(win, text=&amp;quot;登录&amp;quot;, width=10, command=login).grid(row=3, column=0, sticky=&amp;quot;w&amp;quot;, padx=10, pady=5)
tk.Button(win, text=&amp;quot;退出&amp;quot;, width=10, command=win.quit).grid(row=3, column=1, sticky=&amp;quot;e&amp;quot;, padx=10, pady=5)

win.mainloop()
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;entry&#34;&gt;Entry输入控件&lt;/h3&gt;
&lt;p&gt;Entry 控件的作用就是允许用户输入内容。基本语法格式如下：&lt;/p&gt;
&lt;h4 id=&#34;_9&#34;&gt;基本属性&lt;/h4&gt;
&lt;p&gt;Entry 控件除了具备一些共有属性之外，还有一些自身的特殊属性，如下表所示：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性名称&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;exportselection&lt;/td&gt;
&lt;td&gt;默认情况下，如果在输入框中选中文本会复制到粘贴板，如果要忽略这个功能，可以设置为 exportselection=0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;selectbackground&lt;/td&gt;
&lt;td&gt;选中文字时的背景颜色&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;selectforeground&lt;/td&gt;
&lt;td&gt;选中文字时的前景色&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;show&lt;/td&gt;
&lt;td&gt;指定文本框内容以何种样式的字符显示，比如密码可以将值设为 show=&#34;*&#34;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;textvariable&lt;/td&gt;
&lt;td&gt;输入框内值，也称动态字符串，使用 StringVar() 对象来设置，而 text 为静态字符串对象&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;xscrollcommand&lt;/td&gt;
&lt;td&gt;设置输入框内容滚动条，当输入的内容大于输入框的宽度时使用户&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;_10&#34;&gt;动态数据类型&lt;/h4&gt;
&lt;p&gt;上述表格中提及了 StringVar() 方法，和其同类的方法还有 BooleanVar()、DoubleVar()、IntVar() 方法，不难看出他们分别代表一种数据类型，即字符串、布尔值、浮点型、整型，这些方法并不属于 Python 内置方法，而是 Tkinter 特有的方法。在界面编程的过程中，有时我们需要“动态跟踪”一些变量值的变化，从而保证值的变换及时的反映到显示界面上，但是 Python 内置的数据类型是无法这一目的的，因此使用了 Tcl 内置的对象，我们把这些方法创建的数据类型称为“动态类型”，比如 StringVar() 创建的字符串，称为“动态字符串”。&lt;/p&gt;
&lt;h4 id=&#34;_11&#34;&gt;常用方法&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;方法&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;delete()&lt;/td&gt;
&lt;td&gt;根据索引值删除输入框内的值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;get()&lt;/td&gt;
&lt;td&gt;获取输入框内的是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;set()&lt;/td&gt;
&lt;td&gt;设置输入框内的值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;insert()&lt;/td&gt;
&lt;td&gt;在指定的位置插入字符串&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;index()&lt;/td&gt;
&lt;td&gt;返回指定的索引值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;select_clear()&lt;/td&gt;
&lt;td&gt;取消选中状态&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;select_adujst()&lt;/td&gt;
&lt;td&gt;确保输入框中选中的范围包含 index 参数所指定的字符，选中指定索引和光标所在位置之前的字符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;select_from (index)&lt;/td&gt;
&lt;td&gt;设置一个新的选中范围，通过索引值 index 来设置&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;select_present()&lt;/td&gt;
&lt;td&gt;返回输入框是否有处于选中状态的文本，如果有则返回 true，否则返回 false。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;select_to()&lt;/td&gt;
&lt;td&gt;选中指定索引与光标之间的所有值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;select_range()&lt;/td&gt;
&lt;td&gt;选中指定索引与光标之间的所有值，参数值为 start,end，要求 start 必须小于 end。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;注意：在 Entry 控件中，我们可以通过以下方式来指定字符的所在位置：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数字索引：表示从 0 开始的索引数字；&lt;/li&gt;
&lt;li&gt;&#34;ANCHOE&#34;：在存在字符的情况下，它对应第一个被选中的字符；&lt;/li&gt;
&lt;li&gt;&#34;END&#34;：对应已存在文本中的最后一个位置；&lt;/li&gt;
&lt;li&gt;&#34;insert(index,&#39;字符&#39;)：将字符插入到 index 指定的索引位置。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;示例如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;import tkinter as tk

win = tk.Tk()
# 设置主窗口
win.geometry(&#39;250x100&#39;)
win.title(&amp;quot;破污噗&amp;quot;)
win.iconbitmap(&#39;favicon.ico&#39;)
win.resizable(0,0)
# 创建输入框控件
entry1 = tk.Entry(win)
# 放置输入框，并设置位置
entry1.pack(padx=20, pady=20)

entry1.delete(0, &amp;quot;end&amp;quot;)
# 插入默认文本
entry1.insert(0,&#39;百度网址：www.baidu.com&#39;)
# 得到输入框字符串
print(entry1.get())
# 删除所有字符
# entry1.delete(0, tk.END)
win.mainloop()
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;entry_1&#34;&gt;Entry控件验证功能&lt;/h4&gt;
&lt;p&gt;Entry 控件也提供了对输入内容的验证功能，比如要求输入英文字母，你却输入了数字，这就属于非法输入，Entry 控件通过以下参数实现对内容的校验：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;参数&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;validate&lt;/td&gt;
&lt;td&gt;指定验证方式，字符串参数，参数值有 focus、focusin、focusout、key、all、none。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;validatecommand&lt;/td&gt;
&lt;td&gt;指定用户自定义的验证函数，该函数只能返回 True 或者 Fasle&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;invalidcommand&lt;/td&gt;
&lt;td&gt;当 validatecommand 指定的验证函数返回 False 时，可以使用该参数值再指定一个验证函数。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;下面对 validate 的参数值做简单的介绍：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;参数值&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;focus&lt;/td&gt;
&lt;td&gt;当 Entry 组件获得或失去焦点的时候验证&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;focusin&lt;/td&gt;
&lt;td&gt;当 Entry 组件获得焦点的时候验证&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;focuson&lt;/td&gt;
&lt;td&gt;当 Entry 组件失去焦点的时候验证&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;key&lt;/td&gt;
&lt;td&gt;当输入框被编辑的时候验证&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;all&lt;/td&gt;
&lt;td&gt;当出现上边任何一种情况的时候验证&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;none&lt;/td&gt;
&lt;td&gt;默认不启用验证功能，需要注意的是这里是字符串的 &#39;none&#39;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;下面看一组具体的运行示例：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;import tkinter as tk
from tkinter import messagebox

win = tk.Tk()
# 设置主窗口
win.geometry(&#39;250x200+250+200&#39;)
win.title(&amp;quot;破污噗&amp;quot;)
win.iconbitmap(&#39;favicon.ico&#39;)
win.resizable(0,0)

# 创建验证函数
def check():
    if entry1.get() == &amp;quot;破污噗&amp;quot;:
        messagebox.showinfo(title=&#39;温馨提示&#39;,message=&amp;quot;输入正确&amp;quot;)
        return True
    else:
        messagebox.showwarning(title=&#39;温馨提示&#39;,message=&amp;quot;输入不正确&amp;quot;)
        entry1.delete(0,tk.END)  # 删除输入框中的值
        return False
# 新建文本标签
labe1 = tk.Label(win,text=&amp;quot;账号：&amp;quot;)
labe2 = tk.Label(win,text=&amp;quot;密码：&amp;quot;)
labe1.grid(row=0)
labe2.grid(row=1)
# 创建动字符串
Dy_String = tk.StringVar()
# 使用验证参数 validata,参数值为 focusout 当失去焦点的时候，验证输入框内容是否正确
entry1 = tk.Entry(win,textvariable =Dy_String,validate =&amp;quot;focusout&amp;quot;,validatecommand=check)
entry2 = tk.Entry(win)

# 对控件进行布局管理，放在文本标签的后面
entry1.grid(row=0, column=1)
entry2.grid(row=1, column=1)

win.mainloop()
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;spinbox&#34;&gt;Spinbox 高级输入框&lt;/h3&gt;
&lt;p&gt;Spinbox 是 Entry 控件的升级版，它是 Tkinter 8.4 版本后新增的控件，该控件不仅允许用户直接输入内容，还支持用户使用微调选择器（即上下按钮调节器）来输入内容。在一般情况下，Spinbox 控件用于在固定的范围内选取一个值的时候使用。下面看一组简单的应用示例：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;import tkinter as tk

root = tk.Tk()
root.title(&amp;quot;破污噗&amp;quot;)
root.geometry(&#39;300x200+300+300&#39;)
root.iconbitmap(&#39;favicon.ico&#39;)
# 如果是数字使用 from_和to参数，范围 0-20,并且与2步长递增或递减
w = tk.Spinbox(root,from_=0,to=20, increment=2,width = 15,bg=&#39;#9BCD9B&#39;)
w.pack()
# 显示窗口
root.mainloop()
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;values&#34;&gt;若不是数字，而是字符串形式的选项值，则采用values参数以元组的形式进行传参，如下所示：&lt;/h4&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;import tkinter as tk

root = tk.Tk()
root.title(&amp;quot;破污噗&amp;quot;)
root.geometry(&#39;300x200+300+300&#39;)
root.iconbitmap(&#39;favicon.ico&#39;)
# 使用values传递即可
w = tk.Spinbox(root,values=[&#39;python&#39;,&#39;c++&#39;,&#39;java&#39;])
w.pack()
# 显示窗口
root.mainloop()
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;text&#34;&gt;Text 文本控件&lt;/h3&gt;
&lt;p&gt;Text 控件用于显示和编辑多行文本。可以包含纯文本或者格式化文本，同时支持嵌入图片、显示超链接以及带有 CSS 格式的 HTML 等。&lt;/p&gt;
&lt;h4 id=&#34;_12&#34;&gt;基本属性&lt;/h4&gt;
&lt;p&gt;除了基本的共有属性之外，Text 控件还具备以下属性：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;autoseparators&lt;/td&gt;
&lt;td&gt;默认为 True，表示执行撤销操作时是否自动插入一个“分隔符”（其作用是用于分隔操作记录）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;exportselection&lt;/td&gt;
&lt;td&gt;默认值为 True，表示被选中的文本是否可以被复制到剪切板，若是 False 则表示不允许。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;insertbackground&lt;/td&gt;
&lt;td&gt;设置插入光标的颜色，默认为 BLACK&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;insertborderwidth&lt;/td&gt;
&lt;td&gt;设置插入光标的边框宽度，默认值为 0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;insertofftime&lt;/td&gt;
&lt;td&gt;该选项控制光标的闪烁频频率（灭的状态）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;insertontime&lt;/td&gt;
&lt;td&gt;该选项控制光标的闪烁频频率（亮的状态）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;selectbackground&lt;/td&gt;
&lt;td&gt;指定被选中文本的背景颜色，默认由系统决定&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;selectborderwidth&lt;/td&gt;
&lt;td&gt;指定被选中文本的背景颜色，默认值是0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;selectforeground&lt;/td&gt;
&lt;td&gt;指定被选中文本的字体颜色，默认值由系统指定&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;setgrid&lt;/td&gt;
&lt;td&gt;默认值是 False，指定一个布尔类型的值，确定是否启用网格控制&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;spacing1&lt;/td&gt;
&lt;td&gt;指定 Text 控件文本块中每一行与上方的空白间隔，注意忽略自动换行，且默认值为 0。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;spacing2&lt;/td&gt;
&lt;td&gt;指定 Text 控件文本块中自动换行的各行间的空白间隔，忽略换行符，默认值为0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;spacing3&lt;/td&gt;
&lt;td&gt;指定 Text 组件文本中每一行与下方的空白间隔，忽略自动换行，默认值是 0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;tabs&lt;/td&gt;
&lt;td&gt;定制 Tag 所描述的文本块中 Tab 按键的功能，默认被定义为 8 个字符宽度，比如 tabs=(&#39;1c&#39;, &#39;2c&#39;, &#39;8c&#39;) 表示前 3 个 Tab 宽度分别为 1厘米，2厘米，8厘米。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;undo&lt;/td&gt;
&lt;td&gt;该参数默认为 False，表示关闭 Text 控件的“撤销”功能，若为 True 则表示开启&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;wrap&lt;/td&gt;
&lt;td&gt;该参数用来设置当一行文本的长度超过 width 选项设置的宽度时，是否自动换行，参数值 none（不自动换行）、char（按字符自动换行）、word（按单词自动换行）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;xscrollcommand&lt;/td&gt;
&lt;td&gt;该参数与 Scrollbar 相关联，表示沿水平方向上下滑动&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;yscrollcommand&lt;/td&gt;
&lt;td&gt;该参数与 Scrollbar 相关联，表示沿垂直方向左右滑动&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;_13&#34;&gt;基本方法&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;方法&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;bbox(index)&lt;/td&gt;
&lt;td&gt;返回指定索引的字符的边界框，返回值是一个 4 元组，格式为(x,y,width,height)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;edit_modified()&lt;/td&gt;
&lt;td&gt;该方法用于查询和设置 modified 标志（该标标志用于追踪 Text 组件的内容是否发生变化）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;edit_redo()&lt;/td&gt;
&lt;td&gt;“恢复”上一次的“撤销”操作，如果设置 undo 选项为 False，则该方法无效。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;edit_separator()&lt;/td&gt;
&lt;td&gt;插入一个“分隔符”到存放操作记录的栈中，用于表示已经完成一次完整的操作，如果设置 undo 选项为 False，则该方法无效。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;get(index1, index2)&lt;/td&gt;
&lt;td&gt;返回特定位置的字符，或者一个范围内的文字。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;image_cget(index, option)&lt;/td&gt;
&lt;td&gt;返回 index 参数指定的嵌入 image 对象的 option 选项的值，如果给定的位置没有嵌入 image 对象，则抛出 TclError 异常&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;image_create()&lt;/td&gt;
&lt;td&gt;在 index 参数指定的位置嵌入一个 image 对象，该 image 对象必须是 Tkinter 的 PhotoImage 或 BitmapImage 实例。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;insert(index, text)&lt;/td&gt;
&lt;td&gt;在 index 参数指定的位置插入字符串，第一个参数也可以设置为 INSERT，表示在光标处插入，END 表示在末尾处插入。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;delete(startindex [, endindex])&lt;/td&gt;
&lt;td&gt;删除特定位置的字符，或者一个范围内的文字。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;see(index)&lt;/td&gt;
&lt;td&gt;如果指定索引位置的文字是可见的，则返回 True，否则返回 False。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;下面来一个小案例：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;from tkinter import *

win = Tk()
win.title(&amp;quot;破污噗&amp;quot;)
win.iconbitmap(&#39;favicon.ico&#39;)
win.geometry(&#39;400x300&#39;)
# 创建一个文本控件
# width 一行可见的字符数；height 显示的行数
text = Text(win, width=50, height=20, undo=True, autoseparators=False)
text.grid()
# INSERT 光标处插入；END 末尾处插入
text.insert(INSERT, &#39;恭喜你，发现了宝藏文章！&#39;)
# 定义撤销和恢复方法，调用edit_undo()和 edit_redo()方法
def backout():
    text.edit_undo()
def regain():
    text.edit_redo()
# 定义撤销和恢复按钮
Button(win,text = &#39;撤销&#39;,command = backout).grid(row=3, column=0, sticky=&amp;quot;w&amp;quot;, padx=10, pady=5)
Button(win,text = &#39;恢复&#39;,command = regain).grid(row=3, column=0, sticky=&amp;quot;e&amp;quot;, padx=10, pady=5)
win.mainloop()
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;listboxcombobox&#34;&gt;列表框(ListBox)和组合框(Combobox)&lt;/h3&gt;
&lt;p&gt;列表框（Listbox）和复选框（Combobox）是 Tkinter 中两个控件，由于其非常相似，所有将它们放在一起进行介绍。 &lt;/p&gt;
&lt;h4 id=&#34;listbox&#34;&gt;Listbox控件&lt;/h4&gt;
&lt;p&gt;Listbox，列表框中的选项可以是多个条目，也可以是单个唯一条目，但常用于多个条目。下面对列表框控件（Listbox）的常用方法做简单的介绍：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;方法&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;activate(index)&lt;/td&gt;
&lt;td&gt;将给定索引号对应的选项激活，即文本下方画一条下划线&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;bbox(index)&lt;/td&gt;
&lt;td&gt;返回给定索引号对应的选项的边框，返回值是一个以像素为单位的 4 元祖表示边框：(xoffset, yoffset, width, height)， xoffset 和 yoffset 表示距离左上角的偏移位置&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;curselection()&lt;/td&gt;
&lt;td&gt;返回一个元组，包含被选中的选项序号（从 0 开始）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;delete(first, last=None)&lt;/td&gt;
&lt;td&gt;删除参数 first 到 last 范围内（包含 first 和 last）的所有选项&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;get(first, last=None)&lt;/td&gt;
&lt;td&gt;返回一个元组，包含参数 first 到 last 范围内（包含 first 和 last）的所有选项的文本&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;index(index)&lt;/td&gt;
&lt;td&gt;返回与 index 参数相应选项的序号&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;itemcget(index, option)&lt;/td&gt;
&lt;td&gt;获得 index 参数指定的项目对应的选项（由 option 参数指定）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;itemconfig(index, **options)&lt;/td&gt;
&lt;td&gt;设置 index 参数指定的项目对应的选项（由可变参数 **option 指定）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;nearest(y)&lt;/td&gt;
&lt;td&gt;返回与给定参数 y 在垂直坐标上最接近的项目的序号&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;selection_set(first, last=None)&lt;/td&gt;
&lt;td&gt;设置参数 first 到 last 范围内（包含 first 和 last）选项为选中状态，使用 selection_includes(序号) 可以判断选项是否被选中。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;size()&lt;/td&gt;
&lt;td&gt;返回 Listbox 组件中选项的数量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;xview(*args)&lt;/td&gt;
&lt;td&gt;该方法用于在水平方向上滚动 Listbox 组件的内容，一般通过绑定 Scollbar 组件的 command 选项来实现。 如果第一个参数是 &#34;moveto&#34;，则第二个参数表示滚动到指定的位置：0.0 表示最左端，1.0 表示最右端；如果第一个参数是 &#34;scroll&#34;，则第二个参数表示滚动的数量，第三个参数表示滚动的单位（可以是 &#34;units&#34; 或 &#34;pages&#34;），例如：xview(&#34;scroll&#34;, 2, &#34;pages&#34;)表示向右滚动二行。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;yview(*args)&lt;/td&gt;
&lt;td&gt;该方法用于在垂直方向上滚动 Listbox 组件的内容，一般通过绑定 Scollbar 组件的 command 选项来实现&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;除了共有属性之外，列表框控件也有一些其他属性，如下表所示：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;listvariable&lt;/td&gt;
&lt;td&gt;1. 指向一个 StringVar 类型的变量，该变量存放 Listbox 中所有的项目&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1. 在 StringVar 类型的变量中，用空格分隔每个项目，例如 var.set(&#34;c c++ java python&#34;)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;selectbackground&lt;/td&gt;
&lt;td&gt;1. 指定当某个项目被选中的时候背景颜色，默认值由系统指定&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;selectborderwidth&lt;/td&gt;
&lt;td&gt;1. 指定当某个项目被选中的时候边框的宽度&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2. 默认是由 selectbackground 指定的颜色填充，没有边框&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3. 如果设置了此选项，Listbox 的每一项会相应变大，被选中项为 &#34;raised&#34; 样式&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;selectforeground&lt;/td&gt;
&lt;td&gt;1. 指定当某个项目被选中的时候文本颜色，默认值由系统指定&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;selectmode&lt;/td&gt;
&lt;td&gt;1. 决定选择的模式，tk 提供了四种不同的选择模式，分别是：&#34;single&#34;（单选）、&#34;browse&#34;（也是单选，但拖动鼠标或通过方向键可以直接改变选项）、&#34;multiple&#34;（多选）和 &#34;extended&#34;（也是多选，但需要同时按住 Shift 键或 Ctrl 键或拖拽鼠标实现），默认是 &#34;browse&#34;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;setgrid&lt;/td&gt;
&lt;td&gt;指定一个布尔类型的值，决定是否启用网格控制，默认值是 False&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;takefocus&lt;/td&gt;
&lt;td&gt;指定该组件是否接受输入焦点（用户可以通过 tab 键将焦点转移上来），默认值是 True&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;xscrollcommand&lt;/td&gt;
&lt;td&gt;为 Listbox 组件添加一条水平滚动条，将此选项与 Scrollbar 组件相关联即可&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;yscrollcommand&lt;/td&gt;
&lt;td&gt;为 Listbox 组件添加一条垂直滚动条，将此选项与 Scrollbar 组件相关联即可&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;下面是一个简单的例子：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;# 创建一个列表控件，并增加相应的选项
from tkinter import *
# 创建主窗口
win = Tk()
win.title(&amp;quot;破污噗&amp;quot;)
win.geometry(&#39;400x200&#39;)
win.iconbitmap(&#39;favicon.ico&#39;)
# 创建列表选项
listbox1 =Listbox(win)
listbox1.pack()
# i表示索引值，item 表示值，根据索引值的位置依次插入
for i,item in enumerate([&amp;quot;C&amp;quot;,&amp;quot;C++&amp;quot;,&amp;quot;C#&amp;quot;,&amp;quot;Python&amp;quot;,&amp;quot;Java&amp;quot;]):
    listbox1.insert(i,item)
# 显示窗口
win.mainloop()
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;_14&#34;&gt;增加滚动条和删除功能&lt;/h4&gt;
&lt;p&gt;下面为上述示例增加一个滚动条和选项的删除功能，如下所示：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;from tkinter import *
# 创建主窗口
win = Tk()
win.title(&amp;quot;破污噗&amp;quot;)
win.geometry(&#39;400x180&#39;)
win.iconbitmap(&#39;favicon.ico&#39;)
# 创建滚动条
s = Scrollbar(win)
# 设置垂直滚动条显示的位置，使得滚动条，靠右侧；通过 fill 沿着 Y 轴填充
s.pack(side = RIGHT,fill = Y)

# 将 selectmode 设置为多选模式，并为Listbox控件添加滚动条
listbox1 = Listbox(win,selectmode = MULTIPLE,height =5, yscrollcommand = s.set)
# i 表示索引值，item 表示值，根据索引值的位置依次插入
for i,item in enumerate(range(1,50)):
    listbox1.insert(i,item)
listbox1.pack()
# 设置滚动条，使用 yview使其在垂直方向上滚动 Listbox 组件的内容，通过绑定 Scollbar 组件的 command 参数实现
s.config(command = listbox1.yview)

# 使用匿名函数,创建删除函数，点击删除按钮，会删除选项
bt = Button(win,text=&#39;删除&#39;,command = lambda x = listbox1:x.delete(ACTIVE))
# 将按钮放置在底部
bt.pack(side = BOTTOM)
# 显示窗口
win.mainloop()
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;stringvar&#34;&gt;StringVar() 添加列表选项&lt;/h4&gt;
&lt;p&gt;下面演示如何通过  StringVar() 方法动态地获取列表框中的选项，示例代码如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;import tkinter as tk
from tkinter import messagebox

window = tk.Tk()

window.title(&amp;quot;破污噗&amp;quot;)
window.geometry(&#39;400x180&#39;)
window.iconbitmap(&#39;favicon.ico&#39;)

# 创建变量，用var1用来接收鼠标点击的具体选项内容
var1 = tk.StringVar()
l = tk.Label(window, bg=&#39;#B0B0B0&#39;, font=(&#39;微软雅黑&#39;, 15), width=20, textvariable=var1)
l.pack()

# 创建一个按钮的点击事件
def click_button():
    # 使用 curselection来选中文本
    try:
        val = lb.get(lb.curselection())
    # 设置label值
        var1.set(val)
    except Exception as e:
        e = &#39;发现一个错误&#39;
        messagebox.showwarning(e,&#39;没有选择任何条目&#39;)

# 创建一个按钮并放置，点击按钮调用print_selection函数
b1 = tk.Button(window, text=&#39;获取当前选项&#39;, command=click_button)
b1.pack()


# 创建Listbox并为其添加内容
var2 = tk.StringVar()
var2.set((&amp;quot;C语言辅导班&amp;quot;, &amp;quot;Python答疑辅导&amp;quot;, &amp;quot;Java答疑辅导&amp;quot;, &amp;quot;C++辅导&amp;quot;))
# 创建Listbox，通过 listvariable来传递变量
lb = tk.Listbox(window, listvariable=var2)
# 新建一个序列，然后将值循环添加到Listbox控件中
items = [&amp;quot;C&amp;quot;, &amp;quot;Java&amp;quot;, &amp;quot;Python&amp;quot;, &amp;quot;C#&amp;quot;, &amp;quot;Golang&amp;quot;, &amp;quot;Runby&amp;quot;]
for i in items:
    lb.insert(&#39;end&#39;, i)  # 从最后一个位置开始加入值
lb.insert(0, &#39;编程学习&#39;)  # 在第一个位置插入一段字符串
lb.delete(4)  # 删除第2个位置处的索引
lb.pack()

#主窗显示
window.mainloop()
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;combobox&#34;&gt;Combobox控件&lt;/h4&gt;
&lt;p&gt;Combobox 控件，就是下拉菜单控件。包含在tkinter.ttk子模块中，想使用 Combobox 控件，需要导入包&lt;code&gt;from tkinter import ttk&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;Combobox 控件在形式虽然与列表控件存在不同，但它们的本质是相同，因此属性和方法是通用的。对于 Combobox 控件而言，它常用的方法有两个，分别是 get() 和 current()，前者表示获取当前选中选项的内容，后者表示获取选中选项的索引值。下面通过一组简单的示例进一步了解 Combobox 控件，示例代码如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;import tkinter
from tkinter import ttk # 导入ttk模块，下拉菜单控件位于ttk子模块中

# 创建窗口
win = tkinter.Tk()
win.title(&amp;quot;破污噗&amp;quot;)
win.iconbitmap(&#39;favicon.ico&#39;)
win.geometry(&#39;400x250&#39;)
win.resizable(0,0)
# 创建下拉菜单
cbox = ttk.Combobox(win)
# 使用 grid() 来控制控件的位置
cbox.grid(row = 1, sticky=&amp;quot;NW&amp;quot;)
# 设置下拉菜单中的值
cbox[&#39;value&#39;] = (&#39;C&#39;,&#39;C#&#39;,&#39;Go&#39;,&#39;Python&#39;,&#39;Java&#39;)

#通过 current() 设置下拉菜单选项的默认值
cbox.current(3)

# 编写回调函数，绑定执行事件,向文本插入选中文本
def func(event):
    text.insert(&#39;insert&#39;,cbox.get()+&amp;quot;\n&amp;quot;)
# 绑定下拉菜单事件
cbox.bind(&amp;quot;&amp;lt;&amp;lt;ComboboxSelected&amp;gt;&amp;gt;&amp;quot;,func)
# 新建文本框
text = tkinter.Text(win)
# 布局
text.grid(pady = 5)
win.mainloop()
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;radiobuttoncheckbutton&#34;&gt;单选框(Radiobutton)和多选框按钮(Checkbutton)&lt;/h3&gt;
&lt;h4 id=&#34;radiobutton&#34;&gt;Radiobutton单选框按钮控件&lt;/h4&gt;
&lt;p&gt;单选框按钮控件（Radiobutton），允许用户选择具体的选项值，仅允许用户选择单一的选项值。Radiobutton 控件通常都是成组出现的，所有控件都使用相同的变量。Radiobutton 可以包含文本或图像，每一个按钮都可以与一个 Python 函数相关联。当按钮被按下时，对应的函数会被执行。这里需要注意的是，单选按钮控件仅能显示单一字体的文本，但文本可以跨越多行，除此之外，您还可以为个别的字符添加下划线。&lt;/p&gt;
&lt;p&gt;Radiobutton 除常用的共有属性之外，还具有一些其他属性，如下表所示：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;activebackground&lt;/td&gt;
&lt;td&gt;设置当 Radiobutton 处于活动状态（通过 state 选项设置状态）的背景色，默认值由系统指定&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;activeforeground&lt;/td&gt;
&lt;td&gt;设置当 Radiobutton 处于活动状态（通过 state 选项设置状态）的前景色，默认值由系统指定&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;compound&lt;/td&gt;
&lt;td&gt;1. 默认值为 None，控制 Radiobutton 中文本和图像的混合模式，默认情况下，如果有指定位图或图片，则不显示文本&lt;br /&gt;2. 如果该选项设置为 &#34;center&#34;，文本显示在图像上（文本重叠图像）&lt;br /&gt;3. 设置为 &#34;bottom&#34;，&#34;left&#34;，&#34;right&#34; 或 &#34;top&#34;，那么图像显示在文本的旁边，比如如&#34;bottom&#34;，则显示图像在文本的下方。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;disabledforeground&lt;/td&gt;
&lt;td&gt;指定当 Radiobutton 不可用的时的前景色颜色，默认由系统指定&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;indicatoron&lt;/td&gt;
&lt;td&gt;1. 该参数表示选项前面的小圆圈是否被绘制，默认为 True，即绘制；&lt;br /&gt;2. 如果设置为 False，则会改变单选按钮的样式，当点击时按钮会变成 &#34;sunken&#34;（凹陷），再次点击变为 &#34;raised&#34;（凸起）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;selectcolor&lt;/td&gt;
&lt;td&gt;设置当 Radiobutton 为选中状态的时候显示的图片；如果没有指定 image 选项，该选项被忽略&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;takefocus&lt;/td&gt;
&lt;td&gt;如果是 True，该组件接受输入焦点，默认为 False&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;variable&lt;/td&gt;
&lt;td&gt;表示与 Radiobutton 控件关联的变量，注意同一组中的所有按钮的 variable 选项应该都指向同一个变量，通过将该变量与 value 选项值对比，可以判断用户选中了哪个按钮。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Radiobutton 控件的常用方法如下所示：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;方法&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;deselect()&lt;/td&gt;
&lt;td&gt;取消该按钮的选中状态&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;flash()&lt;/td&gt;
&lt;td&gt;刷新 Radiobutton 控件，该方法将重绘 Radiobutton控件若干次（即在&#34;active&#34; 和 &#34;normal&#34; 状态间切换）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;invoke()&lt;/td&gt;
&lt;td&gt;1. 调用 Radiobutton 中 command 参数指定的函数，并返回函数的返回值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2. 如果 Radiobutton 控件的 state(状态) 是 &#34;disabled&#34; （不可用）或没有指定 command 选项，则该方法无效&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;select()&lt;/td&gt;
&lt;td&gt;将 Radiobutton 控件设置为选中状态&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Radiobutton 控件用来解决多选一的问题，它通常是成组出现的，下面看一组简答的示例：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;import tkinter as tk

window = tk.Tk()
window.title(&amp;quot;破污噗&amp;quot;)
window.geometry(&#39;400x180&#39;)
window.iconbitmap(&#39;favicon.ico&#39;)
# IntVar() 用于处理整数类型的变量
v = tk.IntVar()
# 根据单选按钮的 value 值来选择相应的选项
v.set(0)
# 使用 variable 参数来关联 IntVar() 的变量 v
tk.Radiobutton(window, text=&amp;quot;JAVA&amp;quot;, fg=&#39;blue&#39;,font=(&#39;微软雅黑&#39;,&#39;12&#39;,&#39;bold&#39;),variable=v, value=0).pack(anchor = &#39;w&#39;)
tk.Radiobutton(window, text=&amp;quot;Python&amp;quot;, variable=v, value=1).pack(anchor = &#39;w&#39;)
tk.Radiobutton(window, text=&amp;quot;C++&amp;quot;, variable=v, value=2).pack(anchor = &#39;w&#39;)
tk.Radiobutton(window, text=&amp;quot;Go&amp;quot;, variable=v, value=3).pack(anchor = &#39;w&#39;)
# 显示窗口
window.mainloop()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上述代码是比较直接的写法，虽然编码过程简单，但是从代码重构的角度来讲，它是比较冗余的，因此我们推荐下面这种写法，如下所示：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;import tkinter as tk

window = tk.Tk()
window.title(&amp;quot;破污噗&amp;quot;)
window.geometry(&#39;400x180&#39;)
window.iconbitmap(&#39;favicon.ico&#39;)

site = [(&#39;美团外卖&#39;,1),
        (&#39;饿了么外卖&#39;,2),
        (&#39;美团闪购&#39;,3),
        (&#39;艾奇外卖&#39;,4)]

# IntVar() 用于处理整数类型的变量
v = tk.IntVar()
# 重构后的写法，也非常简单易懂
for name, num in site:
    radio_button = tk.Radiobutton(window,text = name, variable = v,value =num)
    radio_button.pack(anchor =&#39;w&#39;)
# 显示窗口
window.mainloop()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对上述代码稍作修改，当点击某一按钮时，获取选项的内容，代码如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;import tkinter as tk

def select():
    dict = {1:&#39;Python&#39;,2:&#39;java&#39;,3:&#39;c++&#39;,4:&#39;Go&#39;}
    strings = &#39;您选择了&#39; + dict.get(v.get()) + &#39;，祝您学习愉快&#39;
    lable.config(text = strings)


window = tk.Tk()
window.title(&amp;quot;破污噗&amp;quot;)
window.geometry(&#39;400x180&#39;)
window.iconbitmap(&#39;favicon.ico&#39;)
lable = tk.Label(window,font=(&#39;微软雅黑&#39;, &#39;15&#39;,&#39;bold&#39;),fg=&#39;#43CD80&#39;)
lable.pack(side =&#39;bottom&#39;)
site = [(&#39;Python&#39;,1),
        (&#39;java&#39;,2),
        (&#39;c++&#39;,3),
        (&#39;Go&#39;,4)]

# IntVar() 用于处理整数类型的变量
v = tk.IntVar()
for name, num in site:
    radio_button = tk.Radiobutton(window,text = name, variable = v,value =num,command = select,indicatoron = False)
    radio_button.pack(anchor =&#39;w&#39;)
# 显示窗口
window.mainloop()
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;checkbutton&#34;&gt;Checkbutton复选框控件&lt;/h4&gt;
&lt;p&gt;Checkbutton 控件是一种供用户选择相应条目的按钮控件，Checkbutton 允许用户同时选择多项，各个选项之间属于并列的关系。下面对它们做简单地介绍：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;text&lt;/td&gt;
&lt;td&gt;显示的文本，使用 &#34;\n&#34; 来对文本进行换行。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;variable&lt;/td&gt;
&lt;td&gt;1. 和复选框按钮关联的变量，该变量值会随着用户选择行为来改变（选或不选），即在 onvalue 和 offvalue 设置值之间切换，这些操作由系统自动完成&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1. 在默认情况下，variable 选项设置为 1 表示选中状态，反之则为 0，表示不选中。&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;onvalue&lt;/td&gt;
&lt;td&gt;通过设置 onvalue 的值来自定义选中状态的值。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;offvalue&lt;/td&gt;
&lt;td&gt;通过设置 offvalue 的值来自定义未选中状态的值。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;indicatoron&lt;/td&gt;
&lt;td&gt;默认为 True，表示是否绘制用来选择的选项的小方块，当设置为 False 时，会改变原有按钮的样式，与单选按钮相同&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;selectcolor&lt;/td&gt;
&lt;td&gt;选择框的颜色（即小方块的颜色），默认由系统指定&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;selectimage&lt;/td&gt;
&lt;td&gt;设置当 Checkbutton 为选中状态的时候显示的图片，若如果没有指定 image 选项，该选项被忽略&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;textvariable&lt;/td&gt;
&lt;td&gt;Checkbutton 显示 Tkinter 变量（通常是一个 StringVar 变量）的内容，如果变量被修改，Checkbutton 的文本会自动更新&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;wraplength&lt;/td&gt;
&lt;td&gt;表示复选框文本应该被分成多少行，该选项指定每行的长度，单位是屏幕单元，默认值为 0&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;下面看一组简单的示例，创建一组复选框控件，代码如下： &lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;from tkinter import *
win = Tk()
win.title(&amp;quot;破污噗&amp;quot;)
win.geometry(&#39;500x200&#39;)
win.resizable(0,0)
lb = Label(text=&#39;编程语言答疑辅导班&#39;,font=(&#39;微软雅黑&#39;, 18,&#39;bold&#39;),fg=&#39;#CD7054&#39;)
lb.pack()
win.iconbitmap(&#39;favicon.ico&#39;)
# 新建整型变量
CheckVar1 = IntVar()
CheckVar2 = IntVar()
CheckVar3 = IntVar()
# 设置三个复选框控件，使用variable参数来接收变量
check1 = Checkbutton(win, text=&amp;quot;Python&amp;quot;,font=(&#39;微软雅黑&#39;, 15,&#39;bold&#39;),variable = CheckVar1,onvalue=1,offvalue=0)
check2 = Checkbutton(win, text=&amp;quot;C语言&amp;quot;,font=(&#39;微软雅黑&#39;, 15,&#39;bold&#39;),variable = CheckVar2,onvalue=1,offvalue=0)
check3 = Checkbutton(win, text=&amp;quot;Java&amp;quot;,font=(&#39;微软雅黑&#39;, 15,&#39;bold&#39;),variable = CheckVar3,onvalue=1,offvalue=0)
# 选择第一个为默认选项
# check1.select ()
check1.pack(side = LEFT)
check2.pack(side = LEFT)
check3.pack(side = LEFT)
# 定义执行函数
def study():
    # 没有选择任何项目的情况下
    if (CheckVar1.get() == 0 and CheckVar2.get() == 0 and CheckVar3.get() == 0):
        s = &#39;您还没选择任语言&#39;
    else:
        s1 = &amp;quot;Python&amp;quot; if CheckVar1.get() == 1 else &amp;quot;&amp;quot;
        s2 = &amp;quot;C语言&amp;quot; if CheckVar2.get() == 1 else &amp;quot;&amp;quot;
        s3 = &amp;quot;Java&amp;quot; if CheckVar3.get() == 1 else &amp;quot;&amp;quot;
        s = &amp;quot;您选择了%s %s %s&amp;quot; % (s1, s2, s3)
     #设置标签lb2的字体
    lb2.config(text=s)

btn = Button(win,text=&amp;quot;选好了&amp;quot;,bg=&#39;#BEBEBE&#39;,command=study)
btn.pack(side = LEFT)
# 该标签，用来显示选择的文本
lb2 = Label(win,text=&#39;&#39;,bg =&#39;#9BCD9B&#39;,font=(&#39;微软雅黑&#39;, 8,&#39;bold&#39;),width = 8,height=2)
lb2.pack(side = BOTTOM, fill = X)

# 显示窗口
win.mainloop()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;复选框控件提供以下常用方法，如下表所示：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;方法&lt;/th&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;desellect()&lt;/td&gt;
&lt;td&gt;取消 Checkbutton 组件的选中状态，也就是设置 variable 为 offvalue&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;flash()&lt;/td&gt;
&lt;td&gt;刷新 Checkbutton 组件，对其进行重绘操作，即将前景色与背景色互换从而产生闪烁的效果。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;invoke()&lt;/td&gt;
&lt;td&gt;1. 调用 Checkbutton 中 command 选项指定的函数或方法，并返回函数的返回值&lt;br /&gt;2. 如果 Checkbutton 的state(状态)&#34;disabled&#34;是 （不可用）或没有指定 command 选项，则该方法无效&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;select()&lt;/td&gt;
&lt;td&gt;将 Checkbutton 组件设置为选中状态，也就是设置 variable 为 onvalue&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;toggle()&lt;/td&gt;
&lt;td&gt;改变复选框的状态，如果复选框现在状态是 on，就改成 off，反之亦然&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;下面看一组简答的示例，如下所示：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;from tkinter import *
win = Tk()
win.title(&amp;quot;破污噗&amp;quot;)
win.geometry(&#39;500x200&#39;)
win.resizable(0,0)
lb = Label(text=&#39;编程语言答疑辅导班&#39;,font=(&#39;微软雅黑&#39;, 18,&#39;bold&#39;),fg=&#39;#CD7054&#39;)
lb.pack()
win.iconbitmap(&#39;favicon.ico&#39;)
# 设置三个复选框控件，
check1 = Checkbutton(win, text=&amp;quot;Python&amp;quot;,font=(&#39;微软雅黑&#39;, 15,&#39;bold&#39;),onvalue=1,offvalue=0)
check2 = Checkbutton(win, text=&amp;quot;C语言&amp;quot;,font=(&#39;微软雅黑&#39;, 15,&#39;bold&#39;),onvalue=1,offvalue=0)
check3 = Checkbutton(win, text=&amp;quot;Java&amp;quot;,font=(&#39;微软雅黑&#39;, 15,&#39;bold&#39;),onvalue=1,offvalue=0)
# 将第一个 复选框按钮的 variable值，设置为 onvalue =1 ，表示选中状态
check1.select ()
# 取消了第一个复选框的选中状态
# check1.toggle()
check1.pack (side = LEFT)
check2.pack (side = LEFT)
check3.pack (side = LEFT)
# 显示窗口
win.mainloop()
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;scale&#34;&gt;Scale控件&lt;/h3&gt;
&lt;p&gt;Scale 控件，即滑块控件或标尺控件，该控件可以创建一个类似于标尺式的滑动条对象，用户通过操作它可以直接设置相应的数值（刻度值)。&lt;/p&gt;
&lt;h4 id=&#34;scale_1&#34;&gt;Scale 控件常用基本属性&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;参数&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;activebackground&lt;/td&gt;
&lt;td&gt;指定当鼠标在上方飘过的时候滑块的背景颜色&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;bigincrement&lt;/td&gt;
&lt;td&gt;1. 设置“大”增长量&lt;br /&gt;2. 该选项设置增长量的大小&lt;br /&gt;3. 默认值是 0，增长量为范围的 1/10&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;borderwidth&lt;/td&gt;
&lt;td&gt;1. 指定边框宽度&lt;br /&gt;2. 默认值是 2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;command&lt;/td&gt;
&lt;td&gt;1. 指定一个函数，每当滑块发生改变的时候都会自动调用该函数&lt;br /&gt;2. 该函数有一个唯一的参数，就是最新的滑块位置&lt;br /&gt;3. 如果滑块快速地移动，函数可能无法获得每一个位置，但一定会获得滑块停下时的最终位置&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;digits&lt;/td&gt;
&lt;td&gt;1. 设置最多显示多少位数字&lt;br /&gt;2. 补充注释：例如设置 from 选项为 0，to 选项为 20，digits 选项设置为 5，那么滑块的范围就是在 0.000 ~ 20.000 直接滑动&lt;br /&gt;3. 默认值是 0（不开启）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;font&lt;/td&gt;
&lt;td&gt;1. 指定滑块左侧的 Label 和刻度的文字字体&lt;br /&gt;2. 默认值由系统指定&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;from_&lt;/td&gt;
&lt;td&gt;1. 设置滑块最顶（左）端的位置&lt;br /&gt;2. 默认值是 0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;highlightcolor&lt;/td&gt;
&lt;td&gt;1. 指定当 Scale 获得焦点的时候高亮边框的颜色&lt;br /&gt;2. 默认值由系统指定&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;label&lt;/td&gt;
&lt;td&gt;1. 你可以在垂直的 Scale 组件的顶端右侧（水平的话是左端上方）显示一个文本标签&lt;br /&gt;2. 默认值是不显示标签&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;length&lt;/td&gt;
&lt;td&gt;1. Scale 组件的长度，默认值是 100 像素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;orient&lt;/td&gt;
&lt;td&gt;1. 设置 Scale 控件是水平放置（HORIZONTAL）还是垂直放置（VERTICAL）&lt;br /&gt;2. 默认值是 VERTICAL（垂直放置）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;repeatdelay&lt;/td&gt;
&lt;td&gt;1. 该选项指定鼠标左键点击滚动条凹槽的响应时间&lt;br /&gt;2. 默认值是 300（毫秒）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;repeatinterval&lt;/td&gt;
&lt;td&gt;1. 该选项指定鼠标左键紧按滚动条凹槽时的响应间隔&lt;br /&gt;2. 默认值是 100（毫秒）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;resolution&lt;/td&gt;
&lt;td&gt;1. 指定 Scale 组件的分辨率（每点击一下移动的步长）示例： 比如 resolution 选项设置为 0.1 的话，那么每点击一下鼠标就是在 0.0 ~ 20.0 之间以 0.1 的步长移动&lt;br /&gt;2. 该参数的默认值是 1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;showvalue&lt;/td&gt;
&lt;td&gt;1. 设置是否显示滑块旁边的数字&lt;br /&gt;2. 默认值为 True&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;sliderlength&lt;/td&gt;
&lt;td&gt;1. 设置滑块的长度&lt;br /&gt;2. 默认值是 30 像素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;state&lt;/td&gt;
&lt;td&gt;1. 默认情况下 Scale 组件支持鼠标事件和键盘事件，可以通过设置该选项为 DISABLED 来禁用此功能&lt;br /&gt;2. 默认值是 NORMAL&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;takefocus&lt;/td&gt;
&lt;td&gt;1. 指定使用 Tab 键是否可以将焦点移动到该 Scale 组件上&lt;br /&gt;2. 默认是开启的，可以通过将该选项设置为 False 避免焦点落在此组件上&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;tickinterval&lt;/td&gt;
&lt;td&gt;1. 设置显示的刻度，如果设置一个值，那么就会按照该值的倍数显示刻度&lt;br /&gt;2. 默认值是不显示刻度&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;to&lt;/td&gt;
&lt;td&gt;1. 设置滑块最底（右）端的位置&lt;br /&gt;2. 默认值是 100&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;troughcolor&lt;/td&gt;
&lt;td&gt;1. 设置凹槽的颜色&lt;br /&gt;2. 默认值由系统指定&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;variable&lt;/td&gt;
&lt;td&gt;1. 指定一个与 Scale 组件相关联的 Tkinter 变量，该变量存放滑块最新的位置&lt;br /&gt;2. 当滑块移动的时候，该变量的值也会发生相应的变化&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;width&lt;/td&gt;
&lt;td&gt;1. 指定 Scale 组件的宽度&lt;br /&gt;2. 默认值是 15 像素&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;scale_2&#34;&gt;Scale 常用方法&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;方法&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;coords(value=None)&lt;/td&gt;
&lt;td&gt;1. 获得当前滑块位置相对于 Scale 控件左上角位置的相对坐标，&lt;br /&gt;2. 如果设置了 value 值，则返回当滑块位于该位置时与左上角的相对坐标&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;get()&lt;/td&gt;
&lt;td&gt;获得当前滑块的位置（即当前数值），返回值可以为整型或者浮点型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;identify(x, y)&lt;/td&gt;
&lt;td&gt;返回一个字符串表示指定位置下的 Scale 控件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;set(value)&lt;/td&gt;
&lt;td&gt;设置 Scale 控件的值，即滑块的位置，默认为初始位置&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;下面看一组简单的实例应用：创建一个 Scale 控件&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;from tkinter import *
# 创建主窗口
win =Tk()
win.title(&amp;quot;控制管理界面&amp;quot;)
win.iconbitmap(&#39;favicon.ico&#39;)
win.geometry(&#39;400x250&#39;)
# 添加一个 Scale 控件，默认垂直方向，步长设置为 5，长度为200，滑动块的大小为 50，最后使用label参数文本
s=Scale(win, from_ =100, to =0,resolution =5,length =200,sliderlength= 20,label =&#39;音量控制&#39; )
s.pack()
# 设置滑块的位置
s.set(value=15)
# 显示窗口
mainloop()
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;下面看一个稍微复杂点的应用示例，代码如下：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;import tkinter as tk

window = tk.Tk()
window.title(&amp;quot;购物车界面&amp;quot;)
window.iconbitmap(&#39;favicon.ico&#39;)
window.geometry(&#39;450x200+450+250&#39;)
window.resizable(0,0)
# 创建一个文本标签
label = tk.Label(window, bg=&#39;#9FB6CD&#39;,width=18, text=&#39;&#39;)
label.grid(row =2)
# 创建执行函数
def select_price(value):
    label.config(text=&#39;您购买的数量是 &#39; + value)
# 创建 Scale控件
scale = tk.Scale(window,
             label=&#39;选择您要购买的数量&#39;,
             from_=1,
             to= 100,
             orient=tk.HORIZONTAL,   # 设置Scale控件平方向显示
             length=400,
             tickinterval=9,       # 设置刻度滑动条的间隔
             command=select_price)  # 调用执行函数，是数值显示在 Label控件中
scale.grid(row =1)

# 显示窗口
window.mainloop()
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;canvas&#34;&gt;Canvas画布控件&lt;/h3&gt;
&lt;p&gt;Canvas 控件具有两个功能，首先它可以用来绘制各种图形，比如弧形、线条、椭圆形、多边形和矩形等，其次 Canvas 控件还可以用来展示图片（包括位图），我们将这些绘制在画布控件上的图形，称之为“画布对象”。每一个画布对象都有一个“唯一身份ID”，这是 Tkinter 自动为其创建的，从而方便控制和操作这些画布对象。通过 Canvas 控件创建一个简单的图形编辑器，让用户可以达到自定义图形的目的，就像使用画笔在画布上绘画一样，可以绘制各式各样的形状，从而有更好的人机交互体验。&lt;/p&gt;
&lt;h4 id=&#34;canvas_1&#34;&gt;Canvas控件基本属性&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;方法&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;background(bg)&lt;/td&gt;
&lt;td&gt;指定 Canvas 控件的背景颜色&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;borderwidth(bd)&lt;/td&gt;
&lt;td&gt;指定 Canvas 控件的边框宽度&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;closeenough&lt;/td&gt;
&lt;td&gt;1. 指定一个距离，当鼠标与画布对象的距离小于该值时，认为鼠标位于画布对象上&lt;br /&gt;2. 该选项是一个浮点类型的值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;confine&lt;/td&gt;
&lt;td&gt;1. 指定 Canvas 控件是否允许滚动超出 scrollregion 选项设置的滚动范围，默认值为 True&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;selectbackground&lt;/td&gt;
&lt;td&gt;指定当画布对象（即在 Canvas 画布上绘制的图形）被选中时的背景色，&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;selectborderwidth&lt;/td&gt;
&lt;td&gt;指定当画布对象被选中时的边框宽度（选中边框）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;selectforeground&lt;/td&gt;
&lt;td&gt;指定当画布对象被选中时的前景色&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;state&lt;/td&gt;
&lt;td&gt;设置 Canvas 的状态：&#34;normal&#34; 或 &#34;disabled&#34;，默认值是 &#34;normal&#34;，注意，该值不会影响画布对象的状态&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;takefocus&lt;/td&gt;
&lt;td&gt;指定使用 Tab 键可以将焦点移动到输入框中，默认为开启，将该选项设置为 False 避免焦点在此输入框中&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;width&lt;/td&gt;
&lt;td&gt;指定 Canvas 的宽度，单位为像素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;xscrollcommand&lt;/td&gt;
&lt;td&gt;与 scrollbar（滚动条）控件相关联（沿着 x 轴水平方向）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;xscrollincrement&lt;/td&gt;
&lt;td&gt;1. 该选项指定 Canvas 水平滚动的“步长”&lt;br /&gt;2. 例如 &#39;3c&#39; 表示 3 厘米，还可以选择的单位有 &#39;i&#39;（英寸），&#39;m&#39;（毫米）和 &#39;p&#39;（DPI，大约是 &#39;1i&#39; 等于 &#39;72p&#39;）&lt;br /&gt;3. 默认为 0，表示可以水平滚动到任意位置&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;yscrollcommand&lt;/td&gt;
&lt;td&gt;与 scrollbar 控件（滚动条）相关联（沿着 y 轴垂直方向）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;yscrollincrement&lt;/td&gt;
&lt;td&gt;1. 该选项指定 Canvas 垂直滚动的“步长”&lt;br /&gt;2. 例如 &#39;3c&#39; 表示 3 厘米，还可以选择的单位有 &#39;i&#39;（英寸），&#39;m&#39;（毫米）和 &#39;p&#39;（DPI，大约是 &#39;1i&#39; 等于 &#39;72p&#39;）&lt;br /&gt;3. 默认值是 0，表示可以垂直方向滚动到任意位置&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;canvas_2&#34;&gt;Canvas控件绘图常用方法&lt;/h4&gt;
&lt;p&gt;Cansvas 控件提供了一系列绘制几何图形的常用方法，下面对这些方法做简单介绍:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;方法&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;create_line(x0, y0, x1, y1, ... , xn, yn, options)&lt;/td&gt;
&lt;td&gt;1. 根据给定的坐标创建一条或者多条线段；&lt;br /&gt;2. 参数 x0,y0,x1,y1,...,xn,yn 定义线条的坐标；&lt;br /&gt;3. 参数 options 表示其他可选参数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;create_oval(x0, y0, x1, y1, options)&lt;/td&gt;
&lt;td&gt;1. 绘制一个圆形或椭圆形；&lt;br /&gt;2. 参数 x0 与 y0 定义绘图区域的左上角坐标；参数 x1 与 y1 定义绘图区域的右下角坐标；&lt;br /&gt;3. 参数 options 表示其他可选参数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;create_polygon(x0, y0, x1, y1, ... , xn, yn, options)&lt;/td&gt;
&lt;td&gt;1. 绘制一个至少三个点的多边形；&lt;br /&gt;2. 参数 x0、y0、x1、y1、...、xn、yn 定义多边形的坐标；&lt;br /&gt;3. 参数 options 表示其他可选参数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;create_rectangle(x0, y0, x1, y1, options)&lt;/td&gt;
&lt;td&gt;1. 绘制一个矩形；&lt;br /&gt;2. 参数 x0 与 y0 定义矩形的左上角坐标；参数 x 与 y1 定义矩形的右下角坐标；&lt;br /&gt;3. 参数 options 表示其他可选参数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;create_text(x0, y0, text, options)&lt;/td&gt;
&lt;td&gt;1. 绘制一个文字字符串。其中&lt;br /&gt;2. 参数 x0 与 y0 定义文字字符串的左上角坐标，参数 text 定义文字字符串的文字；&lt;br /&gt;3. 参数 options 表示其他可选参数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;create_image(x, y, image)&lt;/td&gt;
&lt;td&gt;1. 创建一个图片;&lt;br /&gt;2. 参数 x 与 y 定义图片的左上角坐标；&lt;br /&gt;3. 参数 image 定义图片的来源，必须是 tkinter 模块的 BitmapImage 类或 PhotoImage 类的实例变量。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;create_bitmap(x, y, bitmap)&lt;/td&gt;
&lt;td&gt;1. 创建一个位图；&lt;br /&gt;2. 参数 x 与 y 定义位图的左上角坐标；&lt;br /&gt;3. 参数 bitmap 定义位图的来源，参数值可以是 gray12、gray25、gray50、gray75、hourglass、error、questhead、info、warning 或 question，或者也可以直接使用 XBM（X Bitmap）类型的文件，此时需要在 XBM 文件名称前添加一个 @ 符号，例如 bitmap=@hello.xbm&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;create_arc(coord, start, extent, fill)&lt;/td&gt;
&lt;td&gt;1. 绘制一个弧形；&lt;br /&gt;2. 参数 coord 定义画弧形区块的左上角与右下角坐标；&lt;br /&gt;3. 参数 start 定义画弧形区块的起始角度（逆时针方向）；&lt;br /&gt;4. 参数 extent 定义画弧形区块的结束角度（逆时针方向）；&lt;br /&gt;5. 参数 fill 定义填充弧形区块的颜色。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;注意：上述方法都会返回一个画布对象的唯一 ID。关于 options 参数，下面会通过一个示例对经常使用的参数做相关介绍。（但由于可选参数较多，并且每个方法中的参数作用大同小异，因此对它们不再逐一列举）&lt;/p&gt;
&lt;p&gt;从上述表格不难看出，Canvas 控件采用了坐标系的方式来确定画布中的每一点。一般情况下，默认主窗口的左上角为坐标原点，这种坐标系被称作为“窗口坐标系”，但也会存在另外一种情况，即画布的大小可能大于主窗口，当发生这种情况的时，可以采用带滚动条的 Canvas 控件，此时会以画布的左上角为坐标原点，我们将这种坐标系称为“画布坐标系”。&lt;/p&gt;
&lt;h4 id=&#34;_15&#34;&gt;绘制直线&lt;/h4&gt;
&lt;p&gt;下面示例展示了如何在画布（Canvas控件）上绘制一条虚线和实线，代码如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;from tkinter import *
root = Tk()
# 设置窗口的背景颜色以区别画布
root.config(bg=&#39;#87CEEB&#39;)
root.title(&amp;quot;破污噗&amp;quot;)
root.geometry(&#39;450x350&#39;)
root.iconbitmap(&#39;favicon.ico&#39;)
# 设置画布的背景颜色为白色
cv=Canvas(root,bg=&amp;quot;white&amp;quot;,width =300, height = 250)
# 将控件放置在主窗口中
cv.pack()
# 设置坐标点,此处可以元组的形式来设置坐标点
point=[(10,20),(20,30),(30,40),(40,100),(80,120),(150,90)]
# 创建画布，添加线条
# fill 参数指定填充的颜色，如果为空字符串，则表示透明
# dash 参数表示用来绘制虚线轮廓，元组参数，分别代表虚线中线段的长度和线段之间的间隔
# arrow 设线段的箭头样式，默认不带箭头，参数值 first 表示添加箭头带线段开始位置，last表示到末尾占位置，both表示两端均添加
# smooth 布尔值参数，表示是否以曲线的样式划线，默认为 False
# width 控制线宽
line1=cv.create_line(point,fill=&amp;quot;purple&amp;quot;,dash=(1,1),arrow=LAST,width=5)
line2=cv.create_line(point,fill=&amp;quot;red&amp;quot;,arrow=BOTH,smooth=TRUE,width=5)
# 移动其中一条线段，只需要更改其坐标就可以,使用 coords()方法移动曲线
cv.coords(line2,50,30,25,35,35,40,50,120,60,170,10,180)
# 显示窗口
root.mainloop()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上述示例中涉及了一部分参数，比如 fill、dash、arrow 等，下表对 create_line() 函数的相关参数做了简单介绍：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;activedash&lt;/td&gt;
&lt;td&gt;当画布对象状态为 &#34;active&#34; 的时候，绘制虚线&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;activefill&lt;/td&gt;
&lt;td&gt;当画布对象状态为 &#34;active&#34; 的时候，填充颜色&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;activestipple&lt;/td&gt;
&lt;td&gt;当画布对象状态为 &#34;active&#34; 的时候，指定填充的位图&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;activewidth&lt;/td&gt;
&lt;td&gt;当画布对象状态为 &#34;active&#34; 的时候，指定边框的宽度&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;arrow&lt;/td&gt;
&lt;td&gt;1. 默认线段是不带箭头的，通过设置该选项添加箭头到线段中&lt;br /&gt;2. &#34;first&#34; 表示添加箭头到线段开始的位置&lt;br /&gt;3. &#34;last&#34; 表示添加箭头到线段结束的位置&lt;br /&gt;4. &#34;both&#34; 表示两端均添加箭头&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;arrowshape&lt;/td&gt;
&lt;td&gt;1. 用一个三元组来指定箭头的形状，默认值是 (8, 10, 3)，元组中的数值分别代表箭头中三条边的长度&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;capstyle&lt;/td&gt;
&lt;td&gt;1. 指定线段两端的样式，默认值是 &#34;butt&#34;&lt;br /&gt;2. 该选项的值可以是：&#34;butt&#34;（线段的两段平切于起点和终点）、&#34;projecting&#34;（线段的两段在起点和终点的位置将 width 选项设置的长度分别延长一半）、&#34;round&#34;（线段的两段在起点和终点的位置将 width设置的长度分别延长一半，并以圆角进行绘制）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;dash&lt;/td&gt;
&lt;td&gt;绘制虚线，该选项值是一个整数元组，元组中的元素分别代表短线的长度和间隔，比如 (3, 5) 代表 3 个像素的短线和 5 个像素的间隔&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;dashoffset&lt;/td&gt;
&lt;td&gt;指定虚线开始的偏移位置，比如 dash=(5, 1, 2, 1)，dashoffset=3，则从 2 开始画虚线&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;disableddash&lt;/td&gt;
&lt;td&gt;当画布对象状态为 &#34;disabled&#34; 的时候，绘制虚线&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;disabledfill&lt;/td&gt;
&lt;td&gt;当画布对象状态为 &#34;disabled&#34; 的时候，填充颜色&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;disabledstipple&lt;/td&gt;
&lt;td&gt;当画布对象状态为 &#34;disabled&#34; 的时候，指定填充的位图&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;disabledwidth&lt;/td&gt;
&lt;td&gt;当画布对象状态为 &#34;disabled&#34; 的时候，指定边框的宽度&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;fill&lt;/td&gt;
&lt;td&gt;1. 指定填充的颜色，空字符串表示透明&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;joinstyle&lt;/td&gt;
&lt;td&gt;1. 指定当绘制两个相邻线段之间时接口的样式，默认为 &#34;round&#34;&lt;br /&gt;2. 该选项的值可以是：&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&#34;round&#34;（以连接点为圆心，1/2 width 选项设置的长度为半径来绘制圆角）&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&#34;bevel&#34;（在连接点处将两线段的夹角做平切操作）&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&#34;miter&#34;（沿着两线段的夹角延伸至一个点）&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;offset&lt;/td&gt;
&lt;td&gt;指定当点画模式时填充位图的偏移&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;smooth&lt;/td&gt;
&lt;td&gt;默认值为 False，若设置为 True，表示将以曲线的样式代替所绘线段&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;splinesteps&lt;/td&gt;
&lt;td&gt;当绘制曲线的时，该选项指定由多少条折线来构成曲线，默认值是 12，这里需要注意，只有当 smooth 选项为 True 时该选项才会生效。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;state&lt;/td&gt;
&lt;td&gt;指定该画布对象的状态，默认值为 &#34;normal&#34;，参数值有 &#34;normal&#34;，&#34;disabled&#34;（不可用）和 &#34;hidden&#34;（隐藏）三种状态。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;stipple&lt;/td&gt;
&lt;td&gt;指定一个位图进行填充，默认值为空字符串，表示实心&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;tags&lt;/td&gt;
&lt;td&gt;为创建的画布对象添加标签&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;width&lt;/td&gt;
&lt;td&gt;指定边框的宽度&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;对于扇形、矩形、三角形、圆形等，这些封闭式图形，它们由轮廓线和填充颜色两部分组成。在绘制这些图形时相关函数的可选参数与上述表格也存在略微差异，下面以绘制扇形的 create_arc() 函数为例做简单的介绍：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;方法&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;activedash&lt;/td&gt;
&lt;td&gt;当画布对象状态为 &#34;active&#34; 的时候，绘制虚线&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;activefill&lt;/td&gt;
&lt;td&gt;当画布对象状态为 &#34;active&#34; 的时候，填充颜色&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;activeoutline&lt;/td&gt;
&lt;td&gt;当画布对象状态为 &#34;active&#34; 的时候，绘制轮廓线&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;activeoutlinestipple&lt;/td&gt;
&lt;td&gt;当画布对象状态为 &#34;active&#34; 的时候，指定填充轮廓的位图&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;activestipple&lt;/td&gt;
&lt;td&gt;当画布对象状态为 &#34;active&#34; 的时候，指定填充的位图&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;activewidth&lt;/td&gt;
&lt;td&gt;当画布对象状态为 &#34;active&#34; 的时候，指定边框的宽度&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;dash&lt;/td&gt;
&lt;td&gt;指定绘制虚线轮廓，与绘制线段的含义相同&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;dashoffset&lt;/td&gt;
&lt;td&gt;指定虚线轮廓开始的偏移位置&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;disableddash&lt;/td&gt;
&lt;td&gt;当画布对象状态为 &#34;disabled&#34; 的时候，绘制虚线&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;disabledfill&lt;/td&gt;
&lt;td&gt;当画布对象状态为 &#34;disabled&#34; 的时候，填充颜色&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;disabledoutline&lt;/td&gt;
&lt;td&gt;当画布对象状态为 &#34;disabled&#34; 的时候，绘制轮廓线&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;disabledoutlinestipple&lt;/td&gt;
&lt;td&gt;当画布对象状态为 &#34;disabled&#34; 的时候，指定填充轮廓的位图&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;disabledstipple&lt;/td&gt;
&lt;td&gt;当画布对象状态为 &#34;disabled&#34; 的时候，指定填充的位图&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;disabledwidth&lt;/td&gt;
&lt;td&gt;当画布对象状态为 &#34;disabled&#34; 的时候，指定边框的宽度&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;extent&lt;/td&gt;
&lt;td&gt;指定跨度（从 start 选项指定的位置开始到结束位置的角度）默认值是 90.0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;fill&lt;/td&gt;
&lt;td&gt;与上述表格的含义相同，表示指定的填充颜色，若为空字符串则为透明色&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;offset&lt;/td&gt;
&lt;td&gt;指定当点画模式时填充位置的偏移，参数值为 &#34;x,y&#34;坐标偏移和位置偏移两种方式，比如 &#34;ne&#34;/&#34;e&#34; 等&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;outline&lt;/td&gt;
&lt;td&gt;指定轮廓的颜色&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;outlineoffset&lt;/td&gt;
&lt;td&gt;指定当点画模式绘制轮廓时位图的偏移&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;outlinestipple&lt;/td&gt;
&lt;td&gt;当 outline 选项被设置时，该选项用于指定一个位图来填充边框，默认值是空字符串，表示黑色&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;start&lt;/td&gt;
&lt;td&gt;指定起始位置的偏移角度&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;style&lt;/td&gt;
&lt;td&gt;默认创建的是扇形，指定该方法创建的是扇形（&#34;pieslice&#34;）、弓形（&#34;chord&#34;）还是弧形（&#34;arc&#34;）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;tags&lt;/td&gt;
&lt;td&gt;为创建的画布对象添加标签&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;width&lt;/td&gt;
&lt;td&gt;指定边框的宽度&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;下面让我们来一组绘制几何图形的简单示例：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;from tkinter import *
root = Tk()
# 设置主窗口区的背景颜色以区别画布区的颜色
root.config(bg=&#39;#8DB6CD&#39;)
root.title(&amp;quot;破污噗&amp;quot;)
root.geometry(&#39;500x400&#39;)
root.iconbitmap(&#39;favicon.ico&#39;)

# 将画布设置为白色
canvas = Canvas(root,width = 400,height = 400,bg=&#39;white&#39;)
# 设置基准坐标
x0,y0,x1,y1 = 10,10,80,80
# 绘制扇形,起始角度为 0 度，结束角度为 270, 扇形区域填充色为淡蓝色，轮廓线为蓝色，线宽为 2px
arc = canvas.create_arc(x0, y0, x1, y1,start = 0, extent = 270, fill = &#39;#B0E0E6&#39;,outline =&#39;blue&#39;,width = 2)
# 绘制圆形
oval = canvas.create_oval(x0+150, y0, x1+150, y1,fill =&#39;#CD950C&#39;,outline = &#39;blue&#39;,width=2)
# 绘制矩形,并将轮廓线设置为透明色，即不显示最外围的轮廓线，默认为黑色
rect = canvas.create_rectangle(x0,y0+100,x1,y1+100,fill=&#39;red&#39;,outline = &#39;&#39;)
# 绘制一个三角形，填充色为绿色
trigon = canvas.create_polygon(80,80,150,80,200,200, outline=&amp;quot;&amp;quot;, fill=&amp;quot;green&amp;quot;,)

# 当然也可以绘制一个任意多边形，只要你的坐标正确就可以
# 绘制一个多边形，首先定义一系列的多边形上的坐标点
poly_points=[(0,280),(140,200),(140,240),(270,240),(270,320),(140,320),(140,360)]
polygon = canvas.create_polygon(poly_points,fill=&amp;quot;#BF3EFF&amp;quot;)

# 放置画布在主窗口
canvas.pack()
# 显示窗口
root.mainloop()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意：create_rectangle() 方法的前两个参数决定了矩形的左上角坐标，后两个参数决定了矩形的右下角坐标；另外 create_oval() 方法并不是只能绘制圆形，还能绘制椭圆形，这取决于传入的参数。 &lt;/p&gt;
&lt;h3 id=&#34;menu&#34;&gt;Menu菜单控件&lt;/h3&gt;
&lt;p&gt;Menu 控件（菜单控件）它以可视化的方式将一系列的“功能选项卡”进行分组，并在每个分组下又“隐藏”了许多其他的“选项卡”。当打开菜单时，这些选项卡就会“显式”的呈现出来，方便用户进行选择。&lt;/p&gt;
&lt;p&gt;通过使用菜单控件（Menu）可以充分地节省有限的窗口区域，让我们的界面更加简洁优雅，避免臃肿、混乱。 Tkinter Menu 控件提供了三种类型的菜单，分别是：topleve（主目录菜单）、pull-down（下拉式菜单）、pop-up（弹出式菜单，或称快捷式菜单）。
下表列出创建菜单时用到的相关方法，如下所示：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;方法&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;add_cascade(**options)&lt;/td&gt;
&lt;td&gt;添加一个父菜单，将一个指定的子菜单，通过 menu 参数与父菜单连接，从而创建一个下拉菜单。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;add_checkbutton(**options)&lt;/td&gt;
&lt;td&gt;添加一个多选按钮的菜单项&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;add_command(**options)&lt;/td&gt;
&lt;td&gt;添加一个普通的命令菜单项&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;add_radiobutton(**options)&lt;/td&gt;
&lt;td&gt;添加一个单选按钮的菜单项&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;add_separator(**options)&lt;/td&gt;
&lt;td&gt;添加一条分割线&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;add(add(itemType, options))&lt;/td&gt;
&lt;td&gt;添加菜单项，此处 itemType 参数可以是以下几种：&#34;command&#34;、&#34;cascade&#34;，&#34;checkbutton&#34;、&#34;radiobutton&#34;、&#34;separator&#34; 五种，并使用 options 选项来设置菜单其他属性。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;除了上述方法之外，Menu 控件也提供了一些其他方法来操作菜单项，比如删除菜单项、获取菜单项、设置指定的菜单项等，如下表所示：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;方法&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;delete(index1, index2=None)&lt;/td&gt;
&lt;td&gt;1. 删除 index1 ~ index2（包含）的所有菜单项&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1. 如果忽略 index2 参数，则删除 index1 指向的菜单项&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;entrycget(index, option)&lt;/td&gt;
&lt;td&gt;获得指定菜单项的某选项的值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;entryconfig(index, **options)&lt;/td&gt;
&lt;td&gt;设置指定菜单项的选项&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;index(index)&lt;/td&gt;
&lt;td&gt;返回与 index 参数相应的选项的序号&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;insert(index, itemType, **options)&lt;/td&gt;
&lt;td&gt;插入指定类型的菜单项到 index 参数指定的位置，类型可以是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;是：&#34;command&#34;，&#34;cascade&#34;，&#34;checkbutton&#34;，&#34;radiobutton&#34;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;或 &#34;separator&#34; 中的一个，或者也可以使用 insert_类型() 形式来，&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;比如 insert_cascade(index, **options)..等&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;invoke(index)&lt;/td&gt;
&lt;td&gt;调用 index 指定的菜单项相关联的方法&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;post(x, y)&lt;/td&gt;
&lt;td&gt;在指定的位置显示弹出菜单&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;type(index)&lt;/td&gt;
&lt;td&gt;获得 index 参数指定菜单项的类型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;unpost()&lt;/td&gt;
&lt;td&gt;移除弹出菜单&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;yposition(index)&lt;/td&gt;
&lt;td&gt;返回 index 参数指定的菜单项的垂直偏移位置&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;下面对 Menu 控件的 options 参数做简单地介绍，如下所示：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;accelerator&lt;/td&gt;
&lt;td&gt;1. 设置菜单项的快捷键，快捷键会显示在菜单项目的右边，比如 accelerator = &#34;Ctrl+O&#34; 表示打开；&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2. 注意，此选项并不会自动将快捷键与菜单项连接在一起，必须通过按键绑定来实现&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;command&lt;/td&gt;
&lt;td&gt;选择菜单项时执行的 callback 函数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;label&lt;/td&gt;
&lt;td&gt;定义菜单项内的文字&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;menu&lt;/td&gt;
&lt;td&gt;此属性与 add_cascade() 方法一起使用，用来新增菜单项的子菜单项&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;selectcolor&lt;/td&gt;
&lt;td&gt;指定当菜单项显示为单选按钮或多选按钮时选择中标志的颜色&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;state&lt;/td&gt;
&lt;td&gt;定义菜单项的状态，可以是 normal、active 或 disabled&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;onvalue/offvalue&lt;/td&gt;
&lt;td&gt;1. 默认情况下，variable 选项设置为 1 表示选中状态，反之设置为 0，设置 offvalue/onvalue 的值可以自定义未选中状态的值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;tearoff&lt;/td&gt;
&lt;td&gt;1. 如果此选项为 True，在菜单项的上面就会显示一个可选择的分隔线；&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2. 注意：分隔线会将此菜单项分离出来成为一个新的窗口&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;underline&lt;/td&gt;
&lt;td&gt;设置菜单项中哪一个字符要有下画线&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;value&lt;/td&gt;
&lt;td&gt;1. 设置按钮菜单项的值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2. 在同一组中的所有按钮应该拥有各不相同的值&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3. 通过将该值与 variable 选项的值对比，即可判断用户选中了哪个按钮&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;variable&lt;/td&gt;
&lt;td&gt;当菜单项是单选按钮或多选按钮时，与之关联的变量&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;_16&#34;&gt;创建主目录菜单&lt;/h4&gt;
&lt;p&gt;主目录菜单也称之为“顶级菜单”，下拉菜单等其他子菜单的都需要建立在“顶级菜单”的基础之上，下面示例创建了一个类似于“记事本”界面的程序，代码如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;from tkinter import *
import tkinter . messagebox
#创建主窗口
win = Tk()
win.config(bg=&#39;#87CEEB&#39;)
win.title(&amp;quot;破污噗&amp;quot;)
win.geometry(&#39;450x350+300+200&#39;)
win.iconbitmap(&#39;favicon.ico&#39;)

# 绑定一个执行函数，当点击菜单项的时候会显示一个消息对话框
def menuCommand() :
    tkinter.messagebox.showinfo(&amp;quot;主菜单栏&amp;quot;,&amp;quot;你正在使用主菜单栏&amp;quot;)
# 创建一个主目录菜单，也被称为顶级菜单
main_menu = Menu(win)
#新增命令菜单项，使用 add_command() 实现
main_menu.add_command(label=&amp;quot;文件&amp;quot;,command=menuCommand)
main_menu.add_command(label=&amp;quot;编辑&amp;quot;,command=menuCommand)
main_menu.add_command(label=&amp;quot;格式&amp;quot;,command=menuCommand)
main_menu.add_command(label=&amp;quot;查看&amp;quot;,command=menuCommand)
main_menu.add_command(label=&amp;quot;帮助&amp;quot;,command=menuCommand)
#显示菜单
win.config(menu=main_menu)
win.mainloop()
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;_17&#34;&gt;创建下拉菜单&lt;/h4&gt;
&lt;p&gt;下拉菜单时主菜单的重要组成部分，也是用户选择相关命令的重要交互界面，下拉菜单的创建方式也非常简单，不过需要我们注意，下拉菜单是建立的主菜单（即顶级菜单）的基础之上的，并非主窗口之上，这一点千万不要搞混，否则创建下拉菜单会失败。&lt;/p&gt;
&lt;p&gt;下面继续仿照“记事本”的相关功能来创建下拉菜单，示例如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;from tkinter import *
import tkinter .messagebox
#创建主窗口
win = Tk()
win.config(bg=&#39;#87CEEB&#39;)
win.title(&amp;quot;破污噗&amp;quot;)
win.geometry(&#39;450x350+300+200&#39;)
win.iconbitmap(&#39;favicon.ico&#39;)

#创建一个执行函数，点击下拉菜单中命令时执行
def menuCommand() :
    tkinter .messagebox .showinfo(&amp;quot;下拉菜单&amp;quot;, &amp;quot;您正在使用下拉菜单功能&amp;quot;)

#创建主目录菜单（顶级菜单）
mainmenu = Menu (win)

#在顶级菜单上新增&amp;quot;文件&amp;quot;菜单的子菜单，同时不添加分割线
filemenu = Menu (mainmenu, tearoff=False)

#新增&amp;quot;文件&amp;quot;菜单的菜单项，并使用 accelerator 设置菜单项的快捷键
filemenu.add_command (label=&amp;quot;新建&amp;quot;,command=menuCommand,accelerator=&amp;quot;Ctrl+N&amp;quot;)
filemenu.add_command (label=&amp;quot;打开&amp;quot;,command=menuCommand, accelerator=&amp;quot;Ctrl+O&amp;quot;)
filemenu.add_command (label=&amp;quot;保存&amp;quot;,command=menuCommand, accelerator=&amp;quot;Ctrl+S&amp;quot;)
# 添加一条分割线
filemenu.add_separator ()
filemenu.add_command (label=&amp;quot;退出&amp;quot;,command=win. quit)
#在主目录菜单上新增&amp;quot;文件&amp;quot;选项，并通过menu参数与下拉菜单绑定
mainmenu.add_cascade (label=&amp;quot;文件&amp;quot;,menu=filemenu)

# 将主菜单设置在窗口上
win.config (menu=mainmenu)
# 绑定键盘事件，按下键盘上的相应的键时都会触发执行函数
win.bind(&amp;quot;&amp;lt;Control-n&amp;gt;&amp;quot;,menuCommand)
win. bind(&amp;quot;&amp;lt;Control-N&amp;gt;&amp;quot;, menuCommand)
win.bind(&amp;quot;&amp;lt;Control-o&amp;gt;&amp;quot;,menuCommand)
win. bind(&amp;quot;&amp;lt;Control-O&amp;gt;&amp;quot;, menuCommand)
win. bind(&amp;quot;&amp;lt;Control-s&amp;gt;&amp;quot;, menuCommand)
win.bind(&amp;quot;&amp;lt;Control-S&amp;gt;&amp;quot;,menuCommand)
# 显示主窗口
win.mainloop()
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;_18&#34;&gt;创建弹出菜单栏&lt;/h4&gt;
&lt;p&gt;弹出式菜单栏，也称为快捷式菜单栏，比如通过点击鼠标右键弹出一个菜单栏，其中包含一些常用的选项卡，如复制、粘贴等.&lt;/p&gt;
&lt;p&gt;Tkinter Menu 控件同样可以是实现上述功能，而且并不复杂，示例如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;import tkinter as tk

root = tk.Tk()
root.config(bg=&#39;#8DB6CD&#39;)
root.title(&amp;quot;破污噗&amp;quot;)
root.geometry(&#39;400x300&#39;)
root.iconbitmap(&#39;favicon.ico&#39;)
def func():
    print(&#39;您通过弹出菜单执行了命令&#39;)

# 创建一个弹出菜单
menu = tk.Menu(root, tearoff=False)
menu.add_command(label=&amp;quot;新建&amp;quot;, command=func)
menu.add_command(label=&amp;quot;复制&amp;quot;, command=func)
menu.add_command(label=&amp;quot;粘贴&amp;quot;, command=func)
menu.add_command(label=&amp;quot;剪切&amp;quot;, command=func)
# 定义事件函数
def command(event):
    # 使用 post()在指定的位置显示弹出菜单
    menu.post(event.x_root, event.y_root)

# 绑定鼠标右键，这是鼠标绑定事件
# &amp;lt;Button-3&amp;gt;表示点击鼠标的右键，1 表示左键，2表示点击中间的滑轮
root.bind(&amp;quot;&amp;lt;Button-3&amp;gt;&amp;quot;, command)
root.mainloop()
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;scrollbar&#34;&gt;Scrollbar滚动条控件&lt;/h3&gt;
&lt;p&gt;Scrollbar 控件常用于创建一个水平或者垂直的滚动条，通常情况下，Scrollbar 控件可以与 Listbox、Text、Canvas 以及 Entry 等控件一起使。&lt;/p&gt;
&lt;p&gt;滚动条控件是 GUI  程序中经常使用的一种控件类型，它主要用来控制控件区域的可见范围，比如当 Text 控件的文本内容非常多时，为了方便用户阅读，可以给 Text 控件增加滚动条，用户只需拖动滚动条就能完成内容的阅读。
Scrollbar 控件的常用属性，如下表所示：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;activebackground&lt;/td&gt;
&lt;td&gt;指定当鼠标在上方飘过的时候滑块和箭头的背景颜色，默认由系统决定&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;activerelief&lt;/td&gt;
&lt;td&gt;指定当鼠标在滑块上方飘过时滑块的样式，默认值是 &#34;raised&#34;，其他可选值有 &#34;flat&#34;，&#34;sunken&#34;，&#34;groove&#34;，&#34;ridge&#34;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;background(bg)&lt;/td&gt;
&lt;td&gt;指定背景颜色，默认值由系统指定&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;borderwidth(bd)&lt;/td&gt;
&lt;td&gt;指定边框宽度，默认值是 0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;command&lt;/td&gt;
&lt;td&gt;当滚动条更新时回调的函数，通常指定对应组件的 xview() 或 yview() 方法&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;cursor&lt;/td&gt;
&lt;td&gt;指定当鼠标在上方飘过的时的鼠标样式，默认值由系统指定&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;elementborderwidth&lt;/td&gt;
&lt;td&gt;1. 指定滚动条和箭头的边框宽度&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2. 默认值是 -1（表示使用 borderwidth 选项的值）&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;jump&lt;/td&gt;
&lt;td&gt;1. 指定当用户拖拽滚动条时的行为&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2. 默认值为 False，滚动条的任何一丝变动都会即刻调用 command 指定的回调函数&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3. 设置为 True 则当用户松开鼠标才调用&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;orient&lt;/td&gt;
&lt;td&gt;指定绘制 &#34;horizontal&#34;（垂直滚动条）还是 &#34;vertical&#34;（水平滚动条），默认值是 VERTICAL&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;repeatdelay&lt;/td&gt;
&lt;td&gt;该选项指定鼠标左键点击滚动条凹槽的响应时间，默认值是 300（毫秒）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;repeatinterval&lt;/td&gt;
&lt;td&gt;该选项指定鼠标左键紧按滚动条凹槽时的响应间隔，默认值是 100（毫秒）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;takefocus&lt;/td&gt;
&lt;td&gt;指定使用 Tab 键可以将焦点移到该 Scrollbar 组件上，默认为开启，可以将该选项设置为 False 避免焦点在此组件上&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;troughcolor&lt;/td&gt;
&lt;td&gt;指定凹槽的颜色，默认由系统指定&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;width&lt;/td&gt;
&lt;td&gt;指定滚动条的宽度,默认值是 16px&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;下面是介绍了 Scrollbar 控件常用的函数：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;activate(element)&lt;/td&gt;
&lt;td&gt;1. 显示 element 参数指定的元素的背景颜色和样式;&lt;br /&gt;2. element 参数可以设置为：&#34;arrow1&#34;（箭头1），&#34;arrow2&#34;（箭头2）或 &#34;slider&#34;（滑块）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;delta(deltax, deltay)&lt;/td&gt;
&lt;td&gt;1. 给定一个鼠标移动的范围 deltax 和 deltay，然后该方法返回一个浮点类型的值（范围 -1.0 ~ 1.0）&lt;br /&gt;2. 注意：deltax 表示水平移动量，deltay 表示垂直移动量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;fraction(x, y)&lt;/td&gt;
&lt;td&gt;给定一个像素坐标 (x, y)，该方法返回最接近给定坐标的滚动条位置。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;get()&lt;/td&gt;
&lt;td&gt;返回当前滑块的位置 (a, b)，其中 a 值表示当前滑块的顶端或左端的位置，b 值表示当前滑块的底端或右端的位置。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;identify(x, y)&lt;/td&gt;
&lt;td&gt;1. 返回一个字符串表示指定位置下（如果有的话）的滚动条部件，&lt;br /&gt;2. 返回值可以是：&#34;arrow1&#34;（箭头1），&#34;arrow2&#34;（箭头2）、&#34;slider&#34;（滑块）或 &#34;&#34;（空）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;set(*args)&lt;/td&gt;
&lt;td&gt;1. 设置当前滚动条的位置&lt;br /&gt;2. 该方法有两个参数即 (first, last)，其中 first 表示当前滑块的顶端或左端的位置，last 表示当前滑块的底端或右端的位置（范围 0.0 ~ 1.0）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;下面看一组简单的示例：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;from tkinter import *
root = Tk()
root.title(&amp;quot;破污噗&amp;quot;)
root.geometry(&#39;450x180+300+200&#39;)
root.iconbitmap(&#39;favicon.ico&#39;)
# 创建一个滚动条控件，默认为垂直方向
sbar1= Scrollbar(root)
# 将滚动条放置在右侧，并设置当窗口大小改变时滚动条会沿着垂直方向延展
sbar1.pack(side=RIGHT, fill=Y)
# 创建水平滚动条，默认为水平方向,当拖动窗口时会沿着X轴方向填充
sbar2 = Scrollbar(root, orient=HORIZONTAL)
sbar2.pack(side=BOTTOM, fill=X)

# 创建列表框控件,并添加两个滚动条（分别在垂直和水平方向），使用 set() 进行设置
mylist = Listbox(root,xscrollcommand = sbar2.set,yscrollcommand = sbar1.set)
for i in range(30):
    mylist.insert(END,&#39;第&#39;+ str(i+1)+&#39;次:&#39;+&#39;百度网址为：www.baidu.com&#39;+ &#39;\n&#39; )
# 当窗口改变大小时会在X与Y方向填满窗口
mylist.pack(side=LEFT,fill = BOTH)
# 使用 command 关联控件的 yview、xview方法
sbar1.config(command = mylist.yview)
sbar2.config(command = mylist.xview)
#  显示主窗口
root.mainloop()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过滑动滚动条可以浏览列表框中的内容，垂直方向的滚动条沿着上下浏览，水平方向的滚动条则沿着左右方向浏览。&lt;/p&gt;
&lt;h3 id=&#34;event&#34;&gt;Event事件处理&lt;/h3&gt;
&lt;p&gt;事件处理，是 GUI 程序中不可或缺的重要组成部分，相比来说，控件只是组成一台机器的零部件， 而事件处理则是驱动这台机器“正常”运转的关键所在，它能够将零部件之间“优雅”的贯穿起来，因此“事件处理”可谓是 GUI 程序的“灵魂”，同时它也是实现人机交互的关键。在一款 GUI 程序中，我们将用户对软件的操作统称为“事件”，比如鼠标点击按钮、键盘输入文本以及窗口管理器触发的重绘事件等，这些事件有一个共同的特点，即都是由用户直接或者间接触发的。&lt;/p&gt;
&lt;h4 id=&#34;_19&#34;&gt;事件绑定方法&lt;/h4&gt;
&lt;p&gt;Tkinter 提供的事件处理机制允许我们为“控件”绑定相应的事件和事件处理函数（即 callback函数），从而实现控件与用户的交互，其语法格式如下：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;widget.bind(&#34;&amp;lt;event&amp;gt;&#34;,func)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;上述语法中，widget 代表控件的实例对象，之后，采用 bind() 方法进行事件绑定，该函数有两个参数：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;event&amp;gt;&lt;/code&gt;：一个字符串参数，表示事件的类型，并使用“尖括号”的形式进行包裹；
func：表示事件的处理函数（callback，即回调函数），当触发事件时，Tk 会携带事件对象（Event）去调用 func 方法。&lt;/p&gt;
&lt;p&gt;注意：&lt;code&gt;bind()&lt;/code&gt; 方法可以完成事件与处理函数绑定，而使用 unbind() 方法可以将事件与处理函数解绑。&lt;/p&gt;
&lt;h4 id=&#34;_20&#34;&gt;常用事件类型&lt;/h4&gt;
&lt;p&gt;事件类型（也称事件码）是 Tkinter 模块规定的，主要包括鼠标、键盘、光标等相关事件，Tkinter 为其规定了相应的语法格式：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;modifier-type-detail&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;上述语法由三部分组成，说明如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&amp;lt;&amp;gt;：事件类型必须包含在“尖括号”内；&lt;/li&gt;
&lt;li&gt;modifier：可选项，事件类型的修饰符，通常用于描述组合键、双击&lt;Double-Button-1&gt;、大写锁定键&lt;Lock&gt;以及&lt;Alt-Shift&gt;等；&lt;/li&gt;
&lt;li&gt;type：是必不可少的一项，表示事件的具体类型；&lt;/li&gt;
&lt;li&gt;detail：可选项，通常用于描述具体的哪个按键，比如 &lt;Button-1&gt; 表示鼠标左键；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里有必要对经常使用的 modifier 修饰符做简单的介绍，修饰符可以修改事件的激活条件，比如双击鼠标或者需要同时按下某个键才触发事件，常用的修饰符如下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;修饰符&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Control&lt;/td&gt;
&lt;td&gt;事件发生时需按下 Control 键&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Alt&lt;/td&gt;
&lt;td&gt;事件发生时需按下 Alt 键&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Shift&lt;/td&gt;
&lt;td&gt;事件发生时需按下 Shift 键&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Lock&lt;/td&gt;
&lt;td&gt;事件发生时需处于大写锁定状态&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Double&lt;/td&gt;
&lt;td&gt;事件连续发生两次，比如双击鼠标&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Triple&lt;/td&gt;
&lt;td&gt;事件连续发生三次&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Quadruple&lt;/td&gt;
&lt;td&gt;事件连续发生四次&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;下述表格中介绍了 Tkinter 中经常使用的事件类型，如下所示：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;事件码&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;ButtonPress-1&gt;&lt;/td&gt;
&lt;td&gt;单击鼠标左键，简写为&lt;Button-1&gt;，后面的数字可以是1/2/3，分别代表左键、中间滑轮、右键&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;ButtonRelease-1&gt;&lt;/td&gt;
&lt;td&gt;释放鼠标左键，后面数字可以是1/2/3，分别代表释放左键、滑轮、右键&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;B1-Motion&gt;&lt;/td&gt;
&lt;td&gt;按住鼠标左键移动，&lt;B2-Motion&gt;和&lt;B3-Motion&gt;分别表示按住鼠标滑轮移动、右键移动&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;MouseWheel&gt;&lt;/td&gt;
&lt;td&gt;转动鼠标滑轮&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;Double-Button-1&gt;&lt;/td&gt;
&lt;td&gt;双击鼠标左键&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;Enter&gt;&lt;/td&gt;
&lt;td&gt;鼠标光标进入控件实例&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;Leave&gt;&lt;/td&gt;
&lt;td&gt;鼠标光标离开控件实例&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;Key&gt;&lt;/td&gt;
&lt;td&gt;按下键盘上的任意键&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;KeyPress-字母&gt;/&lt;KeyPress-数字&gt;&lt;/td&gt;
&lt;td&gt;按下键盘上的某一个字母或者数字键&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;KeyRelease&gt;&lt;/td&gt;
&lt;td&gt;释放键盘上的按键&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;Return&gt;&lt;/td&gt;
&lt;td&gt;回车键，其他同类型键有&lt;Shift&gt;/&lt;Tab&gt;/&lt;Control&gt;/&lt;Alt&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;Space&gt;&lt;/td&gt;
&lt;td&gt;空格键&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;UP&gt;/&lt;Down&gt;/&lt;Left&gt;/&lt;Right&gt;&lt;/td&gt;
&lt;td&gt;方向键&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;F1&gt;...&lt;F12&gt;&lt;/td&gt;
&lt;td&gt;常用的功能键&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;Control-Alt&gt;&lt;/td&gt;
&lt;td&gt;组合键，再比如&lt;Control-Shift-KeyPress-T&gt;，表示用户同时点击 Ctrl + Shift + T&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;FocusIn&gt;&lt;/td&gt;
&lt;td&gt;当控件获取焦点时候触发，比如鼠标点击输入控件输入内容，可以调用 focus_set() 方法使控件获得焦点&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;FocusOut&gt;&lt;/td&gt;
&lt;td&gt;当控件失去焦点时激活，比如当鼠标离开输入框的时候&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;Configure &gt;&lt;/td&gt;
&lt;td&gt;控件的发生改变的时候触发事件，比如调整了控件的大小等&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;Deactivate&gt;&lt;/td&gt;
&lt;td&gt;当控件的状态从“激活”变为“未激活”时触发事件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;Destroy&gt;&lt;/td&gt;
&lt;td&gt;当控件被销毁的时候触发执行事件的函数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;Expose&gt;&lt;/td&gt;
&lt;td&gt;当窗口或组件的某部分不再被覆盖的时候触发事件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;Visibility&gt;&lt;/td&gt;
&lt;td&gt;当应用程序至少有一部分在屏幕中是可见状态时触发事件&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;event_1&#34;&gt;Event事件对象&lt;/h4&gt;
&lt;p&gt;当事件触发后，Tkinter 会自动将事件对象交给回调函数进行下步的处理，Event 对象包含了以下常用属性：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;widget&lt;/td&gt;
&lt;td&gt;发生事件的是哪一个控件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;x,y&lt;/td&gt;
&lt;td&gt;相对于窗口的左上角而言，当前鼠标的坐标位置&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;x_root,y_root&lt;/td&gt;
&lt;td&gt;相对于屏幕的左上角而言，当前鼠标的坐标位置&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;char&lt;/td&gt;
&lt;td&gt;用来显示所按键相对应的字符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;keysym&lt;/td&gt;
&lt;td&gt;按键名，比如 Control_L 表示左边的 Ctrl 按键&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;keycode&lt;/td&gt;
&lt;td&gt;按键码，一个按键的数字编号，比如 Delete 按键码是107&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;num&lt;/td&gt;
&lt;td&gt;1/2/3中的一个，表示点击了鼠标的哪个按键，按键分为左、中、右&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;width,height&lt;/td&gt;
&lt;td&gt;控件的修改后的尺寸，对应着 &lt;Configure&gt;事件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;type&lt;/td&gt;
&lt;td&gt;事件类型&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;下面看一组关于“键盘事件”的使用示例：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;from tkinter import *
# 定义事件函数，必须用event参数
def show_key(event):
    # 查看触发事件的按钮
    s=event.keysym
    # 将其显示在按钮控件上
    lb.config(text=s)

root=Tk()
root.config(bg=&#39;#87CEEB&#39;)
root.title(&amp;quot;破污噗&amp;quot;)
root.geometry(&#39;450x350+300+200&#39;)
root.iconbitmap(&#39;favicon.ico&#39;)
# 添加一个按钮控件
lb=Label(root,text=&#39;请按键&#39;,fg=&#39;blue&#39;,font=(&#39;微软雅黑&#39;,15))
# 给按钮控件绑定事件，按下任意键，然后调用事件处理函数。注意，此处需要在英文状态下进行输入
lb.bind(&#39;&amp;lt;Key&amp;gt;&#39;,show_key)
# 设置按钮获取焦点
lb.focus_set()
lb.pack()
# 显示窗口
root.mainloop()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意：在上述示例中，只有当 Label 控件获取焦点后才能接收键盘事件，因此在给控件绑定事件和回调函数后，需要使用 focus_set() 方法来获取焦点。&lt;/p&gt;
&lt;p&gt;下面再看一组关于“鼠标事件”的相关示例：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;# 定义事件函数
from tkinter import *

def handleMotion(event):
    lb1[&#39;text&#39;] = &#39;你移动了光标的所在位置&#39;
    lb2[&#39;text&#39;] = &#39;目前光标位置：x =&#39;+ str(event.x)+&#39;;y=&#39;+str(event.y)
    print(&#39;光标当前位置&#39;,event.x,event.y)

# 创建主窗口
win = Tk()
win.config(bg=&#39;#87CEEB&#39;)
win.title(&amp;quot;破污噗&amp;quot;)
win.geometry(&#39;450x350+300+200&#39;)
win.iconbitmap(&#39;favicon.ico&#39;)
# 创建一个窗体容器frame
frame = Frame (win, relief=RAISED, borderwidth=2, width=300,height=200)
frame.bind(&#39;&amp;lt;Motion&amp;gt;&#39;,handleMotion)
lb1 = Label(frame,text=&#39;没有任何事件触发&#39;)
# 使用place进行位置布局，下一节会介绍
lb1.place (x=20,y=20)
lb2 = Label(frame,text=&#39;&#39;)
lb2.place (x=16,y=60)
frame.pack(side=TOP)
# 显示窗口
win.mainloop()
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;packgridplace&#34;&gt;布局管理器（pack，grid，place）&lt;/h3&gt;
&lt;p&gt;Tkinter 提供了三种常用的布局管理器，分别是 pack()、grid() 以及 place()，如下表所示：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;方法&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;pack()&lt;/td&gt;
&lt;td&gt;按照控件的添加顺序其进行排列，遗憾的是此方法灵活性较差&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;grid()&lt;/td&gt;
&lt;td&gt;以行和列（网格）形式对控件进行排列，此种方法使用起来较为灵活&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;place()&lt;/td&gt;
&lt;td&gt;可以指定组件大小以及摆放位置，三个方法中最为灵活的布局方法&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;pack&#34;&gt;pack()&lt;/h4&gt;
&lt;p&gt;pack() 是一种较为简单的布局方法，在不使用任何参数的情况下，它会将控件以添加时的先后顺序，自上而下，一行一行的进行排列，并且默认居中显示。pack() 方法的常用参数如下所示：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;anchor&lt;/td&gt;
&lt;td&gt;组件在窗口中的对齐方式，有 9 个方位参数值，比如&#34;n&#34;/&#34;w&#34;/&#34;s&#34;/&#34;e&#34;/&#34;ne&#34;，以及 &#34;center&#34; 等（这里的 e w s n分别代表，东西南北）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;expand&lt;/td&gt;
&lt;td&gt;是否可扩展窗口，参数值为 True（扩展）或者 False（不扩展），默认为 False，若设置为 True，则控件的位置始终位于窗口的中央位置&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;fill&lt;/td&gt;
&lt;td&gt;参数值为 X/Y/BOTH/NONE，表示允许控件在水平/垂直/同时在两个方向上进行拉伸，比如当 fill = X 时，控件会占满水平方向上的所有剩余的空间。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ipadx,ipady&lt;/td&gt;
&lt;td&gt;需要与 fill 参数值共同使用，表示组件与内容和组件边框的距离（内边距），比如文本内容和组件边框的距离，单位为像素(p)，或者厘米(c)、英寸(i)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;padx,pady&lt;/td&gt;
&lt;td&gt;用于控制组件之间的上下、左右的距离（外边距），单位为像素(p)，或者厘米(c)、英寸(i)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;side&lt;/td&gt;
&lt;td&gt;组件放置在窗口的哪个位置上，参数值 &#39;top&#39;,&#39;bottom&#39;,&#39;left&#39;,&#39;right&#39;。注意，单词小写时需要使用字符串格式，若为大写单词则不必使用字符串格式&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;下面看一组简单的使用示例：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;from tkinter import  *
win = Tk()
win.title(&amp;quot;破污噗&amp;quot;)
win.geometry(&#39;450x300+300+300&#39;)
win.iconbitmap(&#39;favicon.ico&#39;)

lb_red = Label(win,text=&amp;quot;红色&amp;quot;,bg=&amp;quot;Red&amp;quot;,fg=&#39;#ffffff&#39;,relief=GROOVE)
# 默认以top方式放置
lb_red.pack()
lb_blue = Label(win,text=&amp;quot;蓝色&amp;quot;,bg=&amp;quot;blue&amp;quot;,fg=&#39;#ffffff&#39;,relief=GROOVE)
# 沿着水平方向填充，使用 pady 控制蓝色标签与其他标签的上下距离为 5 个像素
lb_blue.pack(fill=X,pady=&#39;5px&#39;)
lb_green = Label(win,text=&amp;quot;绿色&amp;quot;,bg=&amp;quot;green&amp;quot;,fg=&#39;#ffffff&#39;,relief=RAISED)
# 将 黄色标签所在区域都填充为黄色，当使用 fill 参数时，必须设置 expand = 1，否则不能生效
lb_green.pack(side=LEFT,expand=1,fill = BOTH)
win.mainloop()
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;grid&#34;&gt;grid()&lt;/h4&gt;
&lt;p&gt;grid() 函数是一种基于网格式的布局管理方法，相当于把窗口看成了一张由行和列组成的表格。当使用该 grid 函数进行布局的时，表格内的每个单元格都可以放置一个控件。，从而实现对界面的布局管理。&lt;/p&gt;
&lt;p&gt;注意：这里的所说的“表格”是虚拟出来，目的是便于大家理解，其实窗体并不会因为使用了 gird() 函数，而增加一个表格。&lt;/p&gt;
&lt;p&gt;grid() 函数的常用参数如下所示：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;column&lt;/td&gt;
&lt;td&gt;控件位于表格中的第几列，窗体最左边的为起始列，默认为第 0 列&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;columnsapn&lt;/td&gt;
&lt;td&gt;控件实例所跨的列数，默认为 1 列，通过该参数可以合并一行中多个领近单元格。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ipadx,ipady&lt;/td&gt;
&lt;td&gt;用于控制内边距，在单元格内部，左右、上下方向上填充指定大小的空间。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;padx,pady&lt;/td&gt;
&lt;td&gt;用于控制外边距，在单元格外部，左右、上下方向上填充指定大小的空间。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;row&lt;/td&gt;
&lt;td&gt;控件位于表格中的第几行，窗体最上面为起始行，默认为第 0 行&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;rowspan&lt;/td&gt;
&lt;td&gt;控件实例所跨的行数，默认为 1 行，通过该参数可以合并一列中多个领近单元格。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;sticky&lt;/td&gt;
&lt;td&gt;该属性用来设置控件位于单元格那个方位上，参数值和 anchor 相同，若不设置该参数则控件在单元格内居中&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;grid() 方法相比 pack() 方法来说要更加灵活，以网格的方式对组件进行布局管理，让整个布局显得非常简洁、优雅。如果说非要从三个布局管理器中选择一个使用的话，那么我推荐大家使用 grid() 方法。&lt;/p&gt;
&lt;p&gt;这里有一点需要大家要特别注意，在一个程序中不能同时使用 pack() 和 grid() 方法，这两个方法只能二选一，否则程序会运行错误。&lt;/p&gt;
&lt;p&gt;下面看一组有关 grid() 函数的简单的示例：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;from tkinter import *
#主窗口
win = Tk()
win.config(bg=&#39;#87CEEB&#39;)
win.title(&amp;quot;破污噗&amp;quot;)
win.geometry(&#39;500x350+300+300&#39;)
win.iconbitmap(&#39;favicon.ico&#39;)

#在窗口内创建按钮，以表格的形式依次排列
for i in range (10):
    for j in range (10):
        Button (win, text=&amp;quot; (&amp;quot; + str(i) + &amp;quot;,&amp;quot;+ str(j)+ &amp;quot;)&amp;quot;,bg=&#39;#D1EEEE&#39;) .grid(row=i,column=j)

# 在第5行第11列添加一个Label标签
Label(win,text=&amp;quot;张小白&amp;quot;,fg=&#39;blue&#39;,font=(&#39;楷体&#39;,12,&#39;bold&#39;)).grid(row =4,column=11)
#开始窗口的事件循环
win. mainloop()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当使用 grid 函数布局的时，其实就是为各个控件指定行号、列号的过程，我们不需要为每个单元格指定大小，因为 grid 会为每个单元格自动设置一个适合的尺寸。&lt;/p&gt;
&lt;p&gt;下面通过 grid() 布局管理器制作一个简易的登录界面，代码如下所示：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;import tkinter as tk
from tkinter import messagebox

root = tk.Tk()
root.title(&amp;quot;破污噗&amp;quot;)

root.iconbitmap(&#39;favicon.ico&#39;)
root.resizable(0,0)
tk.Label(root, text=&amp;quot;用户名&amp;quot;).grid(row=0, sticky=&amp;quot;w&amp;quot;)
tk.Label(root, text=&amp;quot;密码&amp;quot;).grid(row=1, sticky=&amp;quot;w&amp;quot;)
tk.Entry(root).grid(row=0, column=1)
tk.Entry(root, show=&amp;quot;*&amp;quot;).grid(row=1, column=1)
# 加载图片LOGO,注意这里是gif格式的图片
photo = tk.PhotoImage(file=&amp;quot;agree.png&amp;quot;)
tk.Label(root, image=photo).grid(row=0, column=2, rowspan=2, padx=&#39;4px&#39;, pady=&#39;5px&#39;)
# 编写一个简单的回调函数
def login():
    messagebox.showinfo(&#39;恭喜你发现了宝藏文章!&#39;)

# 使用grid()函数来布局，并控制按钮的显示位置
tk.Button(root, text=&amp;quot;登录&amp;quot;, width=10, command=login).grid(row=3, column=0, columnspan=2,sticky=&amp;quot;w&amp;quot;, padx=10, pady=5)
tk.Button(root, text=&amp;quot;退出&amp;quot;, width=10, command=root.quit).grid(row=3, column=1, columnspan=2,sticky=&amp;quot;e&amp;quot;, padx=10, pady=5)
# 开启事件主循环
root.mainloop()
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;place&#34;&gt;place()&lt;/h4&gt;
&lt;p&gt;与前两种布局方法相比，采用 place() 方法进行布局管理要更加精细化，通过 place() 布局管理器可以直接指定控件在窗体内的绝对位置，或者相对于其他控件定位的相对位置。&lt;/p&gt;
&lt;p&gt;下面对 place 布局管理器的常用属性做相关介绍：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;anchor&lt;/td&gt;
&lt;td&gt;定义控件在窗体内的方位，参数值N/NE/E/SE/S/SW/W/NW 或 CENTER，默认值是 NW&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;bordermode&lt;/td&gt;
&lt;td&gt;定义控件的坐标是否要考虑边界的宽度，参数值为 OUTSIDE（排除边界） 或 INSIDE（包含边界），默认值 INSIDE。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;x、y&lt;/td&gt;
&lt;td&gt;定义控件在根窗体中水平和垂直方向上的起始绝对位置&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;relx、rely&lt;/td&gt;
&lt;td&gt;1. 定义控件相对于根窗口（或其他控件）在水平和垂直方向上的相对位置（即位移比例），取值范围再 0.0~1.0 之间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2. 可设置 in_ 参数项，相对于某个其他控件的位置&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;height、width&lt;/td&gt;
&lt;td&gt;控件自身的高度和宽度（单位为像素）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;relheight、relwidth&lt;/td&gt;
&lt;td&gt;控件高度和宽度相对于根窗体高度和宽度的比例，取值也在 0.0~1.0 之间&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;通过上述描述我们知道，relx和rely参数指定的是控件相对于父组件的位置，而relwidth和relheight参数则是指定控件相对于父组件的尺寸大小。&lt;/p&gt;
&lt;p&gt;注意：这里父组件指的是当前可操作控件的上层组件，比如在没有使用容器控件（frame）的窗体中，控件的父组件就是主窗口本身。&lt;/p&gt;
&lt;p&gt;上述表格中关于距离位置的参数容易产生“疑惑”，下面通过一组简单的示例来进一步说明：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;from tkinter import *
#主窗口
win = Tk()
win.title(&amp;quot;破污噗&amp;quot;)
win.iconbitmap(&#39;favicon.ico&#39;)
#创建一个frame窗体对象，用来包裹标签
frame = Frame(win, relief=SUNKEN, borderwidth=2, width=450, height=250)
# 在水平、垂直方向上填充窗体
frame.pack(side=TOP, fill=BOTH, expand=1)

# 创建 &amp;quot;位置1&amp;quot;
Label1 = Label(frame, text=&amp;quot;位置1&amp;quot;,bg=&#39;blue&#39;,fg=&#39;white&#39;)
# 使用 place,设置第一个标签位于距离窗体左上角的位置（40,40）和其大小（width，height）
# 注意这里（x,y）位置坐标指的是标签左上角的位置（以NW左上角进行绝对定位，默认为NW）
Label1.place(x=40,y=40, width=60, height=30)

# 设置标签2
Label2 = Label(frame, text=&amp;quot;位置2&amp;quot;,bg=&#39;purple&#39;,fg=&#39;white&#39;)
# 以右上角进行绝对值定位，anchor=NE，第二个标签的位置在距离窗体左上角的(180，80)
Label2.place(x=180,y=80, anchor=NE, width=60, height=30)

# 设置标签3
Label3 = Label (frame, text=&amp;quot;位置3&amp;quot;,bg=&#39;green&#39;,fg=&#39;white&#39;)
# 设置水平起始位置相对于窗体水平距离的0.6倍，垂直的绝对距离为80，大小为60，30
Label3.place(relx=0.6,y=80, width=60, height=30)

# 设置标签4
Label4 = Label (frame, text=&amp;quot;位置4&amp;quot;,bg=&#39;gray&#39;,fg=&#39;white&#39;)
# 设置水平起始位置相对于窗体水平距离的0.01倍，垂直的绝对距离为80，并设置高度为窗体高度比例的0.5倍，宽度为80
Label4.place(relx=0.01,y=80,relheight=0.4,width=80)
#开始事件循环
win. mainloop()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意：在一个父组件中 place()方法可以与 grid() 方法混合使用，要与 pack() 进行区别。&lt;/p&gt;
&lt;h3 id=&#34;_21&#34;&gt;布局管理控件&lt;/h3&gt;
&lt;p&gt;这里介绍了三种常用的容器控件以及它们的使用方法，分别是 Frame、LabelFrame、PanedWindow &lt;/p&gt;
&lt;h4 id=&#34;frame&#34;&gt;Frame控件&lt;/h4&gt;
&lt;p&gt;Frame 本质上也是一个矩形窗体，同其他控件一样也需要位于主窗口内。我们可以在主窗口内放置多个 Frame 控件，并且每个 Frame 中还可以嵌套一个或者多个Frame，从而将主窗口界面划分成多个区域。&lt;/p&gt;
&lt;p&gt;Frame 控件的常用属性如下表所示：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;bg&lt;/td&gt;
&lt;td&gt;设置 Frame 的背景颜色&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;bd&lt;/td&gt;
&lt;td&gt;指定 Frame 的边框宽度&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;colormap&lt;/td&gt;
&lt;td&gt;指定  Frame 组件及其子组件的颜色映射&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;container&lt;/td&gt;
&lt;td&gt;布尔值参数，若参数值为 True，则窗体将被用作容器使用，一些其他程序也可以被嵌入。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;cursor&lt;/td&gt;
&lt;td&gt;指定鼠标在 Frame 上飘过的鼠标样式，默认由系统指定&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;height/width&lt;/td&gt;
&lt;td&gt;设置 Frame 的高度和宽度&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;highlightbackground&lt;/td&gt;
&lt;td&gt;指定当 Frame 没有获得焦点的时候高亮边框的颜色，通常由系统指定为标准颜色&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;highlightcolor&lt;/td&gt;
&lt;td&gt;指定当 Frame 获得焦点的时候高亮边框的颜色&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;highlightthickness&lt;/td&gt;
&lt;td&gt;指定高亮边框的宽度，默认值是 0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;padx/pady&lt;/td&gt;
&lt;td&gt;距离主窗口在水平/垂直方向上的外边距&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;relief&lt;/td&gt;
&lt;td&gt;指定边框的样式，参数值 &#34;sunken&#34;，&#34;raised&#34;，&#34;groove&#34; 或 &#34;ridge&#34;，&#34;flat&#34;，默认为 &#34;falt&#39;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;takefocus&lt;/td&gt;
&lt;td&gt;布尔值参数，默认为 False，指定该组件是否接受输入焦点（即用户通过 Tab 键将焦点转移上来）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;下面看一组简单的示例，通过 Frame 将主窗口分成左右两个部分，如下所示：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;import tkinter as tk

win = tk.Tk()
win.title(&amp;quot;破污噗&amp;quot;)
win.geometry(&#39;400x350+200+200&#39;)
win.iconbitmap(&#39;favicon.ico&#39;)

# 在主窗口上添加一个frame控件
frame1 = tk.Frame(win)
frame1.pack()

# 在frame_1上添加另外两个frame， 一个在靠左，一个靠右
# 左侧的frame
frame_left = tk.Frame(frame1)
tk.Label(frame_left,text=&#39;左侧标签1&#39;,bg=&#39;green&#39;,width=10,height=5).grid(row =0,column=0)
tk.Label(frame_left,text=&#39;左侧标签2&#39;,bg=&#39;blue&#39;,width=10,height=5).grid(row = 1 ,column =1)
frame_left.pack(side=tk.LEFT)

frame_right = tk.Frame(frame1)
tk.Label(frame_right,text=&#39;右侧标签1&#39;,bg=&#39;gray&#39;,width=10,height=5).grid(row = 0 ,column =1)
tk.Label(frame_right,text=&#39;右侧标签2&#39;,bg=&#39;pink&#39;,width=10,height=5).grid(row = 1 ,column =0)
tk.Label(frame_right,text=&#39;右侧标签3&#39;,bg=&#39;purple&#39;,width=10,height=5).grid(row= 1,column=1)
frame_right.pack(side=tk.RIGHT)
win.mainloop()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上述示例利用 Frame 控件将主窗口分成了左右两个子区域，同时在各自区域中添加了 Label 标签，而且区域之间互不干扰。采用这种分区、分块的布局方式，可以使得 GUI 程序更加规范、简洁化。&lt;/p&gt;
&lt;h4 id=&#34;labelframe&#34;&gt;LabelFrame控件&lt;/h4&gt;
&lt;p&gt;LabelFrame 控件也是一种容器类型的控件，它属于是 Frame 控件的变体，因此它们的属性选项大体相同。
在默认情况下，LabelFrame 会在其包裹的子组件周围绘制一个边框和一个标题。当我们想要将一些相关的组件分为一组时，就可以使用 LabelFrame 组件，比如把一系列 Radiobutton（单选按钮）放在一起来供用户选择。
同 Frame 控件一样，LabelFrame 的主要作用也是对控件进行分组处理，下面看一个具体的实例：&lt;/p&gt;
&lt;h4 id=&#34;panedwindow&#34;&gt;PanedWindow控件&lt;/h4&gt;
&lt;p&gt;PanedWindow（窗格界面）也可以理解成一个特殊的 Frame 控件，它是 Tkinter 8.4 版本后新增的空间管理组件，其主要目的是为其他组件提供一个容器或者框架，从而实现以分块的形式对图形界面进行布局。&lt;/p&gt;
&lt;p&gt;与 Frame 控件不同， PanedWindow 允许用户自主地调整界面划分以及每块区域的大小。因此，当您需要让用户自己调节每块区域的大小时，就可以采用 PanedWindow 作为组件载体来进行界面的布局。&lt;/p&gt;
&lt;p&gt;不仅如此 PanedWindow 组件还提供了“手柄” 功能（设置参数 showhandle=True 来启用），通过拖动“手柄”图标也可以改变每块区域的大小。&lt;/p&gt;
&lt;p&gt;其中 master 表示父组件，即包裹该组件的上层组件。其常用属性如下表所示：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;handlepad&lt;/td&gt;
&lt;td&gt;1. 调节“手柄”的位置&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2. 比如当 orient =&#39;vertical&#39; 设置垂直时，handlepad 表示“分割线”上的手柄与左端的距离，默认为 8 像素&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;handlesize&lt;/td&gt;
&lt;td&gt;设置“手柄”的尺寸（由于“手柄”必须是一个正方形，所以是设置正方形的边长）默认为 8 像素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;opaqueresize&lt;/td&gt;
&lt;td&gt;1. 该选项定义了用户调整窗格尺寸的操作，如果该选项的值为 True（默认），窗格的尺寸随用户鼠标的拖拽而改变&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2.  如果该选项的值为 False，那么窗格的尺寸，在用户释放鼠标时才会更新到新的位置上&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;orient&lt;/td&gt;
&lt;td&gt;指定窗格的分布方式，默认为水平方向分布（&#34;horizontal&#34;），或者还可以设置为垂直纵向分布（&#34;vertical&#34;）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;relif&lt;/td&gt;
&lt;td&gt;指定边框的样式，默认为 &#34;flat&#34;，还可以设置为  &#34;sunken&#34;，&#34;raised&#34;，&#34;groove&#34; 或 &#34;ridge&#34;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;sashpad&lt;/td&gt;
&lt;td&gt;设置每一条分割线到窗格间的间距&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;sashrelief&lt;/td&gt;
&lt;td&gt;设置分割线的样式，默认值是：&#34;flat&#34;，还可以设置 &#34;sunken&#34;，&#34;raised&#34;，&#34;groove&#34; 或 &#34;ridge&#34;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;sashwidth&lt;/td&gt;
&lt;td&gt;设置分割线的宽度&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;showhandle&lt;/td&gt;
&lt;td&gt;设置是否显示调节窗格的手柄，默认为 False&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;height/width&lt;/td&gt;
&lt;td&gt;设置 PanedWindow 的高度、宽度，若不设置，则其大小由其子组件的尺寸决定&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;PanedWindow 的常用方法如下表所示：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;方法&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;add(child)&lt;/td&gt;
&lt;td&gt;添加一个新的子组件到窗格中语法格式 add(child,**option)，参数值 after、before、sticky&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;forget(child)&lt;/td&gt;
&lt;td&gt;删除一个子组件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;panecget(child, option)&lt;/td&gt;
&lt;td&gt;获得子组件指定选项的值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;paneconfig(child, **options)&lt;/td&gt;
&lt;td&gt;设置子组件的各种选项&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;panes()&lt;/td&gt;
&lt;td&gt;将父组件中包含的子组件以列表的形式返回&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;sash_coord(index)&lt;/td&gt;
&lt;td&gt;返回一个二元组表示指定分割线的起点坐标&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;sash_place(index, x, y)&lt;/td&gt;
&lt;td&gt;将指定的分割线移动到一个新的位置&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;下面示例设计一个简单的界面布局，然后将图形界面分割成四部分：创建一个水平方向的 PanedWindow，并向其中添加两个 Label 组件，之后创建一个垂直的方向的 PanedWindow，并向其中中添加两个 Label 标签。示例代码如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;import tkinter as tk
win = tk.Tk()
win.title(&amp;quot;破污噗&amp;quot;)
win.geometry(&#39;400x400+200+200&#39;)
win.iconbitmap(&#39;favicon.ico&#39;)
# 创建一个水平方向的 panedwindow，并添加到主窗口中，默认为水平方向
p_window1 = tk.PanedWindow(win)
p_window1.pack(fill=tk.BOTH, expand=1)
# 在窗口区的左侧添加两个水平方向的 Label
left1 =tk. Label(p_window1, text=&#39;百度&#39;, bg=&#39;#7CCD7C&#39;, width=10,font=(&#39;微软雅黑&#39;,15))
p_window1.add(left1)
left2 =tk.Label(p_window1, text=&#39;网址：www.baidu.com&#39;, bg=&#39;#9AC0CD&#39;, width=10,font=(&#39;微软雅黑&#39;,15))
p_window1.add(left2)

# 创建一个垂直方向的panedwindow,并添加一个手柄，设置分割线样式
p_window2 = tk.PanedWindow(orient=tk.VERTICAL,showhandle=True,sashrelief=&#39;sunken&#39;)
# 添加到 p_window1中
p_window1.add(p_window2)
# 在 p_window2 中添加两个垂直方向的标签
top_label =tk. Label(p_window2, text=&#39;教程&#39;, bg=&#39;#7171C6&#39;, height=8,font=(&#39;宋体&#39;,15))
p_window2.add(top_label)
bottom_label =tk. Label(p_window2, text=&#39;辅导班&#39;, bg=&#39;#8968CD&#39;,font=(&#39;宋体&#39;,15))
p_window2.add(bottom_label)

win.mainloop()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意：从上述示例中可以看出 PanedWindw 会为每一个 Label 控件创建一个独立的窗格， 当我们将鼠标悬停在两个控件接壤处的白色边框上时，就会出现可以上下或者左右拉伸的指示光标，用户按照可以按照自己的意愿来调整每块区域的大小。&lt;/p&gt;
&lt;h3 id=&#34;_22&#34;&gt;对话框控件&lt;/h3&gt;
&lt;p&gt;在前面，我们花费了大量的时间讲解了 Tkinter 中常用基本控件，通过对这些控件的学习，我们对  GUI 开发有了基本的认识与掌握，一个完整的 GUI 程序就是由这些组件以合理、美观的布局方式构成的。
除了基本的控件之外，Tkinter 还提供了三种对话框控件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;文件选择对话框：filedailog&lt;/li&gt;
&lt;li&gt;颜色选择对话框：colorchooser&lt;/li&gt;
&lt;li&gt;消息对话框：messagebox&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些对话框的使用能够在一定程度上增强用户的交互体验，下面对这些对话框控件进行详细地介绍。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;文件选择对话框&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;文件对话框在 GUI 程序中经常的使用到，比如上传文档需要从本地选择一个文件，包括文件的打开和保存功能都需要一个文件对话框来实现。Tkinter 提供文件对话框被封装在tkinter.filedailog模块中，该模块提供了有关文件对话框的常用函数，经常使用的有以下几个：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;方法&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Open()&lt;/td&gt;
&lt;td&gt;打开个某个文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SaveAs()&lt;/td&gt;
&lt;td&gt;打开一个保存文件的对话框&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;askopenfilename()&lt;/td&gt;
&lt;td&gt;打开某个文件，并以包函文件名的路径作为返回值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;askopenfilenames()&lt;/td&gt;
&lt;td&gt;同时打开多个文件，并以元组形式返回多个文件名&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;askopenfile()&lt;/td&gt;
&lt;td&gt;打开文件，并返回文件流对象&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;askopenfiles()&lt;/td&gt;
&lt;td&gt;打开多个文件，并以列表形式返回多个文件流对象&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;asksaveasfilename()&lt;/td&gt;
&lt;td&gt;选择以什么文件名保存文件，并返回文件名&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;asksaveasfile()&lt;/td&gt;
&lt;td&gt;选择以什么类型保存文件，并返回文件流对象&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;askdirectory&lt;/td&gt;
&lt;td&gt;选择目录，并返回目录名&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;上述方法的常用参数值如下所示：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;参数&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;defaultextension&lt;/td&gt;
&lt;td&gt;指定文件的后缀名，当保存文件时自动添加文件名，如果自动添加了文件的后缀名，则该选项值不会生效&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;filetypes&lt;/td&gt;
&lt;td&gt;指定筛选文件类型的下拉菜单选项，该选项值是由 2 元祖构成的列表，其中每个二元祖由两部分组成 (类型名,后缀)，比如 filetypes = [(&#34;PNG&#34;,&#34;&lt;em&gt;.png&#34;), (&#34;JPG&#34;, &#34;&lt;/em&gt;.jpg&#34;), (&#34;GIF&#34;,&#34;&lt;em&gt;.gif&#34;),(&#34;文本文件&#34;,&#34;&lt;/em&gt;.txt&#34;)...]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;initialdir&lt;/td&gt;
&lt;td&gt;指定打开/保存文件的默认路径，默认路径是当前文件夹&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;parent&lt;/td&gt;
&lt;td&gt;如果不指定该选项，那么对话框默认显示在根窗口上，通过设置该参数可以使得对话框显示在子窗口上&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;title&lt;/td&gt;
&lt;td&gt;指定文件对话框的标题&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;下面看一组具体的实例应用：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;from tkinter import *
import tkinter.filedialog  # 注意次数要将文件对话框导入

# 定义一个处理文件的相关函数
def askfile():
    # 从本地选择一个文件，并返回文件的目录
    filename = tkinter.filedialog.askopenfilename()
    if filename != &#39;&#39;:
         lb.config(text= filename)
    else:
         lb.config(text=&#39;您没有选择任何文件&#39;)

root = Tk()
root.config(bg=&#39;#87CEEB&#39;)
root.title(&amp;quot;破污噗&amp;quot;)
root.geometry(&#39;400x200+300+300&#39;)
root.iconbitmap(&#39;favicon.ico&#39;)
btn=Button(root,text=&#39;选择文件&#39;,relief=RAISED,command=askfile)
btn.grid(row=0,column=0)
lb = Label(root,text=&#39;&#39;,bg=&#39;#87CEEB&#39;)
lb.grid(row=0,column=1,padx=5)
# 显示窗口
root.mainloop()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面再看一组“保存文件”的示例代码如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;import tkinter as tk
from tkinter import filedialog
from PIL import Image

def open_img():
    try:
        global img
        filepath = filedialog.askopenfilename() # 打开文件，返回该文件的完整路径
        filename.set(filepath)
        img = Image.open(filename.get())
    except Exception as e:
        print(&amp;quot;您没有选择任何文件&amp;quot;,e)


def save_png():
    try:

        filetypes = [(&amp;quot;PNG&amp;quot;,&amp;quot;*.png&amp;quot;), (&amp;quot;JPG&amp;quot;, &amp;quot;*.jpg&amp;quot;), (&amp;quot;GIF&amp;quot;,&amp;quot;*.gif&amp;quot;),(&amp;quot;txt files&amp;quot;,&amp;quot;*.txt&amp;quot;),(&#39;All files&#39;,&#39;*&#39;)]
        # 返回一个 pathname 文件路径字符串，如果取消或者关闭则返回空字符，返回文件如何操作是后续代码的事情，
        # 该函数知识返回选择文件的文件名字，不具备保存文件的能力
        filenewpath= filedialog.asksaveasfilename(title=&#39;保存文件&#39;,
                                                filetypes=filetypes,
                                                defaultextension=&#39;.png&#39;,
                                                initialdir=&#39;C:/Users/Administrator/Desktop&#39; )
        path_var.set(filenewpath)
        # 保存文件
        img.save(str(path_var.get()))
    except Exception as e:
        print(e)

window = tk.Tk()
window.title(&amp;quot;破污噗&amp;quot;)
window.geometry(&#39;400x200+300+300&#39;)
window.iconbitmap(&#39;favicon.ico&#39;)

filename = tk.StringVar()
path_var = tk.StringVar()
# 定义读取文件的组件
entry = tk.Entry(window, textvariable=filename)
entry.grid(row=1, column=0, padx=5, pady=5)
tk.Button(window, text=&#39;选择文件&#39;, command=open_img).grid(row=1, column=1, padx=5, pady=5)

# 定义保存文件的组件
entry1 = tk.Entry(window, textvariable=path_var)
entry1.grid(row=2, column=0, padx=5, pady=5)
tk.Button(window, text=&#39;保存文件&#39;, command=save_png).grid(row=2, column=1, padx=5, pady=5)
window.mainloop()
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;颜色选择对话框&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;颜色选择对话框（colorchooser），提供了一个非常友善的颜色面板，它允许用户选择自己所需要的颜色。 当用户在面板上选择一个颜色并按下“确定”按钮后，它会返回一个二元祖，其第 1 个元素是选择的 RGB 颜色值，第 2 个元素是对应的 16 进制颜色值。&lt;/p&gt;
&lt;p&gt;颜色选择对话款主要应用在画笔、涂鸦等功能上，通过它可以绘制出五彩缤纷的颜色，该对话框的使用非常简单，主要有以下两个常用方法：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;方法&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;askcolor()&lt;/td&gt;
&lt;td&gt;打开一个颜色对话框，并将用户选择的颜色值以元组的形式返回（没选择返回None），格式为((R, G, B), &#34;#rrggbb&#34;)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Chooser()&lt;/td&gt;
&lt;td&gt;打开一个颜色对话框，并用户选择颜色确定后，返回一个二元组，格式为（(R, G, B), &#34;#rrggbb&#34;）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;常用的颜色对话框的参数值如下表所示：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;default&lt;/td&gt;
&lt;td&gt;要显示的初始的颜色，默认颜色是浅灰色（light gray）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;title&lt;/td&gt;
&lt;td&gt;指定颜色选择器标题栏的文本，默认标题为“颜色”&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;parent&lt;/td&gt;
&lt;td&gt;1. 如果不指定该选项，那么对话框默认显示在根窗口上&lt;br /&gt;2. 如果想要将对话框显示在子窗口上，那么可以设置 parent = 子窗口对象&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;下面看一组简单的使用示例：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;import tkinter as tk
from tkinter import colorchooser
root = tk.Tk()
root.title(&amp;quot;颜色选择&amp;quot;)
root.geometry(&#39;400x200+300+300&#39;)
root.iconbitmap(&#39;favicon.ico&#39;)

def callback():
    # 打开颜色对话款
    colorvalue = tk.colorchooser.askcolor()
    # 在颜色面板点击确定后，会在窗口显示二元组颜色值
    lb.config(text=&#39;颜色值:&#39;+ str(colorvalue))

lb=tk.Label(root,text=&#39;&#39;,font=(&#39;宋体&#39;,10))
# 将label标签放置在主窗口
lb.pack()
tk.Button(root, text=&amp;quot;点击选择颜色&amp;quot;, command=callback, width=10, bg=&#39;#9AC0CD&#39;).pack()
# 显示界面
root.mainloop()
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;消息对话框&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;关于消息对话款（messagebox），在前面介绍其他控件时已经使用过，在这里仅对它做简单介绍。
消息对话框主要起到信息提示、警告、说明、询问等作用，通常配合“事件函数”一起使用，比如执行某个操作出现了错误，然后弹出错误消息提示框。通过使用消息对话框可以提升用户的交互体验，也使得 GUI 程序更加人性化。消息对话框主要包含了以下常用方法：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;方法&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;askokcancel(title=None, message=None)&lt;/td&gt;
&lt;td&gt;打开一个“确定／取消”的对话框&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;askquestion(title=None, message=None)&lt;/td&gt;
&lt;td&gt;打开一个“是／否”的对话框。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;askretrycancel(title=None, message=None)&lt;/td&gt;
&lt;td&gt;打开一个“重试／取消”的对话框&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;askyesno(title=None, message=None)&lt;/td&gt;
&lt;td&gt;打开一个“是／否”的对话框&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;showerror(title=None, message=None)&lt;/td&gt;
&lt;td&gt;打开一个错误提示对话框&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;showinfo(title=None, message=None)&lt;/td&gt;
&lt;td&gt;打开一个信息提示对话框&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;showwarning(title=None, message=None)&lt;/td&gt;
&lt;td&gt;打开一个警告提示对话框&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;上述方法拥有相同的选项参数，如下表所示：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;default&lt;/td&gt;
&lt;td&gt;1. 设置默认的按钮（也就是按下回车响应的那个按钮）&lt;br /&gt;2. 默认是第一个按钮（像“确定”，“是”或“重试”）&lt;br /&gt;3. 可以设置的值根据对话框函数的不同，可以选择 CANCEL，IGNORE，OK，NO，RETRY 或 YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;icon&lt;/td&gt;
&lt;td&gt;1. 指定对话框显示的图标&lt;br /&gt;2. 可以指定的值有：ERROR，INFO，QUESTION 或 WARNING&lt;br /&gt;3. 注意：不能指定自己的图标&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;parent&lt;/td&gt;
&lt;td&gt;1. 如果不指定该选项，那么对话框默认显示在根窗口上&lt;br /&gt;2. 如果想要将对话框显示在子窗口上，那么可以设置 parent= 子窗口对象&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;上述方法的返回值一般会是一个布尔值，或者是“YES”，“NO”，“OK”等，这些方法使用较为简单，此处不进行逐一列举。&lt;/p&gt;
&lt;h3 id=&#34;notebook&#34;&gt;Notebook&lt;/h3&gt;
&lt;p&gt;Notebook 是一个Widget 容器控件，这个控件的特点就是有许多选项卡，当选择不同选项卡时可以看到不同的子控件内容，也可以当做子窗口内容，Notebook 是属于tkinter.ttk模块的控件&lt;/p&gt;
&lt;p&gt;构造方法如下：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Notebook(父对象, options)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;参数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一个参数：父对象，表示这个选项卡将建立在哪一个窗口内&lt;/li&gt;
&lt;li&gt;第二个参数：options，参数如下&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;参数&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;height&lt;/td&gt;
&lt;td&gt;如果设置数值则使用设置高度&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;默认是使用最大可能高度&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;padding&lt;/td&gt;
&lt;td&gt;设置Notebook外围的额外空间，可以设置4个数值代表left、top、tight、bottom四周的空间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;width&lt;/td&gt;
&lt;td&gt;如果设置数值则使用设置宽度&lt;br /&gt;默认是使用最大可能宽度&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;整个建立Notebook框架的步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Notebook()建立Notebook对象，假设对象名称是notebook&lt;/li&gt;
&lt;li&gt;使用notebook对象调用add()方法&lt;/li&gt;
&lt;li&gt;add(子对象, text=&#39;xxx&#39;)&lt;/li&gt;
&lt;li&gt;xxx是要添加的选项卡名称&lt;/li&gt;
&lt;li&gt;上述代码可以将子对象插入notebook，同时产生’xxx’选项卡名称&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果用正规语法表示add()方法，它的语法格式如下&lt;/p&gt;
&lt;p&gt;&lt;code&gt;add(子对象, options)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;options参数如下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;参数&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;compound&lt;/td&gt;
&lt;td&gt;可以设置当选项卡内同时含图像和文字时，彼此之间的位置关系&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;image&lt;/td&gt;
&lt;td&gt;选项卡以图像方式呈现&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;padding&lt;/td&gt;
&lt;td&gt;设置Notebook和面板Pane的额外空间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;state&lt;/td&gt;
&lt;td&gt;可能值是normal、disabled、hidden&lt;br /&gt;如果是disabled表示无法被选取使用&lt;br /&gt;如果是hidden表示被隐藏&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;sticky&lt;/td&gt;
&lt;td&gt;指出子窗口面板的配置方式，n/s/e/w分别表示North、South、East、West&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;text&lt;/td&gt;
&lt;td&gt;选项卡中的字符串内容&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;underline&lt;/td&gt;
&lt;td&gt;指出第几个字母含下划线&lt;br /&gt;从0开始计算的索引&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Notebook 基本应用&lt;/p&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;import tkinter
import tkinter.ttk
root = tkinter.Tk()
root.geometry(&#39;300x180&#39;)

notebook = tkinter.ttk.Notebook(root)

frameOne = tkinter.Frame()
frameTwo = tkinter.Frame()

notebook.add(frameOne, text=&#39;选项卡1&#39;)
notebook.add(frameTwo, text=&#39;选项卡2&#39;)
notebook.pack(padx=10, pady=5, fill=tkinter.BOTH, expand=True)

root.mainloop()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;绑定选项卡与子控件内容&lt;/p&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;import tkinter
import tkinter.ttk
root = tkinter.Tk()
root.geometry(&#39;150x120&#39;)

def show():
    labelOther.config(text=&#39;Tkinter&#39;)
    labelOther.config(bg=&#39;lightgreen&#39;)

notebook = tkinter.ttk.Notebook(root)

frameOne = tkinter.Frame()
frameTwo = tkinter.Frame()

# 添加内容
label = tkinter.Label(frameOne, text=&#39;Python&#39;, bg=&#39;lightblue&#39;, fg=&#39;red&#39;)
label.pack(padx=10, pady=5)

button = tkinter.Button(frameTwo, text=&#39;请点击&#39;, command=show)
button.pack(padx=10, pady=5)

labelOther = tkinter.Label(frameTwo, fg=&#39;red&#39;)
labelOther.pack(padx=10, pady=5)

notebook.add(frameOne, text=&#39;选项卡1&#39;)
notebook.add(frameTwo, text=&#39;选项卡2&#39;)
notebook.pack(padx=10, pady=5, fill=tkinter.BOTH, expand=True)

root.mainloop()
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;_23&#34;&gt;构建桌面软件模板&lt;/h3&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;#!/usr/bin/env python3
# coding=utf-8

from tkinter import *
from tkinter import ttk
import os

__author__ = {&#39;name&#39; : &#39;TestPoo&#39;, &#39;created&#39; : &#39;2022-05-05&#39;, &#39;modify&#39; : &#39;2022-11-14&#39;}

#**实现界面功能****
class Application_ui(Frame):
    def __init__(self, master=None):
        Frame.__init__(self, master)
        self.master.title(&#39;万年历&#39;)
        self.master[&amp;quot;bg&amp;quot;]=&#39;#fff&#39;
        self.createWidgets()
        self.position()


    def position(self):
        top.resizable(False,False)
        curWidth = 900
        curHeight = 600
        scnWidth,scnHeight = top.maxsize()
        tmpplace = &#39;%dx%d+%d+%d&#39;%(curWidth,curHeight,(scnWidth-curWidth)/2,(scnHeight-curHeight)/2)
        top.geometry(tmpplace)
        top.iconphoto(False, PhotoImage(file=os.getcwd() + &#39;/calendar.png&#39;))

    def createWidgets(self):
        top = self.winfo_toplevel()

#**实现具体的事件处理回调函数****
class Application(Application_ui):
    def __init__(self, master=None):
        Application_ui.__init__(self, master)

if __name__ == &amp;quot;__main__&amp;quot;:
    top = Tk()
    Application(top).mainloop()
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;_24&#34;&gt;附录&lt;/h3&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;# 去年tkinter边框，包括标题栏
top.overrideredirect(True)

# linux下去掉标题栏，变身dock
top.attributes(&#39;-type&#39;, &#39;dock&#39;)

# 最上层显示
top.attributes(&amp;quot;-topmost&amp;quot;, True)

# 获取焦点
top.focus_force()

# 获取窗口宽度
curWidth = top.winfo_width()

# 获取窗口高度
curHeight = top.winfo_height()

# 获取屏幕宽度和高度
scnWidth,scnHeight = top.maxsize()

# 窗口居中
tmpplace = &#39;%dx%d+%d+%d&#39;%(curWidth,curHeight,(scnWidth-curWidth)/2,(scnHeight-curHeight)/2)

# 失去焦点时，关闭窗口
top.bind(&#39;&amp;lt;FocusOut&amp;gt;&#39;, self.lossfocus)
def lossfocus(self, event=None):
    if event.widget == top:
        top.destroy()

# ttk样式
self.style = ttk.Style()
self.style.theme_use(&#39;default&#39;)
self.style.configure(&amp;quot;TButton&amp;quot;,foreground=&amp;quot;#000&amp;quot;,background=&amp;quot;#fff&amp;quot;,borderwidth=0,font=(&#39;&#39;,config[&#39;fontSize&#39;]),justify=&#39;center&#39;,relief=FLAT)

# 原始样式
self.nextYear = Button(top,text=&amp;quot;▶&amp;quot;,command = self.next_year,fg=&amp;quot;#303133&amp;quot;,bg=&amp;quot;#fff&amp;quot;,bd=0,font=(&#39;Helvetica&#39;,12))

# tk屏幕大小
width = tk.winfo_screenwidth()
height = tk.winfo_screenheight()

# 重启当前程序
path = sys.executable
os.execl(path, &amp;quot;python&amp;quot;, * sys.argv)

# DPI缩放
#导入库
import ctypes
from tkinter import *
from tkinter.ttk import *

#创建窗口，root可替换成自己定义的窗口
root=Tk()
#调用api设置成由应用程序缩放
ctypes.windll.shcore.SetProcessDpiAwareness(1)
#调用api获得当前的缩放因子
ScaleFactor=ctypes.windll.shcore.GetScaleFactorForDevice(0)
#设置缩放因子
root.tk.call(&#39;tk&#39;, &#39;scaling&#39;, ScaleFactor/75)
&lt;/code&gt;&lt;/pre&gt;</description>  
      <pubDate>2025-10-09 17:54:40</pubDate>  
      <link>https://testpoo.github.io/tkinter教程.html</link>  
      <guid isPermaLink="true">https://testpoo.github.io/tkinter教程.html</guid>
       
      <category>技术</category> 
      
    </item>
    
    <item> 
      <title>面试问答</title>  
      <description>&lt;blockquote&gt;
&lt;p&gt;来源于网络搜集&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;你来我们公司的时候，有没有提前了解一下我公司的情况？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;考察面试者的自我学习能力与对将要做的事情的把控能力，避免盲目性，提高可塑性。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;你最近3~5年的职业规划是什么？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;考察面试者的职业发展方向是否与当前职位相符？从侧面看出其稳定性。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;请详细介绍一个你以前参与的项目，可以从做了什么、对你的帮助等内容介绍？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;考察面试者在以往的测试工作中的能力提升方面，可以看出其工作深度。另外，通过其介绍过程，可以了解面试者的沟通与交流能力。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;工作过程中，是否曾主动总结过什么东西与他人分享？具体案例？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;考察面试者的心态与学习能力，是否更容易融入团队。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通常做测试时会碰到，提交的某个bug开发人员不认同你的观点？这时你怎么办？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;考察面试者是否坚持自己的价值观？是否具备协调沟通处理问题能力。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有没有看过什么测试书，具体是哪本？带给你的收获是？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;考察面试者是否真正热爱测试职业，是否付出过努力。从中也可以看出这个测试人员是否有上进心？是否有求知心。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;某个项目上线后，出现问题，恰巧你负责的，你如何应对这突如其来的事件？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;考察面试者应对问题的压力，责任感，及处理问题的能力。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;你平时都有什么业余爱好？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;考察面试者的性格特点。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;编写过什么测试资料，文档编写能力如何？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;考察面试者的文字功底，尤其是测试人员，必须能够用文字表达自己的观点。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;你自己所期待加入的测试团队是什么样的？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;考察面试者在以前测试团队中有哪些不协调？当然，最重要的是，也能提供给你一些信息，这个员工以后如何更好地管理与沟通！&lt;/p&gt;</description>  
      <pubDate>2025-10-09 17:54:40</pubDate>  
      <link>https://testpoo.github.io/面试问答.html</link>  
      <guid isPermaLink="true">https://testpoo.github.io/面试问答.html</guid>
       
      <category>摘录</category> 
      
    </item>
    
    <item> 
      <title>UI自动化测试神器-Cypress</title>  
      <description>&lt;div class=&#34;toc&#34;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1&#34;&gt;1. 简介&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#11-cypress&#34;&gt;1.1 谁能使用 Cypress ？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#12-cypress&#34;&gt;1.2 Cypress 生态系统&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#13&#34;&gt;1.3 特性&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#131&#34;&gt;1.3.1 设置测试&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#132&#34;&gt;1.3.2 编写测试&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#133&#34;&gt;1.3.3 运行测试&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#134&#34;&gt;1.3.4 调试测试&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2&#34;&gt;2. 环境搭建&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#21-node&#34;&gt;2.1 安装node&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#22-cypress&#34;&gt;2.2 安装Cypress&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#23-cypress&#34;&gt;2.3 打开Cypress&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#23-npm&#34;&gt;2.3 添加npm脚本&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3-e2e&#34;&gt;3. 编写第一个E2E测试用例&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4&#34;&gt;4. 写你第一个自己的测试用例&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5&#34;&gt;5. 写一个真正的测试用例&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#6&#34;&gt;6. 执行测试用例&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#61&#34;&gt;6.1 测试策略&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#7&#34;&gt;7. 命令&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#71&#34;&gt;7.1 查找页面元素的基本方法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#72&#34;&gt;7.2 查找页面元素的辅助方法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#73&#34;&gt;7.3 点击命令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#74&#34;&gt;7.4 操作页面元素的命令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#75&#34;&gt;7.5 获取页面全局对象的命令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#76&#34;&gt;7.6 操作浏览器的命令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#77&#34;&gt;7.7 操作上一条命令返回结果的命令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#78&#34;&gt;7.8 操作文件相关命令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#79&#34;&gt;7.9 网络相关命令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#710-cookie&#34;&gt;7.10 操作 Cookie 相关命令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#711-cypress-api&#34;&gt;7.11 Cypress API 命令大全&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#8&#34;&gt;8. 断言&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#81-bdd&#34;&gt;8.1 BDD 断言&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#82-tdd&#34;&gt;8.2 TDD 断言&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#83-chai-jquery&#34;&gt;8.3 Chai-jQuery&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#84-sinon-chai&#34;&gt;8.4 Sinon-Chai&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h3 id=&#34;1&#34;&gt;1. 简介&lt;/h3&gt;
&lt;p&gt;Cypress 是为现代网络而构建的下一代前端测试工具。我们解决开发人员和质量保证工程师在测试现代应用程序时面临的关键难题。&lt;/p&gt;
&lt;p&gt;我们使它很简单：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;设置测试&lt;/li&gt;
&lt;li&gt;编写测试&lt;/li&gt;
&lt;li&gt;运行测试&lt;/li&gt;
&lt;li&gt;调试测试&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Cypress 经常和 Selenium 相提并论；然而，Cypress 在结构和基础上与之有所不同。Cypress 不受 Selenium 限制。&lt;/p&gt;
&lt;p&gt;这能够使你编写更快、更简单和更可靠的测试。&lt;/p&gt;
&lt;h4 id=&#34;11-cypress&#34;&gt;1.1 谁能使用 Cypress ？&lt;/h4&gt;
&lt;p&gt;我们的用户通常是使用现代 JavaScript 构建 Web 应用程序的开发人员或者 QA 工程师。&lt;/p&gt;
&lt;p&gt;Cypress 能够帮助你编写各种类型的测试：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;端到端测试&lt;/li&gt;
&lt;li&gt;集成测试&lt;/li&gt;
&lt;li&gt;单元测试&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Cypress可以测试运行在浏览器中的任何东西。&lt;/p&gt;
&lt;h4 id=&#34;12-cypress&#34;&gt;1.2 Cypress 生态系统&lt;/h4&gt;
&lt;p&gt;Cypress 是一款免费、开源、本地安装的测试工具和记录测试的服务。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;首先：&lt;/strong&gt; 在本地构建应用程序时，Cypress 能够容易的设置并编写测试。TDD 是最好的例子。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;其次：&lt;/strong&gt; 在建立一套测试系统并将 Cypress 与的 CI 集成后，我们的控制台能够记录你的测试运行。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;13&#34;&gt;1.3 特性&lt;/h4&gt;
&lt;p&gt;Cypress 支持全面。这里是一些 Cypress 能够但是其他框架不能够做到的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;安装简单&lt;/strong&gt;：在网络正常的情况下，10分钟就可以安装好Cypress框架，一天则可以入门，写一些简单的用例。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;运行速度快&lt;/strong&gt;：相较于Selenium来说，Cypress的运行速度真的是相当快了，它不需要web driver来驱动浏览器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;脚本实时调试&lt;/strong&gt;：在脚本编写过程中，只要编辑器中进行保存，脚本就会自动运行，可以快速高效的知道脚本是否正确。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;随时查看执行情况：&lt;/strong&gt; 当你执行测试的时候 Cypress 会进行快照。只需在命令日志中鼠标悬停，就能查看每一步的具体情况。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;可调试性&lt;/strong&gt;：直接从熟悉的工具（如：Chrome DevTools）进行调试。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;自动等待：&lt;/strong&gt; 不需要在测试中添加等待。在继续执行之前，Cypress 能够自动等待命令和断言。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;截图和视频：&lt;/strong&gt; 脚本运行失败后，会在..\cypress\screenshots文件夹下面自动保存失败用例的截图，方便我们追踪到失败用例的原因。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;脚本运行完成后&lt;/strong&gt;，会在..\cypress\videos文件夹下自动保存脚本运行过程录制的视频。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;跨浏览器测试&lt;/strong&gt;：支持Firefox 和 Chrome 系列浏览器（包括 Edge 和 Electron）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;131&#34;&gt;1.3.1 设置测试&lt;/h5&gt;
&lt;p&gt;没有服务器、驱动程序或者其他任何依赖项的安装或配置。你可以在 60 秒内写出你的第一个能够通过的测试。&lt;/p&gt;
&lt;h5 id=&#34;132&#34;&gt;1.3.2 编写测试&lt;/h5&gt;
&lt;p&gt;使用 Cypress 编写的测试很容易阅读和理解。我们的 API 已经完全支持你已经熟悉的工具。&lt;/p&gt;
&lt;h5 id=&#34;133&#34;&gt;1.3.3 运行测试&lt;/h5&gt;
&lt;p&gt;Cypress 的运行速度与浏览器渲染内容一样快。你可以在开发应用程序时实时观看测试。&lt;/p&gt;
&lt;h5 id=&#34;134&#34;&gt;1.3.4 调试测试&lt;/h5&gt;
&lt;p&gt;可读的错误消息可帮助您快速调试。您还可以访问您熟悉并喜爱的任何开发调试工具。&lt;/p&gt;
&lt;h3 id=&#34;2&#34;&gt;2. 环境搭建&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;本次安装基于Windows10&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;21-node&#34;&gt;2.1 安装node&lt;/h4&gt;
&lt;p&gt;下载地址：&lt;code&gt;http://nodejs.cn/download/&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;从上面的地址可下载你想要的版本，本次下载的是：&lt;code&gt;https://npmmirror.com/mirrors/node/v16.15.0/node-v16.15.0-x64.msi&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;安装完成后，检查版本，如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;# node -v
v16.15.0

# npm -v
8.5.5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;均正常显示版本，则安装成功。&lt;/p&gt;
&lt;h4 id=&#34;22-cypress&#34;&gt;2.2 安装Cypress&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在要安装的地方，新建一个文件夹，如cypress，并进入&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;初始化项目：在当前目录下执行命令 &lt;code&gt;npm init&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安装Cypress：&lt;code&gt;npm install cypress --save-dev&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;23-cypress&#34;&gt;2.3 打开Cypress&lt;/h4&gt;
&lt;p&gt;以下有多种打开方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;./node_modules/.bin/cypress open&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;$(npm bin)/cypress open&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;npx cypress open&lt;/code&gt;，需要&lt;code&gt;npm &amp;gt; v5.2&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;yarn run cypress open&lt;/code&gt;，需要提前安装&lt;code&gt;yarn&lt;/code&gt;，命令如下：&lt;code&gt;npm install -g yarn&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;然后Cypress会启动。&lt;/p&gt;
&lt;h4 id=&#34;23-npm&#34;&gt;2.3 添加npm脚本&lt;/h4&gt;
&lt;p&gt;如果启动正常，你可以在package.json中添加启动脚本，方便Cypress启动，如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;{
  &amp;quot;scripts&amp;quot;: {
    &amp;quot;cypress:open&amp;quot;: &amp;quot;cypress open&amp;quot;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后就可以像下面那样启动Cypress了&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;npm run cypress:open
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;启动后会有&#34;Welcome to Cypress！&#34;字样出现，说明已经启动成功。&lt;/p&gt;
&lt;h3 id=&#34;3-e2e&#34;&gt;3. 编写第一个E2E测试用例&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;点击E2E Testing&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;选择对应的浏览器，进入页面后会看到一些例子，这个是Cypress自带的，在目录在.cypress\cypress\e2e下，本次我们选择Edge，然后点击&lt;code&gt;Start E2E Testing in Edge&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;然后点击右上角&lt;code&gt;+ New Spec&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;再然后点击右侧&lt;code&gt;Create new empty spec&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;默认或输入新名称，然后点击&lt;code&gt;Create Spec&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可以看到一个新的用例展示，可以直接支持，或者关掉窗口。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;```
  # cypress\e2e\spec.cy.js&lt;/p&gt;
&lt;p&gt;describe(&#39;empty spec&#39;, () =&amp;gt; {
    it(&#39;passes&#39;, () =&amp;gt; {
      cy.visit(&#39;https://example.cypress.io&#39;)
    })
  })
  ```&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;然后就能在用例列表中找到他&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;4&#34;&gt;4. 写你第一个自己的测试用例&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;先让我们看一个通过性测试的用例&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;describe(&#39;My First Test&#39;, () =&amp;gt; {
  it(&#39;Does not do much!&#39;, () =&amp;gt; {
    expect(true).to.equal(true)
  })
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;My First Test
√ Does not do much!
    TEST BODY
        assert expected true to equal true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;尽管这个测试用例没有什么实际用处，但却是我们第一个执行通过的用例。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;再看一个不能过的测试用例&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;describe(&#39;My First Test&#39;, () =&amp;gt; {
  it(&#39;Does not do much!&#39;, () =&amp;gt; {
    expect(true).to.equal(false)
  })
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;My First Test
✖ Does not do much!
    TEST BODY
    1  assert expected true to equal false
    !  AssertionError
    expected true to equal false
      cypress/e2e/false.cy.js:3:21
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;测试结果中会断言失败的地方高亮显示出来，并指出问题所在地方。&lt;/p&gt;
&lt;h3 id=&#34;5&#34;&gt;5. 写一个真正的测试用例&lt;/h3&gt;
&lt;p&gt;通常测试包括3个阶段：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;编写测试用例&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;执行操作&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对执行结果做一个断言&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;现在 ，我们通过Cypress来操作这些步骤&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;访问一个页面&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查询一个元素&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;元素间的交互&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;页面内容的断言&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;步骤1：访问一个页面（visit），如下：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;describe(&#39;第一个测试&#39;, () =&amp;gt; {
  it(&#39;打开SiCAP&#39;, () =&amp;gt; {
    cy.visit(&#39;https://192.168.214.55&#39;)
  })
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行结果：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;可以看到第一行显示describe的内容，第二行显示it的内容&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;TEST BODY显示所有的请求&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;右侧显示每一个请求的执行情况，当然你需要使用鼠标划过对应的请求&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;步骤2：查找一个元素（get、contains），如下：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;describe(&#39;第一个测试&#39;, () =&amp;gt; {
  it(&#39;打开SiCAP&#39;, () =&amp;gt; {
    cy.visit(&#39;https://192.168.214.55&#39;)
    cy.get(&#39;#username&#39;)
    cy.contains(&#39;登 录&#39;)
  })
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行结果：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;可以看到第一行显示describe的内容，第二行显示it的内容&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;TEST BODY显示所有的请求&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在对应的请求中，我们可以清晰的看到程序找到了&lt;code&gt;#username&lt;/code&gt;，&lt;code&gt;登 录&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;步骤3：给文本框输入值（type），如下&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;describe(&#39;登录SiCAP&#39;, () =&amp;gt; {
  it(&#39;passes&#39;, () =&amp;gt; {
    cy.visit(&#39;https://192.168.214.55/&#39;)
    cy.get(&#39;#username&#39;)
        .type(&#39;admin&#39;)
        .should(&#39;have.value&#39;, &#39;admin&#39;);
    cy.get(&#39;#password&#39;)
        .type(&#39;p@ssw0rd&#39;)
        .should(&#39;have.value&#39;, &#39;p@ssw0rd&#39;);
    cy.get(&#39;.login_btn&#39;).contains(&#39;登 录&#39;).click()
  })
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行结果：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户和密码正常输入&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;步骤4：断言（should），如下&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;describe(&#39;登录SiCAP&#39;, () =&amp;gt; {
  it(&#39;passes&#39;, () =&amp;gt; {
    cy.visit(&#39;https://192.168.214.55/&#39;)
    cy.get(&#39;#username&#39;)
        .type(&#39;admin&#39;)
        .should(&#39;have.value&#39;, &#39;admin&#39;);
    cy.get(&#39;#password&#39;)
        .type(&#39;p@ssw0rd&#39;)
        .should(&#39;have.value&#39;, &#39;p@ssw0rd&#39;);
    cy.get(&#39;.login_btn&#39;).contains(&#39;登 录&#39;).click()
  })
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行结果：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户和密码正常断言&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;步骤5：点击一个元素（click），如下&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;describe(&#39;登录SiCAP&#39;, () =&amp;gt; {
  it(&#39;passes&#39;, () =&amp;gt; {
    cy.visit(&#39;https://192.168.214.55/&#39;)
    cy.get(&#39;#username&#39;)
        .type(&#39;admin&#39;)
        .should(&#39;have.value&#39;, &#39;admin&#39;);
    cy.get(&#39;#password&#39;)
        .type(&#39;p@ssw0rd&#39;)
        .should(&#39;have.value&#39;, &#39;p@ssw0rd&#39;);
    cy.get(&#39;.login_btn&#39;).contains(&#39;登 录&#39;).click()
  })
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行结果：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;点击后，正常进入系统&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;6&#34;&gt;6. 执行测试用例&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;启动server&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;访问你的server&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;配置Cypress&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;cypress\cypress.config.js&lt;/p&gt;
&lt;p&gt;如配置基础url，在后面的访问页面的时候就不需要写baseUrl。&lt;/p&gt;
&lt;p&gt;```
  const { defineConfig } = require(&#39;cypress&#39;)&lt;/p&gt;
&lt;p&gt;module.exports = defineConfig({
    e2e: {
      baseUrl: &#39;http://localhost:8080&#39;
    }
  })
  ```&lt;/p&gt;
&lt;p&gt;配置后，访问链接如下：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;describe(&#39;The Home Page&#39;, () =&amp;gt; {
    it(&#39;successfully loads&#39;, () =&amp;gt; {
      cy.visit(&#39;/&#39;)
    })
  })&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;61&#34;&gt;6.1 测试策略&lt;/h4&gt;
&lt;p&gt;在执行测试用例前，有时候需要做一些前置动作，所以Cypress安排了一个特定的命令来执行它，如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;cy.exec()&lt;/code&gt;：用来执行系统命令&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;cy.task()&lt;/code&gt;：通过 setupNodeEvents 函数在 Node 中运行代码&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;cy.request()&lt;/code&gt;：用来发出HTTP请求&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果你想在你的服务上执行npm，你可以加一个before或者beforeEach沟子去执行一个npm任务。如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;describe(&#39;The Home Page&#39;, () =&amp;gt; {
  beforeEach(() =&amp;gt; {
    // reset and seed the database prior to every test
    cy.exec(&#39;npm run db:reset &amp;amp;&amp;amp; npm run db:seed&#39;)
  })

  it(&#39;successfully loads&#39;, () =&amp;gt; {
    cy.visit(&#39;/&#39;)
  })
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再如，你可以在你的测试用例中，执行多个请求。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;describe(&#39;The Home Page&#39;, () =&amp;gt; {
  beforeEach(() =&amp;gt; {
    // reset and seed the database prior to every test
    cy.exec(&#39;npm run db:reset &amp;amp;&amp;amp; npm run db:seed&#39;)

    // seed a post in the DB that we control from our tests
    cy.request(&#39;POST&#39;, &#39;/test/seed/post&#39;, {
      title: &#39;First Post&#39;,
      authorId: 1,
      body: &#39;...&#39;,
    })

    // seed a user in the DB that we can control from our tests
    cy.request(&#39;POST&#39;, &#39;/test/seed/user&#39;, { name: &#39;Jane&#39; })
      .its(&#39;body&#39;)
      .as(&#39;currentUser&#39;)
  })

  it(&#39;successfully loads&#39;, () =&amp;gt; {
    // this.currentUser will now point to the response
    // body of the cy.request() that we could use
    // to log in or work with in some way

    cy.visit(&#39;/&#39;)
  })
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意：第一 次测试时的登录不要去用UI，请使用request。&lt;/p&gt;
&lt;h3 id=&#34;7&#34;&gt;7. 命令&lt;/h3&gt;
&lt;h4 id=&#34;71&#34;&gt;7.1 查找页面元素的基本方法&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align: center;&#34;&gt;命令&lt;/th&gt;
&lt;th style=&#34;text-align: center;&#34;&gt;注释&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;get()&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;通过选择器或别名获取一个或多个 DOM 元素。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;find()&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;获取特定选择器的下位DOM元素。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;contains()&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;获取包含文本的 DOM 元素，可模糊匹配。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;72&#34;&gt;7.2 查找页面元素的辅助方法&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align: center;&#34;&gt;命令&lt;/th&gt;
&lt;th style=&#34;text-align: center;&#34;&gt;注释&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;children()&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;获取一组DOM元素中每个DOM元素的子元素。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;parents()&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;获取一组DOM元素的父DOM元素。请注意 .parents() 在 DOM 树中向上移动多个级别，而不是.parent ()命令在 DOM 树中向上移动一个级别。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;parent()&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;获取一组DOM元素的父DOM元素。请注意，与.parents（）命令相反， .parent() 仅沿DOM树向上移动一个级别。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;siblings()&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;获取同级DOM元素。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;first()&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;获取一组DOM元素中的第一个DOM元素。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;last()&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;获取一组DOM元素中的最后一个DOM元素。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;next()&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;获取一组 DOM 元素中每个 DOM 元素的紧随其后的元素。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;nextAll()&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;在一组匹配的 DOM 元素中获取每个 DOM 元素的所有后续元素。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;nextUntil(selector)&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;获取一组匹配的 DOM 元素中每个 DOM 元素的所有后续元素，但不包括提供的元素。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;prev()&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;获取一组元素中每个元素的前一个同级元素。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;prevUntil()&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;获取一组匹配的 DOM 元素中每个 DOM 元素的所有前置元素，但不包括提供的元素。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;each()&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;遍历类似结构的数组（具有 length 属性的数组或对象）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;eq()&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;在一个元素数组的特定索引处获取一个DOM元素。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;closest()&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;获取与选择器相匹配的第一个DOM元素(无论是它本身还是它的一个祖先)。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;73&#34;&gt;7.3 点击命令&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align: center;&#34;&gt;命令&lt;/th&gt;
&lt;th style=&#34;text-align: center;&#34;&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;click()&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;单击&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;dbclick()&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;双击&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;rightclick()&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;右键点击&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;74&#34;&gt;7.4 操作页面元素的命令&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align: center;&#34;&gt;命令&lt;/th&gt;
&lt;th style=&#34;text-align: center;&#34;&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;type()&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;输入框输入文本元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;focus()&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;聚焦DOM元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;blur()&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;DOM元素失去焦点&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;clear()&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;清空DOM元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;submit()&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;提交表单&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;click()&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;点击DOM元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;dbclick()&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;双击&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;rightclick()&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;右键点击&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;check()&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;选中单选框、复选框&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;uncheck()&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;取消选中复选框&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;select()&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;select&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;scrollIntoView()&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;将DOM元素滑动到可视区域&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;trigger()&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;DOM元素上触发事件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;scrollTo()&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;滑动滚动条&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;75&#34;&gt;7.5 获取页面全局对象的命令&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align: center;&#34;&gt;命令&lt;/th&gt;
&lt;th style=&#34;text-align: center;&#34;&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;window()&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;获取当前页面的窗口对象&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;title()&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;获取当前页面的title&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;url()&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;获取当前页面的URL&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;location()&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;获取当前页面的全局window.location对象&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;document()&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;获取当前页面的全局windowd.document对象&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;hash()&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;获取当前页面的URL&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;root()&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;获取根DOM元素&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;76&#34;&gt;7.6 操作浏览器的命令&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align: center;&#34;&gt;命令&lt;/th&gt;
&lt;th style=&#34;text-align: center;&#34;&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;go()&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;浏览器前进、后退&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;reload()&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;刷新页面&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;viewport()&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;控制浏览器窗口的大小和方向&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;visit()&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;访问指定的&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;wait()&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;强制等待&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;77&#34;&gt;7.7 操作上一条命令返回结果的命令&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align: center;&#34;&gt;命令&lt;/th&gt;
&lt;th style=&#34;text-align: center;&#34;&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;then()&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;将上一条命令返回的结果注入到下一个命令中&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;and()&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;创建一个断言。断言将自动重试，直到它们通过或超时&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;should()&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;and()的别名&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;invoke()&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;对上一条命令的结果执行调用方法操作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;its()&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;获取对象的属性值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;as()&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;取别名&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;within()&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;限定命令作用域&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;each()&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;遍历当前元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;spread()&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;将数组内容作为单独的参数传回到回调函数&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;78&#34;&gt;7.8 操作文件相关命令&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align: center;&#34;&gt;命令&lt;/th&gt;
&lt;th style=&#34;text-align: center;&#34;&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;fixture()&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;加载数据文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;readFile()&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;读取文件并生成其内容。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;writeFile()&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;把指定同内容写入一个文件&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;79&#34;&gt;7.9 网络相关命令&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align: center;&#34;&gt;命令&lt;/th&gt;
&lt;th style=&#34;text-align: center;&#34;&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;request()&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;发送HTTP请求。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;route()&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;用来管理网络请求的行为&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;server()&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;启动服务器以开始将响应路由到cy.route()并更改网络请求的行为。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;intercept()&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;监视和存根网络请求和响应。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;710-cookie&#34;&gt;7.10 操作 Cookie 相关命令&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align: center;&#34;&gt;命令&lt;/th&gt;
&lt;th style=&#34;text-align: center;&#34;&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;getCookies()&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;获取所有&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;setCookie()&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;设置一个&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;clearCookie()&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;清除指定名称的&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;clearCookies()&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;清除所有&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;711-cypress-api&#34;&gt;7.11 Cypress API 命令大全&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align: center;&#34;&gt;命令&lt;/th&gt;
&lt;th style=&#34;text-align: center;&#34;&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;Cypress.Commands&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;Cypress.Cookies&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;Cypress.config&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;Cypress.env&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;Cypress.dom&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;Cypress.platform&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;Cypress.version&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;Cypress.arch&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;Cypress.spec&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;Cypress.browser&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;Cypress.log&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;8&#34;&gt;8. 断言&lt;/h3&gt;
&lt;h4 id=&#34;81-bdd&#34;&gt;8.1 BDD 断言&lt;/h4&gt;
&lt;p&gt;这些链接器可用于 BDD 断言（&lt;code&gt;expect&lt;/code&gt;/&lt;code&gt;should&lt;/code&gt;）。 列出的别名可以与其原始链接器互换使用。 您可以在 &lt;a href=&#34;http://chaijs.com/api/bdd/&#34;&gt;此处&lt;/a&gt; 查看可用 BDD Chai 断言的完整列表。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Chainer&lt;/th&gt;
&lt;th&gt;Example&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;not&lt;/td&gt;
&lt;td&gt;&lt;code&gt;expect(name).to.not.equal(&#39;Jane&#39;)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;deep&lt;/td&gt;
&lt;td&gt;&lt;code&gt;expect(obj).to.deep.equal({ name: &#39;Jane&#39; })&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;nested&lt;/td&gt;
&lt;td&gt;&lt;code&gt;expect({a: {b: [&#39;x&#39;, &#39;y&#39;]}}).to.have.nested.property(&#39;a.b[1]&#39;)&lt;/code&gt;&lt;br&gt;&lt;code&gt;expect({a: {b: [&#39;x&#39;, &#39;y&#39;]}}).to.nested.include({&#39;a.b[1]&#39;: &#39;y&#39;})&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ordered&lt;/td&gt;
&lt;td&gt;&lt;code&gt;expect([1, 2]).to.have.ordered.members([1, 2]).but.not.have.ordered.members([2, 1])&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;any&lt;/td&gt;
&lt;td&gt;&lt;code&gt;expect(arr).to.have.any.keys(&#39;age&#39;)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;all&lt;/td&gt;
&lt;td&gt;&lt;code&gt;expect(arr).to.have.all.keys(&#39;name&#39;, &#39;age&#39;)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;a(&lt;em&gt;type&lt;/em&gt;)&lt;br&gt;&lt;strong&gt;Aliases:&lt;/strong&gt; an&lt;/td&gt;
&lt;td&gt;&lt;code&gt;expect(&#39;test&#39;).to.be.a(&#39;string&#39;)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;include(&lt;em&gt;value&lt;/em&gt;)&lt;br&gt;&lt;strong&gt;Aliases:&lt;/strong&gt; contain, includes, contains&lt;/td&gt;
&lt;td&gt;&lt;code&gt;expect([1,2,3]).to.include(2)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ok&lt;/td&gt;
&lt;td&gt;&lt;code&gt;expect(undefined).to.not.be.ok&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;true&lt;/td&gt;
&lt;td&gt;&lt;code&gt;expect(true).to.be.true&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;false&lt;/td&gt;
&lt;td&gt;&lt;code&gt;expect(false).to.be.false&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;null&lt;/td&gt;
&lt;td&gt;&lt;code&gt;expect(null).to.be.null&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;undefined&lt;/td&gt;
&lt;td&gt;&lt;code&gt;expect(undefined).to.be.undefined&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;exist&lt;/td&gt;
&lt;td&gt;&lt;code&gt;expect(myVar).to.exist&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;empty&lt;/td&gt;
&lt;td&gt;&lt;code&gt;expect([]).to.be.empty&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;arguments&lt;br&gt;&lt;strong&gt;Aliases:&lt;/strong&gt; Arguments&lt;/td&gt;
&lt;td&gt;&lt;code&gt;expect(arguments).to.be.arguments&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;equal(&lt;em&gt;value&lt;/em&gt;)&lt;br&gt;&lt;strong&gt;Aliases:&lt;/strong&gt; equals, eq&lt;/td&gt;
&lt;td&gt;&lt;code&gt;expect(42).to.equal(42)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;deep.equal(&lt;em&gt;value&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;&lt;code&gt;expect({ name: &#39;Jane&#39; }).to.deep.equal({ name: &#39;Jane&#39; })&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;eql(&lt;em&gt;value&lt;/em&gt;)&lt;br&gt;&lt;strong&gt;Aliases:&lt;/strong&gt; eqls&lt;/td&gt;
&lt;td&gt;&lt;code&gt;expect({ name: &#39;Jane&#39; }).to.eql({ name: &#39;Jane&#39; })&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;greaterThan(&lt;em&gt;value&lt;/em&gt;)&lt;br&gt;&lt;strong&gt;Aliases:&lt;/strong&gt; gt, above&lt;/td&gt;
&lt;td&gt;&lt;code&gt;expect(10).to.be.greaterThan(5)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;least(&lt;em&gt;value&lt;/em&gt;)&lt;br&gt;&lt;strong&gt;Aliases:&lt;/strong&gt; gte&lt;/td&gt;
&lt;td&gt;&lt;code&gt;expect(10).to.be.at.least(10)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;lessThan(&lt;em&gt;value&lt;/em&gt;)&lt;br&gt;&lt;strong&gt;Aliases:&lt;/strong&gt; lt, below&lt;/td&gt;
&lt;td&gt;&lt;code&gt;expect(5).to.be.lessThan(10)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;most(&lt;em&gt;value&lt;/em&gt;)&lt;br&gt;&lt;strong&gt;Aliases:&lt;/strong&gt; lte&lt;/td&gt;
&lt;td&gt;&lt;code&gt;expect(&#39;test&#39;).to.have.length.of.at.most(4)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;within(&lt;em&gt;start&lt;/em&gt;, &lt;em&gt;finish&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;&lt;code&gt;expect(7).to.be.within(5,10)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;instanceOf(&lt;em&gt;constructor&lt;/em&gt;)&lt;br&gt;&lt;strong&gt;Aliases:&lt;/strong&gt; instanceof&lt;/td&gt;
&lt;td&gt;&lt;code&gt;expect([1, 2, 3]).to.be.instanceOf(Array)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;property(&lt;em&gt;name&lt;/em&gt;, &lt;em&gt;[value]&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;&lt;code&gt;expect(obj).to.have.property(&#39;name&#39;)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;deep.property(&lt;em&gt;name&lt;/em&gt;, &lt;em&gt;[value]&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;&lt;code&gt;expect(deepObj).to.have.deep.property(&#39;tests[1]&#39;, &#39;e2e&#39;)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ownProperty(&lt;em&gt;name&lt;/em&gt;)&lt;br&gt;&lt;strong&gt;Aliases:&lt;/strong&gt; haveOwnProperty, own.property&lt;/td&gt;
&lt;td&gt;&lt;code&gt;expect(&#39;test&#39;).to.have.ownProperty(&#39;length&#39;)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ownPropertyDescriptor(&lt;em&gt;name&lt;/em&gt;)&lt;br&gt;&lt;strong&gt;Aliases:&lt;/strong&gt; haveOwnPropertyDescriptor&lt;/td&gt;
&lt;td&gt;&lt;code&gt;expect({a: 1}).to.have.ownPropertyDescriptor(&#39;a&#39;)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;lengthOf(&lt;em&gt;value&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;&lt;code&gt;expect(&#39;test&#39;).to.have.lengthOf(3)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;match(&lt;em&gt;RegExp&lt;/em&gt;)&lt;br&gt;&lt;strong&gt;Aliases:&lt;/strong&gt; matches&lt;/td&gt;
&lt;td&gt;&lt;code&gt;expect(&#39;testing&#39;).to.match(/^test/)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;string(&lt;em&gt;string&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;&lt;code&gt;expect(&#39;testing&#39;).to.have.string(&#39;test&#39;)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;keys(&lt;em&gt;key1&lt;/em&gt;, &lt;em&gt;[key2]&lt;/em&gt;, &lt;em&gt;[...]&lt;/em&gt;)&lt;br&gt;&lt;strong&gt;Aliases:&lt;/strong&gt; key&lt;/td&gt;
&lt;td&gt;&lt;code&gt;expect({ pass: 1, fail: 2 }).to.have.keys(&#39;pass&#39;, &#39;fail&#39;)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;throw(&lt;em&gt;constructor&lt;/em&gt;)&lt;br&gt;&lt;strong&gt;Aliases:&lt;/strong&gt; throws, Throw&lt;/td&gt;
&lt;td&gt;&lt;code&gt;expect(fn).to.throw(Error)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;respondTo(&lt;em&gt;method&lt;/em&gt;)&lt;br&gt;&lt;strong&gt;Aliases:&lt;/strong&gt; respondsTo&lt;/td&gt;
&lt;td&gt;&lt;code&gt;expect(obj).to.respondTo(&#39;getName&#39;)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;itself&lt;/td&gt;
&lt;td&gt;&lt;code&gt;expect(Foo).itself.to.respondTo(&#39;bar&#39;)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;satisfy(&lt;em&gt;method&lt;/em&gt;)&lt;br&gt;&lt;strong&gt;Aliases:&lt;/strong&gt; satisfies&lt;/td&gt;
&lt;td&gt;&lt;code&gt;expect(1).to.satisfy((num) =&amp;gt; { return num &amp;gt; 0 })&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;closeTo(&lt;em&gt;expected&lt;/em&gt;, &lt;em&gt;delta&lt;/em&gt;)&lt;br&gt;&lt;strong&gt;Aliases:&lt;/strong&gt; approximately&lt;/td&gt;
&lt;td&gt;&lt;code&gt;expect(1.5).to.be.closeTo(1, 0.5)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;members(&lt;em&gt;set&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;&lt;code&gt;expect([1, 2, 3]).to.include.members([3, 2])&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;oneOf(&lt;em&gt;values&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;&lt;code&gt;expect(2).to.be.oneOf([1,2,3])&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;change(&lt;em&gt;function&lt;/em&gt;)&lt;br&gt;&lt;strong&gt;Aliases:&lt;/strong&gt; changes&lt;/td&gt;
&lt;td&gt;&lt;code&gt;expect(fn).to.change(obj, &#39;val&#39;)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;increase(&lt;em&gt;function&lt;/em&gt;)&lt;br&gt;&lt;strong&gt;Aliases:&lt;/strong&gt; increases&lt;/td&gt;
&lt;td&gt;&lt;code&gt;expect(fn).to.increase(obj, &#39;val&#39;)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;decrease(&lt;em&gt;function&lt;/em&gt;)&lt;br&gt;&lt;strong&gt;Aliases:&lt;/strong&gt; decreases&lt;/td&gt;
&lt;td&gt;&lt;code&gt;expect(fn).to.decrease(obj, &#39;val&#39;)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;These getters are also available for BDD assertions. They don&#39;t actually do anything, but they enable you to write clear, english sentences.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Chainable getters&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;to&lt;/code&gt;, &lt;code&gt;be&lt;/code&gt;, &lt;code&gt;been&lt;/code&gt;, &lt;code&gt;is&lt;/code&gt;, &lt;code&gt;that&lt;/code&gt;, &lt;code&gt;which&lt;/code&gt;, &lt;code&gt;and&lt;/code&gt;, &lt;code&gt;has&lt;/code&gt;, &lt;code&gt;have&lt;/code&gt;, &lt;code&gt;with&lt;/code&gt;, &lt;code&gt;at&lt;/code&gt;, &lt;code&gt;of&lt;/code&gt;, &lt;code&gt;same&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;82-tdd&#34;&gt;8.2 TDD 断言&lt;/h4&gt;
&lt;p&gt;这些断言可用于 TDD 断言（&lt;code&gt;assert&lt;/code&gt;）。 您可以在 &lt;a href=&#34;http://chaijs.com/api/assert/&#34;&gt;此处&lt;/a&gt; 查看可用 Chai 断言的完整列表。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Assertion&lt;/th&gt;
&lt;th&gt;Example&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;.isOk(&lt;em&gt;object&lt;/em&gt;, &lt;em&gt;[message]&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;&lt;code&gt;assert.isOk(&#39;everything&#39;, &#39;everything is ok&#39;)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;.isNotOk(&lt;em&gt;object&lt;/em&gt;, &lt;em&gt;[message]&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;&lt;code&gt;assert.isNotOk(false, &#39;this will pass&#39;)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;.equal(&lt;em&gt;actual&lt;/em&gt;, &lt;em&gt;expected&lt;/em&gt;, &lt;em&gt;[message]&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;&lt;code&gt;assert.equal(3, 3, &#39;vals equal&#39;)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;.notEqual(&lt;em&gt;actual&lt;/em&gt;, &lt;em&gt;expected&lt;/em&gt;, &lt;em&gt;[message]&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;&lt;code&gt;assert.notEqual(3, 4, &#39;vals not equal&#39;)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;.strictEqual(&lt;em&gt;actual&lt;/em&gt;, &lt;em&gt;expected&lt;/em&gt;, &lt;em&gt;[message]&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;&lt;code&gt;assert.strictEqual(true, true, &#39;bools strict eq&#39;)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;.notStrictEqual(&lt;em&gt;actual&lt;/em&gt;, &lt;em&gt;expected&lt;/em&gt;, &lt;em&gt;[message]&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;&lt;code&gt;assert.notStrictEqual(5, &#39;5&#39;, &#39;not strict eq&#39;)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;.deepEqual(&lt;em&gt;actual&lt;/em&gt;, &lt;em&gt;expected&lt;/em&gt;, &lt;em&gt;[message]&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;&lt;code&gt;assert.deepEqual({ id: &#39;1&#39; }, { id: &#39;1&#39; })&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;.notDeepEqual(&lt;em&gt;actual&lt;/em&gt;, &lt;em&gt;expected&lt;/em&gt;, &lt;em&gt;[message]&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;&lt;code&gt;assert.notDeepEqual({ id: &#39;1&#39; }, { id: &#39;2&#39; })&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;.isAbove(&lt;em&gt;valueToCheck&lt;/em&gt;, &lt;em&gt;valueToBeAbove&lt;/em&gt;, &lt;em&gt;[message]&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;&lt;code&gt;assert.isAbove(6, 1, &#39;6 greater than 1&#39;)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;.isAtLeast(&lt;em&gt;valueToCheck&lt;/em&gt;, &lt;em&gt;valueToBeAtLeast&lt;/em&gt;, &lt;em&gt;[message]&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;&lt;code&gt;assert.isAtLeast(5, 2, &#39;5 gt or eq to 2&#39;)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;.isBelow(&lt;em&gt;valueToCheck&lt;/em&gt;, &lt;em&gt;valueToBeBelow&lt;/em&gt;, &lt;em&gt;[message]&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;&lt;code&gt;assert.isBelow(3, 6, &#39;3 strict lt 6&#39;)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;.isAtMost(&lt;em&gt;valueToCheck&lt;/em&gt;, &lt;em&gt;valueToBeAtMost&lt;/em&gt;, &lt;em&gt;[message]&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;&lt;code&gt;assert.isAtMost(4, 4, &#39;4 lt or eq to 4&#39;)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;.isTrue(&lt;em&gt;value&lt;/em&gt;, &lt;em&gt;[message]&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;&lt;code&gt;assert.isTrue(true, &#39;this val is true&#39;)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;.isNotTrue(&lt;em&gt;value&lt;/em&gt;, &lt;em&gt;[message]&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;&lt;code&gt;assert.isNotTrue(&#39;tests are no fun&#39;, &#39;val not true&#39;)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;.isFalse(&lt;em&gt;value&lt;/em&gt;, &lt;em&gt;[message]&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;&lt;code&gt;assert.isFalse(false, &#39;val is false&#39;)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;.isNotFalse(&lt;em&gt;value&lt;/em&gt;, &lt;em&gt;[message]&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;&lt;code&gt;assert.isNotFalse(&#39;tests are fun&#39;, &#39;val not false&#39;)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;.isNull(&lt;em&gt;value&lt;/em&gt;, &lt;em&gt;[message]&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;&lt;code&gt;assert.isNull(err, &#39;there was no error&#39;)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;.isNotNull(&lt;em&gt;value&lt;/em&gt;, &lt;em&gt;[message]&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;&lt;code&gt;assert.isNotNull(&#39;hello&#39;, &#39;is not null&#39;)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;.isNaN(&lt;em&gt;value&lt;/em&gt;, &lt;em&gt;[message]&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;&lt;code&gt;assert.isNaN(NaN, &#39;NaN is NaN&#39;)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;.isNotNaN(&lt;em&gt;value&lt;/em&gt;, &lt;em&gt;[message]&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;&lt;code&gt;assert.isNotNaN(5, &#39;5 is not NaN&#39;)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;.exists(&lt;em&gt;value&lt;/em&gt;, &lt;em&gt;[message]&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;&lt;code&gt;assert.exists(5, &#39;5 is not null or undefined&#39;)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;.notExists(&lt;em&gt;value&lt;/em&gt;, &lt;em&gt;[message]&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;&lt;code&gt;assert.notExists(null, &#39;val is null or undefined&#39;)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;.isUndefined(&lt;em&gt;value&lt;/em&gt;, &lt;em&gt;[message]&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;&lt;code&gt;assert.isUndefined(undefined, &#39;val is undefined&#39;)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;.isDefined(&lt;em&gt;value&lt;/em&gt;, &lt;em&gt;[message]&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;&lt;code&gt;assert.isDefined(&#39;hello&#39;, &#39;val has been defined&#39;)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;.isFunction(&lt;em&gt;value&lt;/em&gt;, &lt;em&gt;[message]&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;&lt;code&gt;assert.isFunction(x =&amp;gt; x * x, &#39;val is func&#39;)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;.isNotFunction(&lt;em&gt;value&lt;/em&gt;, &lt;em&gt;[message]&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;&lt;code&gt;assert.isNotFunction(5, &#39;val not funct&#39;)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;.isObject(&lt;em&gt;value&lt;/em&gt;, &lt;em&gt;[message]&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;&lt;code&gt;assert.isObject({num: 5}, &#39;val is object&#39;)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;.isNotObject(&lt;em&gt;value&lt;/em&gt;, &lt;em&gt;[message]&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;&lt;code&gt;assert.isNotObject(3, &#39;val not object&#39;)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;.isArray(&lt;em&gt;value&lt;/em&gt;, &lt;em&gt;[message]&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;&lt;code&gt;assert.isArray([&#39;unit&#39;, &#39;e2e&#39;], &#39;val is array&#39;)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;.isNotArray(&lt;em&gt;value&lt;/em&gt;, &lt;em&gt;[message]&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;&lt;code&gt;assert.isNotArray(&#39;e2e&#39;, &#39;val not array&#39;)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;.isString(&lt;em&gt;value&lt;/em&gt;, &lt;em&gt;[message]&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;&lt;code&gt;assert.isString(&#39;e2e&#39;, &#39;val is string&#39;)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;.isNotString(&lt;em&gt;value&lt;/em&gt;, &lt;em&gt;[message]&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;&lt;code&gt;assert.isNotString(2, &#39;val not string&#39;)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;.isNumber(&lt;em&gt;value&lt;/em&gt;, &lt;em&gt;[message]&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;&lt;code&gt;assert.isNumber(2, &#39;val is number&#39;)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;.isNotNumber(&lt;em&gt;value&lt;/em&gt;, &lt;em&gt;[message]&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;&lt;code&gt;assert.isNotNumber(&#39;e2e&#39;, &#39;val not number&#39;)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;.isFinite(&lt;em&gt;value&lt;/em&gt;, &lt;em&gt;[message]&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;&lt;code&gt;assert.isFinite(&#39;e2e&#39;, &#39;val is finite&#39;)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;.isBoolean(&lt;em&gt;value&lt;/em&gt;, &lt;em&gt;[message]&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;&lt;code&gt;assert.isBoolean(true, &#39;val is bool&#39;)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;.isNotBoolean(&lt;em&gt;value&lt;/em&gt;, &lt;em&gt;[message]&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;&lt;code&gt;assert.isNotBoolean(&#39;true&#39;, &#39;val not bool&#39;)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;.typeOf(&lt;em&gt;value&lt;/em&gt;, &lt;em&gt;name&lt;/em&gt;, &lt;em&gt;[message]&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;&lt;code&gt;assert.typeOf(&#39;e2e&#39;, &#39;string&#39;, &#39;val is string&#39;)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;.notTypeOf(&lt;em&gt;value&lt;/em&gt;, &lt;em&gt;name&lt;/em&gt;, &lt;em&gt;[message]&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;&lt;code&gt;assert.notTypeOf(&#39;e2e&#39;, &#39;number&#39;, &#39;val not number&#39;)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;83-chai-jquery&#34;&gt;8.3 Chai-jQuery&lt;/h4&gt;
&lt;p&gt;这些链接器在断言 DOM 对象时可用。 在使用 DOM 命令后，您通常会使用这些链接器，例如： &lt;a href=&#34;https://docs.cypress.io/api/commands/get&#34;&gt;&lt;code&gt;cy.get()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;https://docs.cypress.io/api/commands/contains&#34;&gt;&lt;code&gt;cy.contains()&lt;/code&gt;&lt;/a&gt;,等。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Chainers&lt;/th&gt;
&lt;th&gt;Assertion&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;attr(&lt;em&gt;name&lt;/em&gt;, &lt;em&gt;[value]&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;&lt;code&gt;expect($el).to.have.attr(&#39;foo&#39;, &#39;bar&#39;)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;prop(&lt;em&gt;name&lt;/em&gt;, &lt;em&gt;[value]&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;&lt;code&gt;expect($el).to.have.prop(&#39;disabled&#39;, false)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;css(&lt;em&gt;name&lt;/em&gt;, &lt;em&gt;[value]&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;&lt;code&gt;expect($el).to.have.css(&#39;background-color&#39;, &#39;rgb(0, 0, 0)&#39;)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;data(&lt;em&gt;name&lt;/em&gt;, &lt;em&gt;[value]&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;&lt;code&gt;expect($el).to.have.data(&#39;foo&#39;, &#39;bar&#39;)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;class(&lt;em&gt;className&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;&lt;code&gt;expect($el).to.have.class(&#39;foo&#39;)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;id(&lt;em&gt;id&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;&lt;code&gt;expect($el).to.have.id(&#39;foo&#39;)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;html(&lt;em&gt;html&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;&lt;code&gt;expect($el).to.have.html(&#39;I love testing&#39;)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;text(&lt;em&gt;text&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;&lt;code&gt;expect($el).to.have.text(&#39;I love testing&#39;)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;value(&lt;em&gt;value&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;&lt;code&gt;expect($el).to.have.value(&#39;test@dev.com&#39;)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;visible&lt;/td&gt;
&lt;td&gt;&lt;code&gt;expect($el).to.be.visible&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;hidden&lt;/td&gt;
&lt;td&gt;&lt;code&gt;expect($el).to.be.hidden&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;selected&lt;/td&gt;
&lt;td&gt;&lt;code&gt;expect($option).not.to.be.selected&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;checked&lt;/td&gt;
&lt;td&gt;&lt;code&gt;expect($input).not.to.be.checked&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;focus[ed]&lt;/td&gt;
&lt;td&gt;&lt;code&gt;expect($input).not.to.be.focused&lt;/code&gt;&lt;br&gt;&lt;code&gt;expect($input).to.have.focus&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;enabled&lt;/td&gt;
&lt;td&gt;&lt;code&gt;expect($input).to.be.enabled&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;disabled&lt;/td&gt;
&lt;td&gt;&lt;code&gt;expect($input).to.be.disabled&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;empty&lt;/td&gt;
&lt;td&gt;&lt;code&gt;expect($el).not.to.be.empty&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;exist&lt;/td&gt;
&lt;td&gt;&lt;code&gt;expect($nonexistent).not.to.exist&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;match(&lt;em&gt;selector&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;&lt;code&gt;expect($emptyEl).to.match(&#39;:empty&#39;)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;contain(&lt;em&gt;text&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;&lt;code&gt;expect($el).to.contain(&#39;text&#39;)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;descendants(&lt;em&gt;selector&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;&lt;code&gt;expect($el).to.have.descendants(&#39;div&#39;)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;84-sinon-chai&#34;&gt;8.4 Sinon-Chai&lt;/h4&gt;
&lt;p&gt;这些链接器用于带有 &lt;a href=&#34;https://docs.cypress.io/api/commands/stub&#34;&gt;&lt;code&gt;cy.stub()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;https://docs.cypress.io/api/commands/spy&#34;&gt;&lt;code&gt;cy.spy()&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Sinon.JS property/method&lt;/th&gt;
&lt;th&gt;Assertion&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;called&lt;/td&gt;
&lt;td&gt;&lt;code&gt;expect(spy).to.be.called&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;callCount&lt;/td&gt;
&lt;td&gt;&lt;code&gt;expect(spy).to.have.callCount(n)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;calledOnce&lt;/td&gt;
&lt;td&gt;&lt;code&gt;expect(spy).to.be.calledOnce&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;calledTwice&lt;/td&gt;
&lt;td&gt;&lt;code&gt;expect(spy).to.be.calledTwice&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;calledThrice&lt;/td&gt;
&lt;td&gt;&lt;code&gt;expect(spy).to.be.calledThrice&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;calledBefore&lt;/td&gt;
&lt;td&gt;&lt;code&gt;expect(spy1).to.be.calledBefore(spy2)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;calledAfter&lt;/td&gt;
&lt;td&gt;&lt;code&gt;expect(spy1).to.be.calledAfter(spy2)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;calledWithNew&lt;/td&gt;
&lt;td&gt;&lt;code&gt;expect(spy).to.be.calledWithNew&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;alwaysCalledWithNew&lt;/td&gt;
&lt;td&gt;&lt;code&gt;expect(spy).to.always.be.calledWithNew&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;calledOn&lt;/td&gt;
&lt;td&gt;&lt;code&gt;expect(spy).to.be.calledOn(context)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;alwaysCalledOn&lt;/td&gt;
&lt;td&gt;&lt;code&gt;expect(spy).to.always.be.calledOn(context)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;calledWith&lt;/td&gt;
&lt;td&gt;&lt;code&gt;expect(spy).to.be.calledWith(...args)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;alwaysCalledWith&lt;/td&gt;
&lt;td&gt;&lt;code&gt;expect(spy).to.always.be.calledWith(...args)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;calledWithExactly&lt;/td&gt;
&lt;td&gt;&lt;code&gt;expect(spy).to.be.calledWithExactly(...args)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;alwaysCalledWithExactly&lt;/td&gt;
&lt;td&gt;&lt;code&gt;expect(spy).to.always.be.calledWithExactly(...args)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;calledWithMatch&lt;/td&gt;
&lt;td&gt;&lt;code&gt;expect(spy).to.be.calledWithMatch(...args)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;alwaysCalledWithMatch&lt;/td&gt;
&lt;td&gt;&lt;code&gt;expect(spy).to.always.be.calledWithMatch(...args)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;returned&lt;/td&gt;
&lt;td&gt;&lt;code&gt;expect(spy).to.have.returned(returnVal)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;alwaysReturned&lt;/td&gt;
&lt;td&gt;&lt;code&gt;expect(spy).to.have.always.returned(returnVal)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;threw&lt;/td&gt;
&lt;td&gt;&lt;code&gt;expect(spy).to.have.thrown(errorObjOrErrorTypeStringOrNothing)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;alwaysThrew&lt;/td&gt;
&lt;td&gt;&lt;code&gt;expect(spy).to.have.always.thrown(errorObjOrErrorTypeStringOrNothing)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</description>  
      <pubDate>2025-10-09 17:54:40</pubDate>  
      <link>https://testpoo.github.io/UI自动化测试神器-Cypress.html</link>  
      <guid isPermaLink="true">https://testpoo.github.io/UI自动化测试神器-Cypress.html</guid>
       
      <category>测试</category> 
      
    </item>
    
    <item> 
      <title>如何用自动化测试搞垮团队</title>  
      <description>&lt;div class=&#34;toc&#34;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1&#34;&gt;1.我关于自动化测试的理解&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#11&#34;&gt;1.1.自动化测试技术其实门槛很低&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#12&#34;&gt;1.2.网上学习资源非常丰富&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-9&#34;&gt;2.用自动化测试搞垮团队的 9种方法&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#21&#34;&gt;2.1.所有的测试场景都必须自动化&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#22&#34;&gt;2.2.自动化就是用来替代测试人员的&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#23&#34;&gt;2.3.必须紧盯自动化的指标&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#24bug&#34;&gt;2.4.自动化测试一定可以发现更多的功能Bug&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#25&#34;&gt;2.5.自动化测试框架越先进越好&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#26&#34;&gt;2.6.脚本通过就可以了，管它质量如何呢&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#27&#34;&gt;2.7.都有自动化工具和框架了，我还要测试工程师干嘛？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#28&#34;&gt;2.8.计算机基础没必要学习&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#29&#34;&gt;2.9.自动化测试挺不错的，我们要立马开干&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;以下文章来源于茹炳晟聊软件研发 ，作者司文&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;自动化测试是大家非常熟悉的测试手段，近年来随着行业内卷越来越严重，对于测试工程师的岗位要求也水涨船高。&lt;/p&gt;
&lt;p&gt;如果你有留意一些测试工程师岗位的招聘要求，你就会了解很多细节，自动化测试技术已经不再是测试工程师找工作的「敲门砖」了，而是大部分测试工程师都应该具备的「基本生存技能」了，很多公司在招聘测试工程师时，最低要求都是「你得会自动化测试、你曾经做过自动化测试、你得把自动化测试用的很6」，当然，至于入职之后怎么做这项工作，那是另外一回事。&lt;/p&gt;
&lt;h3 id=&#34;1&#34;&gt;1.我关于自动化测试的理解&lt;/h3&gt;
&lt;p&gt;面对这个现象，我曾经思考过，发现其中存在2个有趣的逻辑：&lt;/p&gt;
&lt;h4 id=&#34;11&#34;&gt;1.1.自动化测试技术其实门槛很低&lt;/h4&gt;
&lt;p&gt;这块技术整体可以分为两类：一类是设计自动化测试框架，一类是用自动化测试框架编写脚本。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;先说第一类：框架设计&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;自动化测试框架网上很多开源的，各种版本语言的都有，UI、接口、单元测试等各种场景也有很多分类，要从事这类工作至少需要会某一门编程语言，编程的逻辑得清晰，照着网上开源的框架捣鼓捣鼓，很快就熟悉了。&lt;/p&gt;
&lt;p&gt;对于普通测试工程师来说，自动化测试框架设计看起来似乎是挺「高大上」的，但对于懂的人来说，也就那么回事，正所谓：会者不难、难者不会。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;再说第二类：脚本编写&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;无论是UI自动化测试，还是接口自动化测试，依旧属于「黑盒测试」的范畴，本质上只是代替人工操作和验证，把手工测试用例用编程语言翻译成了自动化脚本。当然，这里面使用的技术手段可以多样化，可以使用各种各样的工具、借助各种平台。&lt;/p&gt;
&lt;p&gt;这一类工作，测试工程师花一定量的时间去学习，可以轻松搞定这件事。&lt;/p&gt;
&lt;p&gt;所以，结论就是，自动化测试技术无论是搭建框架、还是编写自动化脚本，相比开发工程师的技术门槛，其实真的不算高。&lt;/p&gt;
&lt;h4 id=&#34;12&#34;&gt;1.2.网上学习资源非常丰富&lt;/h4&gt;
&lt;p&gt;时间倒回是2007年那会，自己刚大学毕业，当年我准备入测试这一行当，为了弄清楚自动化测试，周末找了一个小网吧，向网管上了一台机，开机百度搜索「自动化测试」，能找到的文章寥寥无几，最后没办法，只能自己翻墙去国外找一些文章学习，一边摸索一边练习，学习进度可谓是举步维艰。&lt;/p&gt;
&lt;p&gt;相反最近这些年网上的资源很多，想获取自动化测试的知识并不难，各大论坛、公众号、各大视频APP、各大学习平台，很多牛人写了很多博客，还有更6的小伙直接把进阶学习的文档全部集中起来放到了github工程里……。&lt;/p&gt;
&lt;p&gt;只要你想学，学习资源这块可以说是相当地轻松，资源成体系的打包呈现在你面前，接下来要做的事就很简单：「学就是了」。&lt;/p&gt;
&lt;p&gt;越来越多的年轻测试工程师掌握了自动化测试技术，让这项技术变得「烂大街」了。那么，既然这项技术这么普遍，为什么有的团队还做不好呢？大家忘记了，这里面还有一个「经验」属性，这其中某些经验都是大家耳熟能详的，某些经验又是老测试工程师们密不外传的「私货」。&lt;/p&gt;
&lt;p&gt;接下来我们回归正题，如果你作为测试团队的技术骨干，如何利用自动化测试技术搞垮整个团队呢？我们还是以调楷的目光来审视以下几种情况吧：&lt;/p&gt;
&lt;h3 id=&#34;2-9&#34;&gt;2.用自动化测试搞垮团队的 9种方法&lt;/h3&gt;
&lt;h4 id=&#34;21&#34;&gt;2.1.所有的测试场景都必须自动化&lt;/h4&gt;
&lt;p&gt;歪歪原则：既然你都有了自动化测试了，那就把所有的测试活动都自动化掉吧。&lt;/p&gt;
&lt;p&gt;正解：很多新人在学完自动化测试后，总想试图利用自动化测试技术代替所有手工测试，且不论这种可行性是不是存在。&lt;/p&gt;
&lt;p&gt;我们首先要理解ROI的概念，既：投资回报率，是指通过投资而应该返回的价值，即企业从某项投资行为中得到的经济利益回报。&lt;/p&gt;
&lt;p&gt;回到我们的工作中，自动化测试也是一样，根据ROI来决定这项测试工作是否需要自动化，如果用自动化测试来做，能带来什么样的回报。&lt;/p&gt;
&lt;p&gt;结论就是，想要自动化一切测试活动是不可能的，要考虑投入产出比，否则整个团队做了很多ROI很低的事情，迟迟达不到效果，最终会被你活活整垮掉的。&lt;/p&gt;
&lt;h4 id=&#34;22&#34;&gt;2.2.自动化就是用来替代测试人员的&lt;/h4&gt;
&lt;p&gt;歪歪原则：我引入自动化测试就是为了节省人力呀，要不我没事弄什么自动化测试呢？&lt;/p&gt;
&lt;p&gt;正解：很多非测试的测试领导会认为引入自动化测试后，测试人员的负担立刻会减轻，其实这是个误区。&lt;/p&gt;
&lt;p&gt;开展自动化测试初期需要投入一定的人力进行自动化测试脚本开发，并逐渐将自动化测试脚本用于日常的测试中，逐步减少手工测试人员从事重复劳动的时间和人数。长期看也许会减少一定数量的测试人员数量，短期内的测试工作量一定是增加的。&lt;/p&gt;
&lt;p&gt;从成本的角度来看，一个自动化测试脚本的成本大致可以分成：&lt;/p&gt;
&lt;p&gt;自动化测试脚本的成本 = 编写成本 + 维护成本 + 执行成本 + 交接成本 + 沉没成本。&lt;/p&gt;
&lt;p&gt;前面3类都比较容易理解，这里简单说1下后面2类成本。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;交接成本&lt;/strong&gt;：张三写的自动化测试脚本，能执行能验证，后来张三离职了。李四入职顶张三的岗，李四拿出来脚本一看，俺的勒个娘雷，写的这的这是啥（煞，四声）啊，乱七八糟的。还有，用别人的脚本就好比穿别人的内裤，太脏了。一怒之下，直接删掉脚本，自己重新写了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;沉没成本&lt;/strong&gt;：张三写的自动化测试脚本，能执行能验证，后来需求变了，这个测试场景不存在了，测试用例废了，自动化测试脚本也跟着废了，成本沉没了。&lt;/p&gt;
&lt;p&gt;所以，引入自动化测试不但不会减少工作成本，短期内反而会增加工作成本。而自动化测试可以提高测试效率，但是不是以减少人员数量为目的的，如果抱着减少人员的心态来入坑自动化测试，最后是没办法向领导交代的。&lt;/p&gt;
&lt;h4 id=&#34;23&#34;&gt;2.3.必须紧盯自动化的指标&lt;/h4&gt;
&lt;p&gt;歪歪原则：没有指标就没办法度量，一个自动化测试脚本能发现几个bug，我要拿指标去衡量团队的工作质量。&lt;/p&gt;
&lt;p&gt;正解：有些测试团队的领导会格外关注指标的有效性;&lt;/p&gt;
&lt;p&gt;平均每条自动化脚本发现了多少个bug、平均每条自动化脚本用时多长、平均每条自动化脚本包含了多少步骤……。
可能是数学系毕业的领导，也可能是从大数据转岗过来的，要么怎么就盯着数据不放呢？&lt;/p&gt;
&lt;p&gt;当然，这里提到的是「过度」，度量某一件事的效果，核心指标是要有的，但不用过度依赖指标。&lt;/p&gt;
&lt;p&gt;打个比方，详细小伙伴过年回老家时会有这样的感叹，在上了年纪亲戚心目中，家里、邻居、亲朋的所有年轻人在他们心目中都有个 &lt;strong&gt;「是否出息的排行榜」&lt;/strong&gt;，榜单评比的维度就是，无非就是 &lt;strong&gt;「赚钱多少、工作单位如何、职位高低」&lt;/strong&gt;，你们肯定也很抵制这样的现象，同理，回到工作中也一样。&lt;/p&gt;
&lt;p&gt;数字化管理是90年代外企比较注重的管理方式之一，数据是可以造假的，数据是可以骗人的，所以，没必要过度关注指标，关于这一点可以看看茹老师的这篇文章“研发效能度量引发的血案（长文慎入）“。&lt;/p&gt;
&lt;h4 id=&#34;24bug&#34;&gt;2.4.自动化测试一定可以发现更多的功能Bug&lt;/h4&gt;
&lt;p&gt;歪歪原则：自动化测试你不发现bug你来做什么，我要你有何用？&lt;/p&gt;
&lt;p&gt;正解：稍微懂行的测试工程师都知道，自动化测试最擅长的是做测试回归，而不是发现更多缺陷。要知道，目前缺陷的发现主要还是依赖于人工测试的。而对于不太懂的领导来说，就不是这回事了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;「哎，你们测试不都自动化测试了吗？怎么发现的bug这么少？看来自动化测试也没啥用嘛。」&lt;/strong&gt;不止一位开发领导跟我这么吐槽过，而我也会耐心地跟他解释，为什么自动化测试这种测试手段不能发现很多Bug，其实自动化测试发现的问题少是好事，你可以思考一下这是为什么。&lt;/p&gt;
&lt;h4 id=&#34;25&#34;&gt;2.5.自动化测试框架越先进越好&lt;/h4&gt;
&lt;p&gt;歪歪原则：团队必须得有一名首席自动化测试框架架构师坐镇，要把我们的自动化测试框架设计成行业最先进的框架。&lt;/p&gt;
&lt;p&gt;正解：PDD的黄征曾经说过一句话让我记忆犹新：&lt;strong&gt;所谓的消费升级，不是让所有人都能穿上普达拉，而是让全国2345线城市的老百姓都能随时随地用上便宜、干净的卫生纸。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;自动化测试框架的设计升级，其实能够满足团队和项目需求即可，点到为止，无需过度投入和钻研，做过了，就属于「项目镀金」了。&lt;/p&gt;
&lt;p&gt;我非常能理解有些技术控的测试工程师，喜欢学习和钻研技术，非常享受那种 &lt;strong&gt;「技术成就感」&lt;/strong&gt;，花了很多心思在赋能框架这件事上，为框架增加各种各样的函数和黑科技，但殊不知，需要这些功能的测试人员寥寥无几，无端浪费了团队资源。 &lt;strong&gt;记住永远不要为了技术而技术，技术只是你达成目标的手段。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;26&#34;&gt;2.6.脚本通过就可以了，管它质量如何呢&lt;/h4&gt;
&lt;p&gt;歪歪原则：要绝对的相信团队，相信大家的工作质量，没事不要做什么抽查&lt;/p&gt;
&lt;p&gt;正解：当自动化测试脚本的数量增长到一定量级后，建议测试团队对每位成员的脚本代码进行随机抽样评审。这样的目的并不是不相信团队，而是要关注测试的执行过程、验证检查点、脚本合理性、以及可维护性。&lt;/p&gt;
&lt;p&gt;同时，只关注脚本通过与否，最终容易陷入 &lt;strong&gt;「误报与漏报」&lt;/strong&gt;的质量陷阱。&lt;/p&gt;
&lt;p&gt;从不评审设计和脚本，不关注自动化测试的设计和脚本质量，导致的结果就是测试质量的直线下滑。&lt;/p&gt;
&lt;h4 id=&#34;27&#34;&gt;2.7.都有自动化工具和框架了，我还要测试工程师干嘛？&lt;/h4&gt;
&lt;p&gt;歪歪原则：第一步先引入自动化测试，第二步把很多测试工作自动化了，第三步向领导申请砍掉测试团队。（由开发经理来管理测试团队的后果）&lt;/p&gt;
&lt;p&gt;正解：人才是做测试活动最重要的部分。&lt;/p&gt;
&lt;p&gt;有些测试领导过度迷信工具和框架的作用，不知道人才是真正能够开发和用好这些东西的关键要素。&lt;/p&gt;
&lt;p&gt;这属于忘记了测试的本份：发现Bug。&lt;/p&gt;
&lt;p&gt;自动化测试工具和框架再好，也得由人来判断测试场景，由人来判断是使用等价类划分、边界值分析方法，还是使用因果图、基于风险测试法。通常在自动化测试过程中，我们都忙着搭建自动化框架和编写测试脚本，但其实作为测试的职责是：设计合理的用例找到系统中的bug。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;尊重做测试的人，才是尊重测试这项工作。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;28&#34;&gt;2.8.计算机基础没必要学习&lt;/h4&gt;
&lt;p&gt;歪歪原则：测试工程师没有多少技术的，会点点点、写点脚本就行了。&lt;/p&gt;
&lt;p&gt;正解：自动化测试脚本虽然也算代码，但那是按照测试用例翻译过来的“脚本”，真正有技术含量的是如何定制自动化测试框架。&lt;/p&gt;
&lt;p&gt;对于框架层面，需要考虑的事情太多了，我粗略估算了1下大概分这么几类：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;框架使用场景认知&lt;/strong&gt;：考虑的业务重要程度、用例的分层分级、测试资源分配、执行频率和特点，还有技术难度……&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;自动化脚本的质量认知&lt;/strong&gt;：脚本之间能否互不影响、被测系统能否保持清爽、快速定位问题、保留现场证据、易于编写、维护及扩展……&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;执行失败的调试认知&lt;/strong&gt;：测试开发环境部署、网络异常、脚本本身问题、Docker和虚拟机的问题、通知方式……&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据管理策略认知&lt;/strong&gt;：哪些是框架层面的数据，哪些是用例隔离数据，哪些是业务公共数据，数据能不能通过对象实时获得……&lt;/p&gt;
&lt;p&gt;想设计好一款自动化测试框架，需要用到的技术、考虑的细节还是多方面的。&lt;/p&gt;
&lt;p&gt;测试工程师说到底还是要关注技术，无论是转型测试开发还是继续在自动化测试方向深造，都需要扎实的技术功底。&lt;/p&gt;
&lt;h4 id=&#34;29&#34;&gt;2.9.自动化测试挺不错的，我们要立马开干&lt;/h4&gt;
&lt;p&gt;歪歪原则：自动化测试就是要兵贵神速，项目立项后要立刻开展，争取在开发同事没有交付代码前，先把自动化测试脚本完成。&lt;/p&gt;
&lt;p&gt;正解：对于很多不熟悉自动化测试工作的团队，很多系统都不具备手工测试的 &lt;strong&gt;可测性&lt;/strong&gt;（业务需求没稳定、代码技术方案没稳定、系统没稳定、人员没稳定……），贸然开展自动化测试只会适得其反。&lt;/p&gt;
&lt;p&gt;自动化测试最大的用途是用来做回归测试执行的，在系统不稳定时贸然开展自动化测试，最后只能导致一个结果：卒。&lt;/p&gt;
&lt;p&gt;以上就是用自动化测试搞垮团队的方法，希望你能够喜欢。&lt;/p&gt;</description>  
      <pubDate>2025-10-09 17:54:40</pubDate>  
      <link>https://testpoo.github.io/如何用自动化测试搞垮团队.html</link>  
      <guid isPermaLink="true">https://testpoo.github.io/如何用自动化测试搞垮团队.html</guid>
       
      <category>测试</category> 
      
    </item>
    
    <item> 
      <title>mysql函数汇总</title>  
      <description>&lt;div class=&#34;toc&#34;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#abs&#34;&gt;ABS函数： 求绝对值&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#sqrt&#34;&gt;SQRT函数：求二次方根&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#mod&#34;&gt;MOD函数：求余数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ceilceling&#34;&gt;CEIL和CELING函数：向上取整&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#floor&#34;&gt;FLOOR函数：向下取整&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#rand&#34;&gt;RAND函数：生成随机数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#sign&#34;&gt;SIGN函数：返回参数的符号&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#powpower&#34;&gt;POW和POWER函数：求次方&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#sin&#34;&gt;SIN函数：求正弦值&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#asin&#34;&gt;ASIN函数：求反正弦值&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#cos&#34;&gt;COS函数：求余弦值&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#acos&#34;&gt;ACOS函数：求反余弦值&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#tan&#34;&gt;TAN函数：求正切值&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#atan&#34;&gt;ATAN函数：求反正切值&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#cot&#34;&gt;COT函数：求余切值&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#length&#34;&gt;LENGTH函数：获取字符串长度&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#concat&#34;&gt;CONCAT函数：字符串拼接&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#insert&#34;&gt;INSERT函数：替换字符串&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#lower&#34;&gt;LOWER函数：将字母转换成小写&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#upper&#34;&gt;UPPER函数：将字母转换成大写&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#left&#34;&gt;LEFT函数：从左侧截取字符串&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#right&#34;&gt;RIGHT函数：从右侧截取字符串&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#trim&#34;&gt;TRIM函数：删除空格&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#replace&#34;&gt;REPLACE函数：字符串替换&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#substring&#34;&gt;SUBSTRING函数：截取字符串&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#reverse&#34;&gt;REVERSE函数：反转字符串&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#curdatecurrent_date&#34;&gt;CURDATE和CURRENT_DATE函数：获取系统当前日期&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#curtimecurrent_time&#34;&gt;CURTIME和CURRENT_TIME函数：获取系统当前时间&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#nowsysdate&#34;&gt;NOW和SYSDATE函数：获取当前时间日期&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#unix_timestampunix&#34;&gt;UNIX_TIMESTAMP函数：获取UNIX时间戳&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#from_unixtime&#34;&gt;FROM_UNIXTIME函数：时间戳转日期&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#month&#34;&gt;MONTH函数：获取指定日期的月份&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#monthname&#34;&gt;MONTHNAME函数：获取指定日期月份的英文名称&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#dayname&#34;&gt;DAYNAME函数：获取指定日期的星期名称&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#dayofweek&#34;&gt;DAYOFWEEK函数：获取日期对应的周索引&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#week&#34;&gt;WEEK函数：获取指定日期是一年中的第几周&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#dayofyear&#34;&gt;DAYOFYEAR函数：获取指定日期在一年中的位置&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#dayofmonth&#34;&gt;DAYOFMONTH函数：获取指定日期在一个月的位置&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#year&#34;&gt;YEAR函数：获取年份&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#time_to_sec&#34;&gt;TIME_TO_SEC函数：将时间转换为秒值&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#sec_to_time&#34;&gt;SEC_TO_TIME函数：将秒值转换为时间格式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#date_addadddate&#34;&gt;DATE_ADD和ADDDATE函数：向日期添加指定时间间隔&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#date_subsubdate&#34;&gt;DATE_SUB和SUBDATE函数：日期减法运算&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#addtime&#34;&gt;ADDTIME函数：时间加法运算&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#subtime&#34;&gt;SUBTIME函数：时间减法运算&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#datediff&#34;&gt;DATEDIFF函数：获取两个日期的时间间隔&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#date_format&#34;&gt;DATE_FORMAT函数：格式化指定的日期&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#weekday&#34;&gt;WEEKDAY函数：获取指定日期在一周内的索引位置&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#max&#34;&gt;MAX函数：查询指定列的最大值&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#min&#34;&gt;MIN函数：查询指定列的最小值&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#count&#34;&gt;COUNT函数：统计查询结果的行数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#sum&#34;&gt;SUM函数：求和&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#avg&#34;&gt;AVG函数：求平均值&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#if&#34;&gt;IF函数：判断&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ifnull&#34;&gt;IFNULL函数：判断是否为空&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#case&#34;&gt;CASE函数：搜索语句&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h3 id=&#34;abs&#34;&gt;ABS函数： 求绝对值&lt;/h3&gt;
&lt;p&gt;绝对值函数 &lt;code&gt;ABS(x)&lt;/code&gt; 返回 x 的绝对值。正数的绝对值是其本身，负数的绝对值为其相反数，0 的绝对值是 0。&lt;/p&gt;
&lt;p&gt;如：求 5、-2.4、-24 和 0 的绝对值，输入的 SQL 语句和执行结果如下所示。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;mysql&amp;gt; SELECT ABS(5),ABS(-2.4),ABS(-24),ABS(0);
+--------+-----------+----------+--------+
| ABS(5) | ABS(-2.4) | ABS(-24) | ABS(0) |
+--------+-----------+----------+--------+
|      5 |       2.4 |       24 |      0 |
+--------+-----------+----------+--------+
1 row in set (0.10 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由运行结果可知，5 的绝对值为 5，-2.4 的绝对值为 2.4，-24 的绝对值为 24，0 的绝对值是 0。&lt;/p&gt;
&lt;h3 id=&#34;sqrt&#34;&gt;SQRT函数：求二次方根&lt;/h3&gt;
&lt;p&gt;平方根函数 &lt;code&gt;SQRT(x)&lt;/code&gt; 返回非负数 x 的二次方根。负数没有平方根，返回结果为 NULL。&lt;/p&gt;
&lt;p&gt;如：求 25、120 和 -9 的二次平方根，输入的 SQL 语句和执行结果如下所示。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;mysql&amp;gt; SELECT SQRT(25),SQRT(120),SQRT(-9);
+----------+--------------------+----------+
| SQRT(25) | SQRT(120)          | SQRT(-9) |
+----------+--------------------+----------+
|        5 | 10.954451150103322 |     NULL |
+----------+--------------------+----------+
1 row in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由运行结果可知，5 的平方等于 25，因此 25 的平方根为 5；120 的平方根为 10.954451150103322；而负数没有平方根，因此 -9 返回的结果为 NULL。&lt;/p&gt;
&lt;h3 id=&#34;mod&#34;&gt;MOD函数：求余数&lt;/h3&gt;
&lt;p&gt;求余函数 &lt;code&gt;MOD(x,y)&lt;/code&gt; 返回 x 被 y 除后的余数，&lt;code&gt;MOD()&lt;/code&gt; 对于带有小数部分的数值也起作用，它返回除法运算后的余数。&lt;/p&gt;
&lt;p&gt;如：对 &lt;code&gt;MOD(63,8)&lt;/code&gt;、&lt;code&gt;MOD(120,10)&lt;/code&gt;、&lt;code&gt;MOD(15.5,3)&lt;/code&gt; 进行求余运算，输入的 SQL 语句和执行结果如下所示。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;mysql&amp;gt; SELECT MOD(63,8),MOD(120,10),MOD(15.5,3);
+-----------+-------------+-------------+
| MOD(63,8) | MOD(120,10) | MOD(15.5,3) |
+-----------+-------------+-------------+
|         7 |           0 |         0.5 |
+-----------+-------------+-------------+
1 row in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由运行结果可知，63 除以 8 余数是 7，120 除以 10 余数是 0，15.5 除以 3 余数是 0.5&lt;/p&gt;
&lt;h3 id=&#34;ceilceling&#34;&gt;CEIL和CELING函数：向上取整&lt;/h3&gt;
&lt;p&gt;取整函数 &lt;code&gt;CEIL(x)&lt;/code&gt; 和 &lt;code&gt;CEILING(x)&lt;/code&gt; 的意义相同，返回不小于 x 的最小整数值，返回值转化为一个 BIGINT。&lt;/p&gt;
&lt;p&gt;如：使用 &lt;code&gt;CEILING&lt;/code&gt; 函数返回最小整数，输入的 SQL 语句和执行结果如下所示。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;mysql&amp;gt; SELECT CEIL(-2.5),CEILING(2.5);
+------------+--------------+
| CEIL(-2.5) | CEILING(2.5) |
+------------+--------------+
|         -2 |            3 |
+------------+--------------+
1 row in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由执行结果可知，-2.5 为负数，不小于 -2.5 的最小整数为 -2，因此返回值为 -2；不小于 2.5 的最小整数为 3，因此返回值为 3。&lt;/p&gt;
&lt;h3 id=&#34;floor&#34;&gt;FLOOR函数：向下取整&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;FLOOR(x)&lt;/code&gt; 函数返回小于 x 的最大整数值。&lt;/p&gt;
&lt;p&gt;如：求 小于 5，5.66，-4，-4.66 的最大整数&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;mysql&amp;gt; SELECT FLOOR(5),FLOOR(5.66),FLOOR(-4),FLOOR(-4.66);
+----------+-------------+-----------+--------------+
| FLOOR(5) | FLOOR(5.66) | FLOOR(-4) | FLOOR(-4.66) |
+----------+-------------+-----------+--------------+
|        5 |           5 |        -4 |           -5 |
+----------+-------------+-----------+--------------+
1 row in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由运行结果可知，小于 5，5.66，-4，-4.66 的最大整数依次是 5，5，-4，-5。&lt;/p&gt;
&lt;h3 id=&#34;rand&#34;&gt;RAND函数：生成随机数&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;RAND()&lt;/code&gt; 函数被调用时，可以产生一个在 0 和 1 之间的随机数。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;mysql&amp;gt;  SELECT RAND(), RAND(), RAND();
+------------------+-----------------+------------------+
| RAND()           | RAND()          | RAND()           |
+------------------+-----------------+------------------+
| 0.45464584925645 | 0.1824410643265 | 0.54826780459682 |
+------------------+-----------------+------------------+
1 row in set (0.00 sec) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由运行结果可知，每次调用 &lt;code&gt;RAND()&lt;/code&gt; 函数，都会随机生成一个 0~1 之间的随机数 。&lt;/p&gt;
&lt;p&gt;当使用整数作为参数调用时，&lt;code&gt;RAND()&lt;/code&gt; 使用该值作为随机数的种子发生器。每次种子使用给定值生成，RAND() 将产生一个可重复的系列数字：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;mysql&amp;gt; SELECT RAND(1),RAND(),RAND(1);
+---------------------+--------------------+---------------------+
| RAND(1)             | RAND()             | RAND(1)             |
+---------------------+--------------------+---------------------+
| 0.40540353712197724 | 0.7901452330780637 | 0.40540353712197724 |
+---------------------+--------------------+---------------------+
1 row in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由运行结果可知，当向 &lt;code&gt;RAND()&lt;/code&gt; 函数中传入一个整数作为参数是，RAND() 函数产生的随机数可以重复。&lt;/p&gt;
&lt;h3 id=&#34;sign&#34;&gt;SIGN函数：返回参数的符号&lt;/h3&gt;
&lt;p&gt;符号函数 &lt;code&gt;SIGN(x)&lt;/code&gt; 返回参数的符号，x 的值为负、零和正时返回结果依次为 -1、0 和 1。&lt;/p&gt;
&lt;p&gt;如：使用 &lt;code&gt;SIGN&lt;/code&gt; 函数返回参数的符号，输入的 SQL 语句和执行结果如下所示。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;mysql&amp;gt; SELECT SIGN(-6),SIGN(0),SIGN(34);
+----------+---------+----------+
| SIGN(-6) | SIGN(0) | SIGN(34) |
+----------+---------+----------+
|       -1 |       0 |        1 |
+----------+---------+----------+
1 row in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由执行结果可知，SIGN(-6) 返回 -1，SIGN(0) 返回 0，SIGN(34) 返回 1。&lt;/p&gt;
&lt;h3 id=&#34;powpower&#34;&gt;POW和POWER函数：求次方&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;POW(x,y)&lt;/code&gt; 函数和 &lt;code&gt;POWER(x,y)&lt;/code&gt; 函数用于计算 x 的 y 次方。&lt;/p&gt;
&lt;p&gt;如：使用 &lt;code&gt;POW(x,y)&lt;/code&gt; 和 &lt;code&gt;POWER(x,y)&lt;/code&gt; 函数对参数 x 进行 y 次方的求值。输入 SQL 语句和执行结果如下。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;mysql&amp;gt; SELECT POW(5,-2),POW(10,3),POW(100,0),POWER(4,3),POWER(6,-3);
+-----------+-----------+------------+------------+----------------------+
| POW(5,-2) | POW(10,3) | POW(100,0) | POWER(4,3) | POWER(6,-3)          |
+-----------+-----------+------------+------------+----------------------+
|      0.04 |      1000 |          1 |         64 | 0.004629629629629629 |
+-----------+-----------+------------+------------+----------------------+
1 row in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由执行结果可知，POW(5,-2)的值是0.04，POW(10,3)的值是1000，POW(100,0)的值是1，POWER(4,3)的值是64，POWER(6,-3)的值是0.004629629629629629。&lt;/p&gt;
&lt;h3 id=&#34;sin&#34;&gt;SIN函数：求正弦值&lt;/h3&gt;
&lt;p&gt;正弦函数 &lt;code&gt;SIN(x)&lt;/code&gt; 返回 x 的正弦值，其中 x 为弧度值。&lt;/p&gt;
&lt;p&gt;如：使用 SIN 函数计算正弦值，输入的 SQL 语句和执行结果如下所示。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;mysql&amp;gt; SELECT SIN(1),SIN(0.5*PI());
+--------------------+---------------+
| SIN(1)             | SIN(0.5*PI()) |
+--------------------+---------------+
| 0.8414709848078965 |             1 |
+--------------------+---------------+
1 row in set (0.15 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意：PI() 函数返回圆周率（3.141593）&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;mysql&amp;gt; select PI();
+----------+
| PI()     |
+----------+
| 3.141593 |
+----------+
1 row in set (0.01 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;asin&#34;&gt;ASIN函数：求反正弦值&lt;/h3&gt;
&lt;p&gt;反正弦函数 &lt;code&gt;ASIN(x)&lt;/code&gt; 返回 x 的反正弦值，若 x 不在 -1 到 1 的范围之内，则返回 NULL。&lt;/p&gt;
&lt;p&gt;如：使用 ASIN 函数计算反正弦值，输入的 SQL 语句和执行结果如下所示。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;mysql&amp;gt; SELECT ASIN(0.8414709848078965),ASIN(2);
+--------------------------+---------+
| ASIN(0.8414709848078965) | ASIN(2) |
+--------------------------+---------+
|                        1 |    NULL |
+--------------------------+---------+
1 row in set (0.03 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由结果可以看到，函数 ASIN 和 SIN 互为反函数，ASIN(2) 中的参数 2 超出了正弦值的范围，因此返回 NULL。&lt;/p&gt;
&lt;h3 id=&#34;cos&#34;&gt;COS函数：求余弦值&lt;/h3&gt;
&lt;p&gt;余弦函数 &lt;code&gt;COS(x)&lt;/code&gt; 返回 x 的余弦值，x 为弧度值。&lt;/p&gt;
&lt;p&gt;如：使用 COS 函数计算余弦值，输入的 SQL 语句和执行结果如下所示&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;mysql&amp;gt; SELECT COS(1),COS(0),COS(PI());
+--------------------+--------+-----------+
| COS(1)             | COS(0) | COS(PI()) |
+--------------------+--------+-----------+
| 0.5403023058681398 |      1 |        -1 |
+--------------------+--------+-----------+
1 row in set (0.03 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由结果可以看到，COS(0) 的值为 1，COS(PI()) 的值为 -1，COS(1) 的值为 0.5403023058681398。&lt;/p&gt;
&lt;h3 id=&#34;acos&#34;&gt;ACOS函数：求反余弦值&lt;/h3&gt;
&lt;p&gt;反余弦函数 &lt;code&gt;ACOS(x)&lt;/code&gt; 。x 值的范围必须在 -1 和 1 之间，否则返回 NULL。&lt;/p&gt;
&lt;p&gt;如：使用 ACOS 函数计算反余弦值，输入的 SQL 语句和执行结果如下所示。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;mysql&amp;gt; SELECT ACOS(2),ACOS(1),ACOS(-1);
+---------+---------+-------------------+
| ACOS(2) | ACOS(1) | ACOS(-1)          |
+---------+---------+-------------------+
|    NULL |       0 | 3.141592653589793 |
+---------+---------+-------------------+
1 row in set (0.01 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由结果可以看到，函数 ACOS 和 COS 互为反函数。&lt;/p&gt;
&lt;h3 id=&#34;tan&#34;&gt;TAN函数：求正切值&lt;/h3&gt;
&lt;p&gt;正切函数 &lt;code&gt;TAN(x)&lt;/code&gt; 返回 x 的正切值，x 为给定的弧度值。&lt;/p&gt;
&lt;p&gt;如：使用 TAN 函数计算正切值，输入的 SQL 语句和执行结果如下所示。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;mysql&amp;gt; SELECT TAN(1),TAN(0);
+--------------------+--------+
| TAN(1)             | TAN(0) |
+--------------------+--------+
| 1.5574077246549023 |      0 |
+--------------------+--------+
1 row in set (0.03 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由运行结果可知，TAN(1) 的值为 1.5574077246549023，TAN(0) 的值为 0。 &lt;/p&gt;
&lt;h3 id=&#34;atan&#34;&gt;ATAN函数：求反正切值&lt;/h3&gt;
&lt;p&gt;反正切 &lt;code&gt;ATAN(x)&lt;/code&gt; 返回 x 的反正切值，正切为 x 的值。&lt;/p&gt;
&lt;p&gt;如：使用 ATAN 函数计算反正切值，输入的 SQL 语句和执行结果如下所示。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;mysql&amp;gt; SELECT ATAN(1.5574077246549023),ATAN(0);
+--------------------------+---------+
| ATAN(1.5574077246549023) | ATAN(0) |
+--------------------------+---------+
|                        1 |       0 |
+--------------------------+---------+
1 row in set (0.05 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由结果可以看到，函数 ATAN 和 TAN 互为反函数。&lt;/p&gt;
&lt;h3 id=&#34;cot&#34;&gt;COT函数：求余切值&lt;/h3&gt;
&lt;p&gt;余切函数 &lt;code&gt;COT(x)&lt;/code&gt; 返回 x 的余切值，x 是给定的弧度值。&lt;/p&gt;
&lt;p&gt;如：使用 COT 函数计算余切值，输入的 SQL 语句和执行结果如下所示。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;mysql&amp;gt; SELECT COT(1);
+--------------------+
| COT(1)             |
+--------------------+
| 0.6420926159343306 |
+--------------------+
1 row in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由运行结果可知，COT(1) 的值为 0.6420926159343306。 &lt;/p&gt;
&lt;h3 id=&#34;length&#34;&gt;LENGTH函数：获取字符串长度&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;LENGTH(str)&lt;/code&gt; 函数的返回值为字符串的字节长度，使用 uft8（UNICODE 的一种变长字符编码，又称万国码）编码字符集时，一个汉字是 3 个字节，一个数字或字母是一个字节。&lt;/p&gt;
&lt;p&gt;如：使用 LENGTH 函数计算字符串长度，输入的 SQL 语句和执行结果如下所示。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;mysql&amp;gt; SELECT LENGTH(&#39;name&#39;),LENGTH(&#39;数据库&#39;);
+----------------+---------------------+
|LENGTH(&#39;name&#39;)  | LENGTH(&#39;数据库&#39;)    |
+----------------+---------------------+
|              4 |                   9 |
+----------------+---------------------+
1 row in set (0.04 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由运行结果可以看到，一个汉字是 3 个字节，“数据库”字符串占 9 个字节。英文字符的个数和所占的字节相同，一个字符占 1 个字节。&lt;/p&gt;
&lt;h3 id=&#34;concat&#34;&gt;CONCAT函数：字符串拼接&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;CONCAT(sl，s2，...)&lt;/code&gt; 函数返回结果为连接参数产生的字符串，或许有一个或多个参数。&lt;/p&gt;
&lt;p&gt;若有任何一个参数为 NULL，则返回值为 NULL。若所有参数均为非二进制字符串，则结果为非二进制字符串。若自变量中含有任一二进制字符串，则结果为一个二进制字符串。&lt;/p&gt;
&lt;p&gt;如：使用 CONCAT 函数连接字符串，输入的 SQL 语句和执行结果如下所示。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;mysql&amp;gt; SELECT CONCAT(&#39;MySQL&#39;,&#39;5.7&#39;),CONCAT(&#39;MySQL&#39;,NULL);
+-----------------------+----------------------+
| CONCAT(&#39;MySQL&#39;,&#39;5.7&#39;) | CONCAT(&#39;MySQL&#39;,NULL) |
+-----------------------+----------------------+
| MySQL5.7              | NULL                 |
+-----------------------+----------------------+
1 row in set (0.03 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由运行结果可知，CONCAT(&#39;MySQL&#39;，&#39;5.7&#39;) 返回两个字符串连接后的字符串；CONCAT(‘MySQL’，NULL) 中有一个参数为 NULL，因此返回结果为 NULL。&lt;/p&gt;
&lt;h3 id=&#34;insert&#34;&gt;INSERT函数：替换字符串&lt;/h3&gt;
&lt;p&gt;替换字符串函数 &lt;code&gt;INSERT(s1，x，len，s2)&lt;/code&gt; 返回字符串 s1，子字符串起始于 x 位置，并且用 len 个字符长的字符串代替 s2。&lt;/p&gt;
&lt;p&gt;若 x 超过字符串长度，则返回值为原始字符串。假如 len 的长度大于其他字符串的长度，则从位置 x 开始替换。若任何一个参数为 NULL，则返回值为 NULL。&lt;/p&gt;
&lt;p&gt;如：使用 INSERT 函数进行字符串替换操作，输入的 SQL 语句和执行结果如下所示。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;mysql&amp;gt; SELECT INSERT(&#39;Football&#39;,2,4,&#39;Play&#39;) AS col1,
    -&amp;gt; INSERT(&#39;Football&#39;,-1,4,&#39;Play&#39;) AS col2,
    -&amp;gt; INSERT(&#39;Football&#39;,3,20,&#39;Play&#39;) AS col3;
+----------+----------+--------+
| col1     | col2     | col3   |
+----------+----------+--------+
| FPlayall | Football | FoPlay |
+----------+----------+--------+
1 row in set (0.04 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由执行结果可知：
第一个函数 &lt;code&gt;INSERT(&#39;Football&#39;，2，4，&#39;Play&#39;)&lt;/code&gt; 将&lt;code&gt;Football&lt;/code&gt;从第 2 个字符开始长度为 4 的字符串替换为 Play，结果为&lt;code&gt;FPlayall&lt;/code&gt;；
第二个函数 &lt;code&gt;(&#39;Football&#39;，-1，4，&#39;Play&#39;)&lt;/code&gt; 中的起始位置 -1 超出了字符串长度，直接返回原字符串；
第三个函数 &lt;code&gt;INSERT(&#39;Football&#39;，3，20，&#39;Play&#39;)&lt;/code&gt; 替换长度超出了原字符串长度，则从第 3 个字符开始，截取后面所有的字符，并替换为指定字符 &lt;code&gt;Play&lt;/code&gt;，结果为&lt;code&gt;FoPlay&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;lower&#34;&gt;LOWER函数：将字母转换成小写&lt;/h3&gt;
&lt;p&gt;字母小写转换函数 &lt;code&gt;LOWER(str)&lt;/code&gt; 可以将字符串 str 中的字母字符全部转换成小写。&lt;/p&gt;
&lt;p&gt;如：使用 LOWER 函数将字符串中所有的字母字符转换为小写，输入的 SQL 语句和执行结果如下所示。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;mysql&amp;gt; SELECT LOWER(&#39;BLUE&#39;),LOWER(&#39;Blue&#39;);
+---------------+---------------+
| LOWER(&#39;BLUE&#39;) | LOWER(&#39;Blue&#39;) |
+---------------+---------------+
| blue          | blue          |
+---------------+---------------+
1 row in set (0.03 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由结果可以看到，原来所有字母为大写的，全部转换为小写，如&lt;code&gt;BLUE&lt;/code&gt;，转换之后为&lt;code&gt;blue&lt;/code&gt;；大小写字母混合的字符串，小写不变，大写字母转换为小写字母，如&lt;code&gt;Blue&lt;/code&gt;，转换之后为&lt;code&gt;bule&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;upper&#34;&gt;UPPER函数：将字母转换成大写&lt;/h3&gt;
&lt;p&gt;字母大写转换函数 &lt;code&gt;UPPER(str)&lt;/code&gt; 可以将字符串 str 中的字母字符全部转换成大写。&lt;/p&gt;
&lt;p&gt;如：使用 UPPER 函数将字符串中所有的字母字符转换为大写，输入的 SQL 语句和执行结果如下所示。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;mysql&amp;gt; SELECT UPPER(&#39;green&#39;),UPPER(&#39;Green&#39;);
+----------------+----------------+
| UPPER(&#39;green&#39;) | UPPER(&#39;Green&#39;) |
+----------------+----------------+
| GREEN          | GREEN          |
+----------------+----------------+
1 row in set (0.03 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由结果可以看到，原来所有字母字符为小写的，全部转换为大写，如&lt;code&gt;green&lt;/code&gt;，转换之后为&lt;code&gt;GREEN&lt;/code&gt;；大小写字母混合的字符串，大写不变，小写字母转换为大写字母，如&lt;code&gt;Green&lt;/code&gt;，转换之后为&lt;code&gt;GREEN&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;left&#34;&gt;LEFT函数：从左侧截取字符串&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;LEFT(s，n)&lt;/code&gt; 函数返回字符串 s 最左边的 n 个字符。&lt;/p&gt;
&lt;p&gt;如：使用 LEFT 函数返回字符串中左边的字符，输入的 SQL 语句和执行结果如下所示。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;mysql&amp;gt; SELECT LEFT(&#39;MySQL&#39;,2);
+-----------------+
| LEFT(&#39;MySQL&#39;,2) |
+-----------------+
| My              |
+-----------------+
1 row in set (0.04 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由运行结果可知，返回字符串&lt;code&gt;MySQL&lt;/code&gt;左边开始的长度为 2 的子字符串，结果为&lt;code&gt;My&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;right&#34;&gt;RIGHT函数：从右侧截取字符串&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;RIGHT(s，n)&lt;/code&gt; 函数返回字符串 s 最右边的 n 个字符。&lt;/p&gt;
&lt;p&gt;如：使用 RIGHT 函数返回字符串中右边的字符，输入的 SQL 语句和执行结果如下所示。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;mysql&amp;gt; SELECT RIGHT(&#39;MySQL&#39;,3);
+------------------+
| RIGHT(&#39;MySQL&#39;,3) |
+------------------+
| SQL              |
+------------------+
1 row in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由执行结果可知，函数返回字符串&lt;code&gt;MySQL&lt;/code&gt;右边开始的长度为3的子字符串，结果为&lt;code&gt;SQL&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;trim&#34;&gt;TRIM函数：删除空格&lt;/h3&gt;
&lt;p&gt;删除空格函数 &lt;code&gt;TRIM(s)&lt;/code&gt; 删除字符串 s 两侧的空格。&lt;/p&gt;
&lt;p&gt;如：&lt;code&gt;SELECT CONCAT(&#39;[&#39;，TRIM(&#39;mobile&#39;)，&#39;]&#39;)&lt;/code&gt;；输入的 SQL 语句和执行结果如下所示。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;mysql&amp;gt; SELECT &#39;[   mobile   ]&#39;,CONCAT(&#39;[&#39;,TRIM(&#39;   mobile   &#39;),&#39;]&#39;);
+----------------+--------------------------------------+
| [   mobile   ] | CONCAT(&#39;[&#39;,TRIM(&#39;   mobile   &#39;),&#39;]&#39;) |
+----------------+--------------------------------------+
| [   mobile   ] | [mobile]                             |
+----------------+--------------------------------------+
1 row in set (0.07 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由执行结果可知，函数执行之后字符串&lt;code&gt;mobile&lt;/code&gt;两边的空格被删除，结果为&lt;code&gt;mobile&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;replace&#34;&gt;REPLACE函数：字符串替换&lt;/h3&gt;
&lt;p&gt;替换函数 &lt;code&gt;REPLACE(s，s1，s2)&lt;/code&gt; 使用字符串 s2 替换字符串 s 中所有的字符串 s1。&lt;/p&gt;
&lt;p&gt;如：使用 REPLACE 函数进行字符串替换操作，输入的 SQL 语句和执行过程如下所示。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;mysql&amp;gt; SELECT REPLACE(&#39;aaa.mysql.com&#39;,&#39;a&#39;,&#39;w&#39;);
+----------------------------------+
| REPLACE(&#39;aaa.mysql.com&#39;,&#39;a&#39;,&#39;w&#39;) |
+----------------------------------+
| www.mysql.com                    |
+----------------------------------+
1 row in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由运行结果可以看出，使用 &lt;code&gt;REPLACE(&#39;aaa.mysql.com&#39;，&#39;a&#39;，&#39;w&#39;)&lt;/code&gt; 将&lt;code&gt;“aaa.mysql.com”&lt;/code&gt;字符串的“a”字符替换为“w”字符，结果为&lt;code&gt;www.mysql.com&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;substring&#34;&gt;SUBSTRING函数：截取字符串&lt;/h3&gt;
&lt;p&gt;获取子串函数 &lt;code&gt;SUBSTRING(s，n，len)&lt;/code&gt; 带有 len 参数的格式，从字符串 s 返回一个长度同 len 字符相同的子字符串，起始于位置 n。&lt;/p&gt;
&lt;p&gt;也可能对 n 使用一个负值。假若这样，则子字符串的位置起始于字符串结尾的第 n 个字符，即倒数第 n 个字符，而不是字符串的开头位置。&lt;/p&gt;
&lt;p&gt;如：使用 SUBSTRING 函数获取指定位置处的子字符串，输入的 SQL 语句和执行结果如下所示。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;mysql&amp;gt; SELECT SUBSTRING(&#39;computer&#39;,3) AS col1,
    -&amp;gt; SUBSTRING(&#39;computer&#39;,3,4) AS col2,
    -&amp;gt; SUBSTRING(&#39;computer&#39;,-3) AS col3,
    -&amp;gt; SUBSTRING(&#39;computer&#39;,-5,3) AS col4;
+--------+------+------+------+
| col1   | col2 | col3 | col4 |
+--------+------+------+------+
| mputer | mput | ter  | put  |
+--------+------+------+------+
1 row in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;SUBSTRING(&#39;computer&#39;，3)&lt;/code&gt; 返回从第 3 个位置开始到字符串结尾的子字符串，结果为&lt;code&gt;mputer&lt;/code&gt;；&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SUBSTRING(&#39;computer&#39;，3，4)&lt;/code&gt; 返回从第 3 个位置开始长度为 4 的子字符串，结果为&lt;code&gt;mput&lt;/code&gt;；&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SUBSTRING(computer，-3)&lt;/code&gt; 返回从倒数第 3 个位置到字符串结尾的子字符串，结果为&lt;code&gt;ter&lt;/code&gt;；&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SUBSTRING(computer，-5，3)&lt;/code&gt; 返回从倒数第 5 个位置开始长度为 3 的子字符串，结果为&lt;code&gt;put&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;reverse&#34;&gt;REVERSE函数：反转字符串&lt;/h3&gt;
&lt;p&gt;字符串逆序函数 &lt;code&gt;REVERSE(s)&lt;/code&gt; 可以将字符串 s 反转，返回的字符串的顺序和 s 字符串的顺序相反。&lt;/p&gt;
&lt;p&gt;如：使用 REVERSE 函数反转字符串，输入的 SQL 语句和执行过程如下所示。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;mysql&amp;gt; SELECT REVERSE(&#39;hello&#39;);
+------------------+
| REVERSE(&#39;hello&#39;) |
+------------------+
| olleh            |
+------------------+
1 row in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由运行结果可以看出，字符串&lt;code&gt;hello&lt;/code&gt;经过 &lt;code&gt;REVERSE&lt;/code&gt; 函数处理之后所有字符顺序被反转，结果为&lt;code&gt;olleh&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;curdatecurrent_date&#34;&gt;CURDATE和CURRENT_DATE函数：获取系统当前日期&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;CURDATE()&lt;/code&gt; 和 &lt;code&gt;CURRENT_DATE()&lt;/code&gt; 函数的作用相同，将当前日期按照&lt;code&gt;YYYY-MM-DD&lt;/code&gt;或&lt;code&gt;YYYYMMDD&lt;/code&gt;格式的值返回，具体格式根据函数用在字符串或数字语境中而定。&lt;/p&gt;
&lt;p&gt;如：使用日期函数 &lt;code&gt;CURDATE&lt;/code&gt; 和 &lt;code&gt;CURRENT_DATE&lt;/code&gt; 获取系统当前日期，输入的 SQL 语句和执行结果如下所示。&lt;/p&gt;
&lt;p&gt;由运行结果可以看到，两个函数的作用相同，返回了相同的系统当前日期，“CURDATE()+0”将当前日期值转换为数值型的。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;mysql&amp;gt; SELECT CURDATE(),CURRENT_DATE(),CURRENT_DATE()+0;
+------------+----------------+------------------+
| CURDATE()  | CURRENT_DATE() | CURRENT_DATE()+0 |
+------------+----------------+------------------+
| 2022-04-19 | 2022-04-19     |         20220419 |
+------------+----------------+------------------+
1 row in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;curtimecurrent_time&#34;&gt;CURTIME和CURRENT_TIME函数：获取系统当前时间&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;CURTIME()&lt;/code&gt; 和 &lt;code&gt;CURRENT_TIME()&lt;/code&gt; 函数的作用相同，将当前时间以&lt;code&gt;HH:MM:SS&lt;/code&gt;或&lt;code&gt;HHMMSS&lt;/code&gt;格式返回，具体格式根据函数用在字符串或数字语境中而定。&lt;/p&gt;
&lt;p&gt;如：使用时间函数 &lt;code&gt;CURTIME&lt;/code&gt; 和 &lt;code&gt;CURRENT_TIME&lt;/code&gt; 获取系统当前时间，输入的 SQL 语句和执行结果如下所示。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;mysql&amp;gt; SELECT CURTIME(),CURRENT_TIME();
+-----------+----------------+
| CURTIME() | CURRENT_TIME() |
+-----------+----------------+
| 18:34:43  | 18:34:43       |
+-----------+----------------+
1 row in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由运行结果可以看出，两个函数返回的结果相同，都返回了当前的系统时间。CURRENT_TIME()+0 是将当前日期值转换为数值型的。&lt;/p&gt;
&lt;h3 id=&#34;nowsysdate&#34;&gt;NOW和SYSDATE函数：获取当前时间日期&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;NOW()&lt;/code&gt; 和 &lt;code&gt;SYSDATE()&lt;/code&gt; 函数的作用相同，都是返回当前日期和时间值，格式为&lt;code&gt;YYYY-MM-DD HH:MM:SS&lt;/code&gt;或&lt;code&gt;YYYYMMDDHHMMSS&lt;/code&gt;，具体格式根据函数用在字符串或数字语境中而定。&lt;/p&gt;
&lt;p&gt;如：使用日期时间函数 &lt;code&gt;NOW&lt;/code&gt; 和 &lt;code&gt;SYSDATE&lt;/code&gt; 获取当前系统的日期和时间，输入的 SQL 语句和执行结果如下所示。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;mysql&amp;gt; SELECT NOW(),SYSDATE();
+---------------------+---------------------+
| NOW()               | SYSDATE()           |
+---------------------+---------------------+
| 2022-04-19 13:47:53 | 2022-04-19 13:47:53 |
+---------------------+---------------------+
1 row in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由运行结果可以看到，&lt;code&gt;NOW&lt;/code&gt; 函数和 &lt;code&gt;SYSDATE&lt;/code&gt; 函数返回的结果是相同的。&lt;/p&gt;
&lt;p&gt;虽然 &lt;code&gt;NOW()&lt;/code&gt; 和 &lt;code&gt;SYSDATE()&lt;/code&gt; 都表示当前时间，但是 &lt;code&gt;NOW()&lt;/code&gt; 取的是语句开始执行的时间，而 &lt;code&gt;SYSDATE()&lt;/code&gt; 取的是语句执行过程中动态的实时时间。&lt;/p&gt;
&lt;p&gt;如：先查询了 NOW() 和 SYSDATE()，然后 sleep 了 3 秒，再查询 NOW() 和 SYSDATE()，结果如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;mysql&amp;gt; select now(),sysdate(),sleep(3),now(),sysdate();
+---------------------+---------------------+----------+---------------------+---------------------+
| now()               | sysdate()           | sleep(3) | now()               | sysdate()           |
+---------------------+---------------------+----------+---------------------+---------------------+
| 2022-04-19 13:48:05 | 2022-04-19 13:48:05 |        0 | 2022-04-19 13:48:05 | 2022-04-19 13:48:08 |
+---------------------+---------------------+----------+---------------------+---------------------+
1 row in set (3.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由运行结果可以看出，&lt;code&gt;NOW()&lt;/code&gt; 函数始终获取的是 SQL 语句开始执行的时间，而 &lt;code&gt;SYSDATE()&lt;/code&gt; 函数则是动态获取的实时时间。&lt;/p&gt;
&lt;h3 id=&#34;unix_timestampunix&#34;&gt;UNIX_TIMESTAMP函数：获取UNIX时间戳&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;UNIX_TIMESTAMP(date)&lt;/code&gt; 若无参数调用，返回一个无符号整数类型的 UNIX 时间戳（&#39;1970-01-01 00:00:00&#39;GMT之后的秒数）。&lt;/p&gt;
&lt;p&gt;若用 date 来调用 &lt;code&gt;UNIX_TIMESTAMP()&lt;/code&gt;，它会将参数值以&#39;1970-01-01 00:00:00&#39;GMT后的秒数的形式返回。&lt;/p&gt;
&lt;p&gt;如：使用 &lt;code&gt;UNIX_TIMESTAMP()&lt;/code&gt; 函数返回 UNIX 格式的时间戳，输入 SQL 语句和执行结果如下。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;mysql&amp;gt; SELECT UNIX_TIMESTAMP(),UNIX_TIMESTAMP(NOW()),NOW();
+------------------+-----------------------+---------------------+
| UNIX_TIMESTAMP() | UNIX_TIMESTAMP(NOW()) | NOW()               |
+------------------+-----------------------+---------------------+
|       1650347304 |            1650347304 | 2022-04-19 13:48:24 |
+------------------+-----------------------+---------------------+
1 row in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;from_unixtime&#34;&gt;FROM_UNIXTIME函数：时间戳转日期&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;FROM_UNIXTIME(date)&lt;/code&gt; 函数把 UNIX 时间戳转换为普通格式的日期时间值，与 &lt;code&gt;UNIX_TIMESTAMP ()&lt;/code&gt; 函数互为反函数。&lt;/p&gt;
&lt;p&gt;如：使用 &lt;code&gt;FROM_UNIXTIME(date)&lt;/code&gt; 函数将 UNIX 时间戳转换为普通格式时间。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;mysql&amp;gt; select FROM_UNIXTIME(1650347304);
+---------------------------+
| FROM_UNIXTIME(1650347304) |
+---------------------------+
| 2022-04-19 13:48:24       |
+---------------------------+
1 row in set (0.00 sec)0 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;month&#34;&gt;MONTH函数：获取指定日期的月份&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;MONTH(date)&lt;/code&gt; 函数返回指定 date 对应的月份，范围为 1～12。&lt;/p&gt;
&lt;p&gt;如：使用 MONTH() 函数返回指定日期中的月份，输入的 SQL 语句和执行结果如下所示。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;mysql&amp;gt; SELECT MONTH(&#39;2022-04-19&#39;);
+---------------------+
| MONTH(&#39;2022-04-19&#39;) |
+---------------------+
|                   4 |
+---------------------+
1 row in set (0.03 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由运行结果可知，2022-04-19 对应的月份是 4。&lt;/p&gt;
&lt;h3 id=&#34;monthname&#34;&gt;MONTHNAME函数：获取指定日期月份的英文名称&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;MONTHNAME(date)&lt;/code&gt; 函数返回日期 date 对应月份的英文全名。&lt;/p&gt;
&lt;p&gt;如：使用 &lt;code&gt;MONTHNAME()&lt;/code&gt; 函数返回指定日期中月份的名称，输入的 SQL 语句和执行结果如下所示。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;mysql&amp;gt; SELECT MONTHNAME(&#39;2022-04-19&#39;);
+-------------------------+
| MONTHNAME(&#39;2022-04-19&#39;) |
+-------------------------+
| April                   |
+-------------------------+
1 row in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由运行结果可知，2022-04-19 对应月份的英文全名是  April。&lt;/p&gt;
&lt;h3 id=&#34;dayname&#34;&gt;DAYNAME函数：获取指定日期的星期名称&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;DAYNAME(date)&lt;/code&gt; 函数返回 date 对应的工作日英文名称，例如 Sunday、Monday 等。&lt;/p&gt;
&lt;p&gt;如：使用 &lt;code&gt;DAYNAME(date)&lt;/code&gt; 函数返回指定日期的工作日名称。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;mysql&amp;gt; SELECT DAYNAME(&#39;2022-04-19&#39;);
+-----------------------+
| DAYNAME(&#39;2022-04-19&#39;) |
+-----------------------+
| Tuesday               |
+-----------------------+
1 row in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由运行结果可知，2022-04-19 这一天是星期二，英文名称是 Tuesday。&lt;/p&gt;
&lt;h3 id=&#34;dayofweek&#34;&gt;DAYOFWEEK函数：获取日期对应的周索引&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;DAYOFWEEK(d)&lt;/code&gt; 函数返回 d 对应的一周中的索引（位置）。1 表示周日，2 表示周一，……，7 表示周六。这些索引值对应于ODBC标准。&lt;/p&gt;
&lt;p&gt;如：使用 &lt;code&gt;DAYOFWEEK()&lt;/code&gt; 函数返回日期对应的周索引，输入的 SQL 语句和执行结果如下所示。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;mysql&amp;gt; SELECT DAYOFWEEK(&#39;2022-04-19&#39;);
+-------------------------+
| DAYOFWEEK(&#39;2022-04-19&#39;) |
+-------------------------+
|                       3 |
+-------------------------+
1 row in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由运行结果可知，2022 年 4 月 19 日为周二，因此返回其对应的索引值为 3。&lt;/p&gt;
&lt;h3 id=&#34;week&#34;&gt;WEEK函数：获取指定日期是一年中的第几周&lt;/h3&gt;
&lt;p&gt;WEEK() 函数计算日期 date 是一年中的第几周。&lt;code&gt;WEEK(date,mode)&lt;/code&gt; 函数允许指定星期是否起始于周日或周一，以及返回值的范围是否为 0～52 或 1～53。&lt;/p&gt;
&lt;p&gt;WEEK函数接受两个参数：
&lt;code&gt;date&lt;/code&gt;是要获取周数的日期。
&lt;code&gt;mode&lt;/code&gt;是一个可选参数，用于确定周数计算的逻辑。&lt;/p&gt;
&lt;p&gt;如果忽略 mode 参数，默认情况下 WEEK 函数将使用 &lt;code&gt;default_week_format&lt;/code&gt; 系统变量的值。要获取 &lt;code&gt;default_week_format&lt;/code&gt; 变量的当前值，请使用 &lt;code&gt;SHOW VARIABLES&lt;/code&gt; 语句如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;mysql&amp;gt; SHOW VARIABLES LIKE &#39;default_week_format&#39;;
+---------------------+-------+
| Variable_name       | Value |
+---------------------+-------+
| default_week_format | 0     |
+---------------------+-------+
1 row in set, 1 warning (0.02 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如：使用 &lt;code&gt;WEEK(date)&lt;/code&gt; 函数查询指定日期是一年中的第几周。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;mysql&amp;gt; SELECT WEEK(&#39;2022-04-19&#39;,1);
+----------------------+
| WEEK(&#39;2022-04-19&#39;,1) |
+----------------------+
|                   16 |
+----------------------+
1 row in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由运行结果可知，2022-04-19 是一年中的第 16 周。&lt;/p&gt;
&lt;h3 id=&#34;dayofyear&#34;&gt;DAYOFYEAR函数：获取指定日期在一年中的位置&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;DAYOFYEAR(d)&lt;/code&gt; 函数返回 d 是一年中的第几天，范围为 1～366。&lt;/p&gt;
&lt;p&gt;如：使用 &lt;code&gt;DAYOFYEAR()&lt;/code&gt; 函数返回指定日期在一年中的位置，输入的 SQL 语句和执行过程如下所示。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;mysql&amp;gt; SELECT DAYOFYEAR(&#39;2022-04-19&#39;);
+-------------------------+
| DAYOFYEAR(&#39;2022-04-19&#39;) |
+-------------------------+
|                     109 |
+-------------------------+
1 row in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由运行结果可以看出，1、3月份各31天，2月份各28天，再加上4月份19天，因此返回结果为109。&lt;/p&gt;
&lt;h3 id=&#34;dayofmonth&#34;&gt;DAYOFMONTH函数：获取指定日期在一个月的位置&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;DAYOFMONTH(d)&lt;/code&gt; 函数返回 d 是一个月中的第几天，范围为 1～31。&lt;/p&gt;
&lt;p&gt;如：使用 &lt;code&gt;DAYOFMONTH()&lt;/code&gt; 函数返回指定日期在一个月中的位置，输入的 SQL 语句和执行结果如下所示。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;mysql&amp;gt; SELECT DAYOFMONTH(&#39;2022-04-19&#39;);
+--------------------------+
| DAYOFMONTH(&#39;2022-04-19&#39;) |
+--------------------------+
|                       19 |
+--------------------------+
1 row in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由运行结果可以看出，2022-04-19 是这个月的第 19 天。&lt;/p&gt;
&lt;h3 id=&#34;year&#34;&gt;YEAR函数：获取年份&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;YEAR()&lt;/code&gt; 函数可以从指定日期值中来获取年份值。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;YEAR()&lt;/code&gt; 函数需要接受 date 参数，并返回日期的年份。语法格式如下：&lt;code&gt;YEAR(date)&lt;/code&gt;;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;YEAR()&lt;/code&gt; 函数返回的年份值范围为 1000 到 9999，如果日期为零，&lt;code&gt;YEAR()&lt;/code&gt; 函数返回 0。&lt;/p&gt;
&lt;p&gt;如：使用 &lt;code&gt;YEAR()&lt;/code&gt; 函数获取当前时间的年份，输入 SQL 语句和执行结果如下。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;mysql&amp;gt; SELECT YEAR(NOW());
+-------------+
| YEAR(NOW()) |
+-------------+
|        2022 |
+-------------+
1 row in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;time_to_sec&#34;&gt;TIME_TO_SEC函数：将时间转换为秒值&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;TIME_TO_SEC(time)&lt;/code&gt; 函数返回将参数 time 转换为秒数的时间值，转换公式为“小时 ×3600+ 分钟 ×60+ 秒”。&lt;/p&gt;
&lt;p&gt;如：使用 &lt;code&gt;TIME_TO_SEC(time)&lt;/code&gt; 函数将时间值转换为秒值。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;mysql&amp;gt; SELECT TIME_TO_SEC(&#39;13:13:13&#39;);
+-------------------------+
| TIME_TO_SEC(&#39;13:13:13&#39;) |
+-------------------------+
|                   47593 |
+-------------------------+
1 row in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由执行结果可以看出，根据计算公式“13×3600+13×60+13”得出结果秒数 47593。&lt;/p&gt;
&lt;h3 id=&#34;sec_to_time&#34;&gt;SEC_TO_TIME函数：将秒值转换为时间格式&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;SEC_TO_TIME(seconds)&lt;/code&gt; 函数返回将参数 seconds 转换为小时、分钟和秒数的时间值。&lt;/p&gt;
&lt;p&gt;如：使用 &lt;code&gt;SEC_TO_TIME(seconds)&lt;/code&gt; 函数将秒值转换为时间格式，输入 SQL 语句和执行结果如下。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;mysql&amp;gt; SELECT SEC_TO_TIME(&#39;47593&#39;);
+----------------------+
| SEC_TO_TIME(&#39;47593&#39;) |
+----------------------+
| 13:13:13.000000      |
+----------------------+
1 row in set (0.01 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由执行结果可以看出，将上例中得到的秒数 47593 通过 &lt;code&gt;SEC_TO_TIME(seconds)&lt;/code&gt; 函数计算，返回结果是时间值 &lt;code&gt;13:13:13.000000&lt;/code&gt;，为字符串型。&lt;/p&gt;
&lt;h3 id=&#34;date_addadddate&#34;&gt;DATE_ADD和ADDDATE函数：向日期添加指定时间间隔&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;DATE_ADD(date,INTERVAL expr type)&lt;/code&gt; 和 &lt;code&gt;ADDDATE(date,INTERVAL expr type)&lt;/code&gt; 两个函数的作用相同，都是用于执行日期的加运算。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;DATE_ADD()&lt;/code&gt; 和 &lt;code&gt;ADDDATE()&lt;/code&gt; 函数有两个参数：
&lt;code&gt;date&lt;/code&gt; 是 &lt;code&gt;DATE&lt;/code&gt; 或 &lt;code&gt;DATETIME&lt;/code&gt; 的起始值。
&lt;code&gt;INTERVAL expr type&lt;/code&gt;是要添加到起始日期值的间隔值。&lt;/p&gt;
&lt;p&gt;如：使用 &lt;code&gt;DATE_ADD(date,INTERVAL expr type)&lt;/code&gt; 函数执行日期的加运算。输入 SQL 语句和执行结果如下。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;mysql&amp;gt; SELECT DATE_ADD(&#39;2022-04-19 23:59:59&#39;,INTERVAL 1 SECOND) AS C1,
    -&amp;gt; DATE_ADD(&#39;2022-04-19 23:59:59&#39;,INTERVAL &#39;1:1&#39; MINUTE_SECOND) AS C2,
    -&amp;gt; ADDDATE(&#39;2022-04-19 23:59:59&#39;,INTERVAL 1 SECOND) AS C3;
+---------------------+---------------------+---------------------+
| C1                  | C2                  | C3                  |
+---------------------+---------------------+---------------------+
| 2022-04-20 00:00:00 | 2022-04-20 00:01:00 | 2022-04-20 00:00:00 |
+---------------------+---------------------+---------------------+
1 row in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由执行结果可以看出，&lt;code&gt;DATE_ADD(date,INTERVAL expr type)&lt;/code&gt; 和 &lt;code&gt;ADDDATE(date,INTERVAL expr type)&lt;/code&gt; 函数的功能完全相同，在原始时间 &lt;code&gt;2022-04-19 23:59:59&lt;/code&gt; 上加 1 秒之后结果都是 &lt;code&gt;2022-04-19 23:59:59&lt;/code&gt; ；在原始时间上加 1 分钟 1 秒的写法是表达式 &#39;1:1&#39;，最终可得结果 &lt;code&gt;2022-04-20 00:01:00&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;如：使用 &lt;code&gt;ADDDATE()&lt;/code&gt; 函数执行日期的加操作，输入的 SQL 语句和执行结果如下所示。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;mysql&amp;gt; SELECT ADDDATE(&#39;2022-04-19 23:59:59&#39;, INTERVAL 1 SECOND) AS col1,
    -&amp;gt; ADDDATE(&#39;2022-04-19 23:59:59&#39; ,INTERVAL &#39;1:1&#39; MINUTE_SECOND) AS col2;
+---------------------+---------------------+
| col1                | col2                |
+---------------------+---------------------+
| 2022-04-20 00:00:00 | 2022-04-20 00:01:00 |
+---------------------+---------------------+
1 row in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由运行结果可以看到，&lt;code&gt;ADDDATE(&#39;2022-04-19 23:59:59&#39;, INTERVAL 1 SECOND)&lt;/code&gt; 函数执行的结果将时间增加 1 秒后返回，结果为&lt;code&gt;2022-04-20 00:00:00&lt;/code&gt;；&lt;code&gt;ADDDATE(&#39;2022-04-19 23:59:59&#39; ,INTERVAL &#39;1:1&#39; MINUTE_SECOND)&lt;/code&gt; 函数的日期运算类型是 &lt;code&gt;MINUTE_SECOND&lt;/code&gt;，将指定时间增加 1 分 1 秒后返回，结果为&lt;code&gt;2022-04-20 00:01:00&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;date_subsubdate&#34;&gt;DATE_SUB和SUBDATE函数：日期减法运算&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;DATE_SUB(date,INTERVAL expr type)&lt;/code&gt; 和 &lt;code&gt;SUBDATE(date,INTERVAL expr type)&lt;/code&gt; 两个函数作用相同，都是执行日期的减法运算。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;DATE_SUB()&lt;/code&gt; 和 &lt;code&gt;SUBDATE()&lt;/code&gt; 函数接受两个参数：
&lt;code&gt;date&lt;/code&gt; 是 &lt;code&gt;DATE&lt;/code&gt; 或 &lt;code&gt;DATETIME&lt;/code&gt; 的起始值。
&lt;code&gt;expr&lt;/code&gt; 是一个字符串，用于确定从起始日期减去的间隔值。type 是 expr 可解析的间隔单位，例如 DAY，HOUR 等&lt;/p&gt;
&lt;p&gt;如：使用 &lt;code&gt;DATE_SUB(date,INTERVAL expr type)&lt;/code&gt; 和 &lt;code&gt;SUBDATE(date,INTERVAL expr type)&lt;/code&gt; 函数执行日期的减运算，输入 SQL 语句与执行结果如下。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;mysql&amp;gt; SELECT DATE_SUB(&#39;2022-04-19&#39;,INTERVAL 31 DAY) AS C1,
    -&amp;gt; SUBDATE(&#39;2022-04-19&#39;,INTERVAL 31 DAY) AS C2,
    -&amp;gt; DATE_SUB(&#39;2022-04-19 00:01:00&#39;,INTERVAL &#39;0 0:1:1&#39; DAY_SECOND) AS C3;
+------------+------------+---------------------+
| C1         | C2         | C3                  |
+------------+------------+---------------------+
| 2022-03-19 | 2022-03-19 | 2022-04-18 23:59:59 |
+------------+------------+---------------------+
1 row in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由执行结果可以看出，&lt;code&gt;DATE_SUB(date,INTERVAL expr type)&lt;/code&gt; 和&lt;code&gt;SUBDATE (date,INTERVAL expr type)&lt;/code&gt; 函数的功能完全相同。
注意：&lt;code&gt;DATE_ADD(date,INTERVAL expr type)&lt;/code&gt; 和 &lt;code&gt;DATE_SUB(date,INTERVAL expr type)&lt;/code&gt; 函数在指定加减的时间段时也可以指定负值，加法的负值即返回原始时间之前的日期和时间，减法的负值即返回原始时间之后的日期和时间。&lt;/p&gt;
&lt;h3 id=&#34;addtime&#34;&gt;ADDTIME函数：时间加法运算&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;ADDTIME(time,expr)&lt;/code&gt; 函数用于执行时间的加法运算。添加 expr 到 time 并返回结果。&lt;/p&gt;
&lt;p&gt;其中：time 是一个时间或日期时间表达式，expr 是一个时间表达式。&lt;/p&gt;
&lt;p&gt;如：使用 &lt;code&gt;ADDTIME()&lt;/code&gt; 函数进行时间的加法运算，输入 SQL 语句和返回结果如下。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;mysql&amp;gt; SELECT ADDTIME(&#39;2022-04-19 23:59:59&#39;,&#39;0:1:1&#39;),
    -&amp;gt; ADDTIME(&#39;10:30:59&#39;,&#39;5:10:37&#39;);
+----------------------------------------+-------------------------------+
| ADDTIME(&#39;2022-04-19 23:59:59&#39;,&#39;0:1:1&#39;) | ADDTIME(&#39;10:30:59&#39;,&#39;5:10:37&#39;) |
+----------------------------------------+-------------------------------+
| 2022-04-20 00:01:00                    | 15:41:36                      |
+----------------------------------------+-------------------------------+
1 row in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由执行结果可以看出，在原始日期时间 &lt;code&gt;2022-04-19 23:59:59&lt;/code&gt; 上加 0 小时 1 分 1 秒之后返回的日期时间是 &lt;code&gt;2022-04-20 00:01:00&lt;/code&gt;；在原始时间 &lt;code&gt;10:30:59&lt;/code&gt; 上加 5 小时 10 分 37 秒之后返回的日期时间是 &lt;code&gt;15:41:36&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;subtime&#34;&gt;SUBTIME函数：时间减法运算&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;SUBTIME(time,expr)&lt;/code&gt; 函数用于执行时间的减法运算。&lt;/p&gt;
&lt;p&gt;其中：函数返回 time。expr 表示的值和格式 time 相同。time 是一个时间或日期时间表达式， expr 是一个时间。&lt;/p&gt;
&lt;p&gt;如：使用 &lt;code&gt;SUBTIME(time,expr)&lt;/code&gt; 函数进行时间的减法运算，输入 SQL 语句和执行结果如下。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;mysql&amp;gt; SELECT SUBTIME(&#39;2022-04-19 23:59:59&#39;,&#39;0:1:1&#39;),SUBTIME(&#39;10:30:59&#39;,&#39;5:12:37&#39;);
+----------------------------------------+-------------------------------+
| SUBTIME(&#39;2022-04-19 23:59:59&#39;,&#39;0:1:1&#39;) | SUBTIME(&#39;10:30:59&#39;,&#39;5:12:37&#39;) |
+----------------------------------------+-------------------------------+
| 2022-04-19 23:58:58                    | 05:18:22                      |
+----------------------------------------+-------------------------------+
1 row in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由执行结果可以看出，在原始日期时间 &lt;code&gt;2022-04-19 23:59:59&lt;/code&gt; 上减去 0 小时 1 分 1 秒之后返回的日期时间是 &lt;code&gt;2022-04-19 23:58:58&lt;/code&gt;；在原始时间 &lt;code&gt;10:30:59&lt;/code&gt; 上减去 5 小时 12 分 37 秒之后返回的日期时间是 &lt;code&gt;05:18:22&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;datediff&#34;&gt;DATEDIFF函数：获取两个日期的时间间隔&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;DATEDIFF(date1，date2)&lt;/code&gt; 返回起始时间 date1 和结束时间 date2 之间的天数。date1 和 date2 为日期或 &lt;code&gt;date-and-time&lt;/code&gt; 表达式。计算时只用到这些值的日期部分。&lt;/p&gt;
&lt;p&gt;如：使用 &lt;code&gt;DATEDIFF()&lt;/code&gt; 函数计算两个日期之间的间隔天数，输入的 SQL 语句和执行结果如下所示。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;mysql&amp;gt; SELECT DATEDIFF(&#39;2022-04-19&#39;,&#39;2022-04-18&#39;) AS COL1,
    -&amp;gt; DATEDIFF(&#39;2022-04-19&#39;,&#39;2022-05-04&#39;) AS col2;
+------+------+
| COL1 | col2 |
+------+------+
|    1 |  -15 |
+------+------+
1 row in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由运行结果可知，DATEDIFF() 函数返回 date1-date2 后的值，因此 &lt;code&gt;DATEDIFF(&#39;2022-04-19&#39;,&#39;2022-04-18&#39;)&lt;/code&gt; 的返回值为 1，&lt;code&gt;DATEDIFF(&#39;2022-04-19&#39;,&#39;2022-05-04&#39;)&lt;/code&gt; 的返回值为 -15。&lt;/p&gt;
&lt;h3 id=&#34;date_format&#34;&gt;DATE_FORMAT函数：格式化指定的日期&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;DATE_FORMAT(date，format)&lt;/code&gt; 函数是根据 format 指定的格式显示 date 值。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;DATE_FORMAT()&lt;/code&gt; 函数接受两个参数：
&lt;code&gt;date&lt;/code&gt;：是要格式化的有效日期值
&lt;code&gt;format&lt;/code&gt;：是由预定义的说明符组成的格式字符串，每个说明符前面都有一个百分比字符(%)。&lt;/p&gt;
&lt;p&gt;主要的 format 格式如下表所示。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align: center;&#34;&gt;说明符&lt;/th&gt;
&lt;th style=&#34;text-align: center;&#34;&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;%a&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;工作日的缩写名称（Sun~Sat)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;%b&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;月份的缩写名称（Jan…Dec)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;%c&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;月份，数字形式（0~12)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;%D&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;带有英语后缀的该月日期(0th, 2st, 3nd,…）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;%d&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;该月日期，数字形式（00~31)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;%e&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;该月日期，数字形式（(0~31)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;%f&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;微秒（000000 …999999)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;%H&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;以 2 位数表示 24 小时（00~23)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;%h, %I&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;以 2 位数表示 12 小时（01~12)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;%i&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;分钟，数字形式(00~59)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;%j&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;—年中的天数（001~366)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;%k&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;以 24 小时（0~23)表示&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;%l&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;以12小时（1~12)表示&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;%M&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;月份名称（January~December)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;%m&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;月份，数字形式（00~12)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;%p&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;上午（AM) 或下午（PM)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;%r&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;时间，12小时制（小时 (hh): 分钟 (mm) : 秒数 (ss) 后加 AM 或 PM)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;%S, %s&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;以 2 位数形式表示秒（00~59)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;%T&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;时间，24 小时制（小时 (hh): 分钟 (mm): 秒数 (ss))&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;%U&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;周（00~53)，其中周日为每周的第一天&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;%u&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;周（00~53)，其中周一为每周的第一天&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;%V&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;周（01~53)，其中周日为每周的第一天，和％X同时使用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;%v&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;周（01~53)，其中周一为每周的第一天，和%x同时使用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;%W&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;星期标识（周日、周一、周二…周六）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;%w&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;—周中的每日（0= 周日…6= 周六）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;%X&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;该周的年份，其中周日为每周的第一天，数字形式，4 位数，和％V同时使用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;%x&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;该周的年份，其中周一为每周的第一天，数字形式，4位数，和%v同时使用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;%Y&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;4 位数形式表示年份&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;%y&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;2 位数形式表示年份&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;%%&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;%一个文字字符&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;如：使用 &lt;code&gt;DATE_FORMAT()&lt;/code&gt; 函数格式化输出日期和时间值，输入的 SQL 语句和执行结果如下所示。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;mysql&amp;gt; SELECT DATE_FORMAT(&#39;2022-04-19 14:16:00&#39;,&#39;%W %M %D %Y&#39;) AS col1,
    -&amp;gt; DATE_FORMAT(&#39;2022-04-19 14:16:00&#39;,&#39;%h:%i %p %M %D %Y&#39;) AS col2;
+-------------------------+-------------------------+
| col1                    | col2                    |
+-------------------------+-------------------------+
| Tuesday April 19th 2022 | 02:16 PM April 19th 2022 |
+-------------------------+-------------------------+
1 row in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由运行结果可以看到，&lt;code&gt;2022-04-19 14:16:00&lt;/code&gt; 分别按照不同的参数已转换为不同格式的日期值和时间值。&lt;/p&gt;
&lt;h3 id=&#34;weekday&#34;&gt;WEEKDAY函数：获取指定日期在一周内的索引位置&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;WEEKDAY(d)&lt;/code&gt; 返回 d 对应的工作日索引。0 表示周一，1 表示周二，……，6 表示周日。&lt;/p&gt;
&lt;p&gt;如：使用 &lt;code&gt;WEEKDAY()&lt;/code&gt; 函数返回日期对应的工作日索引，输入的 SQL 语句和执行结果如下所示。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;mysql&amp;gt; SELECT WEEKDAY(&#39;2022-04-19&#39;);
+-----------------------+
| WEEKDAY(&#39;2022-04-19&#39;) |
+-----------------------+
|                     1 |
+-----------------------+
1 row in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由运行结果可以看出，&lt;code&gt;WEEKDAY()&lt;/code&gt; 和 &lt;code&gt;DAYOFWEEK()&lt;/code&gt; 函数都是返回指定日期在某一周内的位置，只是索引编号不同。&lt;/p&gt;
&lt;h3 id=&#34;max&#34;&gt;MAX函数：查询指定列的最大值&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;MAX()&lt;/code&gt; 函数是用来返回指定列中的最大值。&lt;/p&gt;
&lt;p&gt;为了方便理解，首先创建一个学生成绩表 tb_students_score，学生成绩表的数据内容如下所示。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;mysql&amp;gt; use test_db;
Database changed
mysql&amp;gt; SELECT * FROM tb_students_score;
+--------------+---------------+
| student_name | student_score |
+--------------+---------------+
| Dany         |            90 |
| Green        |            99 |
| Henry        |            95 |
| Jane         |            98 |
| Jim          |            88 |
| John         |            94 |
| Lily         |           100 |
| Susan        |            96 |
| Thomas       |            93 |
| Tom          |            89 |
+--------------+---------------+
10 rows in set (0.13 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如：在 tb_students_score 表中查找最高的成绩，输入的 SQL 语句和执行结果如下所示。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;mysql&amp;gt; SELECT MAX(student_score)
    -&amp;gt; AS max_score
    -&amp;gt; FROM tb_students_score;
+-----------+
| max_score |
+-----------+
|       100 |
+-----------+
1 row in set (0.06 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由运行结果可以看到，&lt;code&gt;MAX()&lt;/code&gt; 函数查询出 &lt;code&gt;student_score&lt;/code&gt; 字段的最大值为 100。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;MAX()&lt;/code&gt; 函数不仅适用于查找数值类型，也可应用于字符类型。&lt;/p&gt;
&lt;p&gt;如：在 &lt;code&gt;tb_students_score&lt;/code&gt; 表中查找 &lt;code&gt;student_name&lt;/code&gt; 的最大值，输入的 SQL 语句和执行结果如下所示。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;mysql&amp;gt; SELECT MAX(student_name)
    -&amp;gt; AS max_name
    -&amp;gt; FROM tb_students_score;
+----------+
| max_name |
+----------+
| Tom      |
+----------+
1 row in set (0.03 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由运行结果可以看到，&lt;code&gt;MAX()&lt;/code&gt; 函数可以对字母进行大小判断，并返回最大的字符或者字符串值。
注意：&lt;code&gt;MAX()&lt;/code&gt; 函数还可以返回任意列中的最大值，包括返回字符类型的最大值。在对字符类型的数据进行比较时，按照字符的 ASCII 码值大小进行比较，从 a～z，a 的 ASCII 码最小，z 的最大。在比较时，先比较第一个字符，如果相等，继续比较下一个字符，一直到两个字符不相等或者字符结束为止。例如，b 与 t 比较时，t 为最大值；bcd 与 bca 比较时，bcd 为最大值。&lt;/p&gt;
&lt;h3 id=&#34;min&#34;&gt;MIN函数：查询指定列的最小值&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;MIN()&lt;/code&gt; 函数是用来返回查询列中的最小值。&lt;/p&gt;
&lt;p&gt;为了便于理解，需要用到在上一节讲 MAX() 函数时创建的数据表 &lt;code&gt;tb_students_score&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;如：在 &lt;code&gt;tb_students_score&lt;/code&gt; 表中查找最低的成绩，输入的 SQL 语句和执行结果如下所示。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;mysql&amp;gt; SELECT MIN(student_score)
    -&amp;gt; AS min_score
    -&amp;gt; FROM tb_students_score;
+-----------+
| min_score |
+-----------+
|        88 |
+-----------+
1 row in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由结果可以看到，&lt;code&gt;MIN()&lt;/code&gt; 函数查询出 &lt;code&gt;student_score&lt;/code&gt; 字段的最小值为 88。
提示：&lt;code&gt;MIN()&lt;/code&gt; 函数与 &lt;code&gt;MAX()&lt;/code&gt; 函数类似，不仅适用于查找数值类型，也可应用于字符类型。&lt;/p&gt;
&lt;h3 id=&#34;count&#34;&gt;COUNT函数：统计查询结果的行数&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;COUNT()&lt;/code&gt; 函数统计数据表中包含的记录行的总数，或者根据查询结果返回列中包含的数据行数，使用方法有以下两种：
&lt;code&gt;COUNT(*)&lt;/code&gt; 计算表中总的行数，无论某列有数值或者为空值。
&lt;code&gt;COUNT(字段名)&lt;/code&gt;计算指定列下总的行数，计算时将忽略空值的行。&lt;/p&gt;
&lt;p&gt;这里需要用到以下在介绍 &lt;code&gt;MAX()&lt;/code&gt; 函数时创建的表 &lt;code&gt;tb_students_score&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;如：查询 &lt;code&gt;tb_students_score&lt;/code&gt; 表中总的行数，输入的 SQL 语句和执行结果如下所示。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;mysql&amp;gt; SELECT COUNT(student_name)
    -&amp;gt; AS students_number
    -&amp;gt; FROM tb_students_score;
+-----------------+
| students_number |
+-----------------+
|              10 |
+-----------------+
1 row in set (0.03 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由查询结果可以看到，&lt;code&gt;COUNT(*)&lt;/code&gt; 返回 &lt;code&gt;tb_students_score&lt;/code&gt; 表中记录的总行数，无论值是什么。返回的总数的名称为 &lt;code&gt;students_number&lt;/code&gt;。
提示：在计算总数的时候对待 NULL 值的方式是，指定列的值为空的行被 &lt;code&gt;COUNT()&lt;/code&gt; 函数忽略，但若不指定列，而在 &lt;code&gt;COUNT()&lt;/code&gt; 函数中使用星号“*”，则所有记录都不忽略。&lt;/p&gt;
&lt;h3 id=&#34;sum&#34;&gt;SUM函数：求和&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;SUM()&lt;/code&gt; 是一个求总和的函数，返回指定列值的总和。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SUM()&lt;/code&gt; 函数是如何工作的？
如果在没有返回匹配行 SELECT 语句中使用 SUM 函数，则 SUM 函数返回 NULL，而不是 0。
&lt;code&gt;DISTINCT&lt;/code&gt; 运算符允许计算集合中的不同值。
&lt;code&gt;SUM&lt;/code&gt; 函数忽略计算中的 NULL 值。&lt;/p&gt;
&lt;p&gt;这里需要用到以下在介绍 &lt;code&gt;MAX()&lt;/code&gt; 函数时创建的表 &lt;code&gt;tb_students_score&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;如：在 &lt;code&gt;tb_students_score&lt;/code&gt; 表中计算学生成绩的总分，输入的 SQL 语句和执行结果如下所示。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;mysql&amp;gt; SELECT SUM(student_score)
    -&amp;gt; AS score_sum
    -&amp;gt; FROM tb_students_score;
+-----------+
| score_sum |
+-----------+
|       942 |
+-----------+
1 row in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由查询结果可以看到，&lt;code&gt;SUM()&lt;/code&gt; 函数返回学生的所有成绩之和为 942。
提示：&lt;code&gt;SUM()&lt;/code&gt; 函数在计算时，忽略列值为 NULL 的行。&lt;/p&gt;
&lt;h3 id=&#34;avg&#34;&gt;AVG函数：求平均值&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;AVG()&lt;/code&gt; 函数通过计算返回的行数和每一行数据的和，求得指定列数据的平均值。&lt;/p&gt;
&lt;p&gt;这里需要用到以下在介绍 &lt;code&gt;MAX()&lt;/code&gt; 函数时创建的表 &lt;code&gt;tb_students_score&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;如：在 &lt;code&gt;tb_students_score&lt;/code&gt; 表中，查询所有学生成绩的平均值，输入的 SQL 语句和执行结果如下所示。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;mysql&amp;gt; SELECT AVG(student_score)
    -&amp;gt; AS score_avg
    -&amp;gt; FROM tb_students_score;
+-----------+
| score_avg |
+-----------+
|   94.2000 |
+-----------+
1 row in set (0.03 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;提示：使用 &lt;code&gt;AVG()&lt;/code&gt; 函数时，参数为要计算的列名称，若要得到多个列的平均值，则需要在每一列都使用 AVG() 函数。&lt;/p&gt;
&lt;h3 id=&#34;if&#34;&gt;IF函数：判断&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;IF&lt;/code&gt; 语句允许您根据表达式的某个条件或值结果来执行一组 SQL 语句。&lt;/p&gt;
&lt;p&gt;要形成一个表达式，可以结合文字，变量，运算符，甚至函数来组合。表达式可以返回 TRUE,FALSE 或 NULL，这三个值之一。&lt;/p&gt;
&lt;p&gt;语法结构如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;IF(expr,v1,v2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中：表达式 expr 得到不同的结果，当 expr 为真是返回 v1 的值，否则返回 v2.&lt;/p&gt;
&lt;p&gt;如：使用 &lt;code&gt;IF(expr,v1,v2)&lt;/code&gt; 函数根据 expr 表达式结果返回相应值，输入 SQL 语句和执行结果如下。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;mysql&amp;gt; SELECT IF(1&amp;lt;2,1,0) c1,IF(1&amp;gt;5,&#39;√&#39;,&#39;×&#39;) c2,IF(STRCMP(&#39;abc&#39;,&#39;ab&#39;),&#39;yes&#39;,&#39;no&#39;) c3;
+----+----+-----+
| c1 | c2 | c3  |
+----+----+-----+
|  1 |  × | yes |
+----+----+-----+
1 row in set (0.06 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由执行结果可以看出，在 c1 中，表达式 1&amp;lt;2 所得的结果是 TRUE，则返回结果为 v1，即数值 1；在 c2 中，表达式 1&amp;gt;5 所得的结果是 FALSE，则返回结果为 v2，即字符串 &#39;×&#39;；在 c3 中，先用 STRCMP(s1,s2) 函数比较两个字符串的大小，字符串 &#39;abc&#39; 和 &#39;ab&#39; 比较结果的返回值为 1，也就是表达式 expr 的返回结果不等于 0 且不等于 NULL，则返回值为 v1，即字符串 &#39;yes&#39;。&lt;/p&gt;
&lt;h3 id=&#34;ifnull&#34;&gt;IFNULL函数：判断是否为空&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;IFNULL&lt;/code&gt; 函数是 MySQL 控制流函数之一，它接受两个参数，如果不是 NULL，则返回第一个参数。 否则，IFNULL 函数返回第二个参数。两个参数可以是文字值或表达式。&lt;/p&gt;
&lt;p&gt;函数的语法：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;IFNULL(v1,v2);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中：如果 v1 不为 NULL，则 IFNULL 函数返回 v1; 否则返回 v2 的结果。&lt;/p&gt;
&lt;p&gt;如：使用 &lt;code&gt;IFNULL(v1,v2)&lt;/code&gt; 函数根据 v1 的取值返回相应值。输入 SQL 语句和执行结果如下。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;mysql&amp;gt; SELECT IFNULL(5,8),IFNULL(NULL,&#39;OK&#39;),IFNULL(SQRT(-8),&#39;FALSE&#39;),SQRT(-8);
+-------------+-------------------+--------------------------+----------+
| IFNULL(5,8) | IFNULL(NULL,&#39;OK&#39;) | IFNULL(SQRT(-8),&#39;FALSE&#39;) | SQRT(-8) |
+-------------+-------------------+--------------------------+----------+
|           5 | OK                | FALSE                    |     NULL |
+-------------+-------------------+--------------------------+----------+
1 row in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由执行结果可以看出，&lt;code&gt;IFNULL(v1,v2)&lt;/code&gt; 函数中的参数 v1=5、v2=8，都不为空，即 v1=5 不为空，返回 v1 的值为 5；当 v1=NULL 时，返回 v2 的值，即字符串 &#39;OK&#39;；当 v1=SQRT(-8) 时，SQRT(-8) 函数的返回值为NULL，即 v1=NULL，所以返回 v2 为字符串 &#39;false&#39;。&lt;/p&gt;
&lt;h3 id=&#34;case&#34;&gt;CASE函数：搜索语句&lt;/h3&gt;
&lt;p&gt;条件语句 CASE。&lt;/p&gt;
&lt;p&gt;CASE 语句有两种形式：简单的和可搜索 CASE 语句。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;简单的 CASE 语句
  简单的 CASE 语句就是指使用简单 CASE 语句来检查表达式的值与一组唯一值的匹配。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;简单的 CASE 语句的语法：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;CASE  &amp;lt;表达式&amp;gt;
   WHEN &amp;lt;值1&amp;gt; THEN &amp;lt;操作&amp;gt;
   WHEN &amp;lt;值2&amp;gt; THEN &amp;lt;操作&amp;gt;
   ...
   ELSE &amp;lt;操作&amp;gt;
END CASE;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中：&amp;lt;表达式&amp;gt; 可以是任何有效的表达式。我们将 &amp;lt;表达式&amp;gt; 的值与每个 WHEN 子句中的值进行比较，例如 &amp;lt;值1&amp;gt;，&amp;lt;值2&amp;gt; 等。如果 &amp;lt;表达式&amp;gt; 和 &amp;lt;值n&amp;gt; 的值相等，则执行相应的 WHEN 分支中的命令 &amp;lt;操作&amp;gt;。如果 WHEN 子句中的 &amp;lt;值n&amp;gt; 没有与 &amp;lt;表达式&amp;gt; 的值匹配，则 ELSE 子句中的命令将被执行。ELSE 子句是可选的。 如果省略 ELSE 子句，并且找不到匹配项，MySQL 将引发错误。
如：使用 CASE 函数根据表达式的取值返回相应值，输入SQL 语句和执行结果如下&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;mysql&amp;gt; SELECT CASE WEEKDAY(NOW()) WHEN 0 THEN &#39;星期一&#39; WHEN 1 THEN &#39;星期二&#39; WHEN 2 THEN
 &#39;星期三&#39; WHEN 3 THEN &#39;星期四&#39; WHEN 4 THEN &#39;星期五&#39; WHEN 5 THEN &#39;星期六&#39;ELSE &#39;星期天&#39; END
 AS COLUMN1,NOW(),WEEKDAY(NOW()),DAYNAME(NOW());
+---------+---------------------+----------------+----------------+
| COLUMN1 | NOW()               | WEEKDAY(NOW()) | DAYNAME(NOW()) |
+---------+---------------------+----------------+----------------+
|  星期二  | 2022-04-19 14:27:33 |              1 | Tuesday        |
+---------+---------------------+----------------+----------------+
1 row in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由执行结果可以看出，&lt;code&gt;NOW()&lt;/code&gt; 函数得到当前系统时间是 2022年 4 月 19 日，DAYNAME(NOW()) 得到当天是 &lt;code&gt;Tuesday&lt;/code&gt;，&lt;code&gt;WEEKDAY(NOW())&lt;/code&gt; 函数返回当前时间的工作日索引是 1，即对应的是星期二。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可搜索的 CASE 语句
  简单 CASE 语句仅允许将表达式的值与一组不同的值进行匹配。 为了执行更复杂的匹配，如范围，则可以使用可搜索 CASE 语句。 可搜索 CASE 语句等同于 IF 语句，但是它的构造更加可读。
  可搜索CASE语句的语法：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;CASE
    WHEN &amp;lt;条件1&amp;gt; THEN &amp;lt;命令&amp;gt;
    WHEN &amp;lt;条件2&amp;gt; THEN &amp;lt;命令&amp;gt;
    ...
    ELSE commands
END CASE;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;MySQL 分别计算 WHEN 子句中的每个条件，直到找到一个值为 TRUE 的条件，然后执行 THEN 子句中的相应 &amp;lt;命令&amp;gt;。如果没有一个条件为 TRUE，则执行 ELSE 子句中的 &amp;lt;命令&amp;gt;。如果不指定 ELSE 子句，并且没有一个条件为 TRUE，MySQL 将发出错误消息。MySQL 不允许在 THEN 或 ELSE 子句中使用空的命令。 如果您不想处理 ELSE 子句中的逻辑，同时又要防止 MySQL 引发错误，则可以在 ELSE 子句中放置一个空的 BEGIN END 块。&lt;/p&gt;
&lt;p&gt;如：使用 CASE 函数根据表达式的取值返回相应值，输入SQL 语句和执行结果如下&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;mysql&amp;gt; SELECT CASE WHEN WEEKDAY(NOW())=0 THEN &#39;星期一&#39; WHEN WEEKDAY(NOW())=1 THEN &#39;星期二&#39;
 WHEN WEEKDAY(NOW())=2 THEN &#39;星期三&#39; WHEN WEEKDAY(NOW())=3 THEN &#39;星期四&#39; WHEN WEEKDAY(NOW())=4
 THEN &#39;星期五&#39; WHEN WEEKDAY(NOW())=5 THEN &#39;星期六&#39; WHEN WEEKDAY(NOW())=6 THEN &#39;星期天&#39; END
 AS COLUMN1,NOW(),WEEKDAY(NOW()),DAYNAME(NOW());
+---------+---------------------+----------------+----------------+
| COLUMN1 | NOW()               | WEEKDAY(NOW()) | DAYNAME(NOW()) |
+---------+---------------------+----------------+----------------+
| 星期二  | 2022-04-19 14:30:03 |              1 | Tuesday        |
+---------+---------------------+----------------+----------------+
1 row in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此例跟上例的返回结果一样，只是使用了 CASE 函数的不同写法，WHEN 后面为表达式，当表达式的返回结果为 TRUE 时取 THEN 后面的值，如果都不是，则返回 ELSE 后面的值。&lt;/p&gt;</description>  
      <pubDate>2025-10-09 17:54:40</pubDate>  
      <link>https://testpoo.github.io/mysql函数汇总.html</link>  
      <guid isPermaLink="true">https://testpoo.github.io/mysql函数汇总.html</guid>
       
      <category>技术</category> 
      
    </item>
    
    <item> 
      <title>shell简介</title>  
      <description>&lt;div class=&#34;toc&#34;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#_1&#34;&gt;本文摘要&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#shell&#34;&gt;Shell编程概述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#shell_1&#34;&gt;Shell 注释&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#shell_2&#34;&gt;Shell关键字&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#shell_3&#34;&gt;Shell变量&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1&#34;&gt;1. 用户自定义变量&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2&#34;&gt;2. 预定义变量&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3&#34;&gt;3. 环境变量&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4&#34;&gt;4.字符串变量&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5&#34;&gt;5. 数组&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#shell_4&#34;&gt;Shell运算&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1_1&#34;&gt;1. 算数运算&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2_1&#34;&gt;2. 数字关系运算符&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3_1&#34;&gt;3. 字符串运算符&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4_1&#34;&gt;4. 布尔运算符&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5_1&#34;&gt;5. 逻辑运算符&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#6&#34;&gt;6. 文件运算符&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#shell_5&#34;&gt;Shell语句&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-if&#34;&gt;1. if语句&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-case&#34;&gt;2. case语句&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3-for&#34;&gt;3. for循环&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4-while&#34;&gt;4. while 循环&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5until&#34;&gt;5.until 循环&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#6-break&#34;&gt;6. break&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#7-continue&#34;&gt;7. continue&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#shell_6&#34;&gt;Shell 函数&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1_2&#34;&gt;1. 定义函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2_2&#34;&gt;2. 调用函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3_2&#34;&gt;3. 获取返回值&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4_2&#34;&gt;4. 定义本地变量&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_2&#34;&gt;调试&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#shell_7&#34;&gt;Shell 易错点&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h3 id=&#34;_1&#34;&gt;本文摘要&lt;/h3&gt;
&lt;p&gt;本文主要介绍Linux Shell编程的基础知识，包含下面8个方面：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Shell编程概述&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Shell关键字&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Shell变量&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Shell运算&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Shell语句&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Shell函数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Shell调试&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Shell易错点&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;shell&#34;&gt;Shell编程概述&lt;/h3&gt;
&lt;p&gt;在Linux下有一门脚本语言叫做：Shell脚本。Shell 是外壳的意思，就是操作系统的外壳。我们可以通过 Shell 命令来操作和控制系统，比如 Linux 中的 Shell 命令就包括 ls、cd、pwd等等，Shell 是一个命令解释器，它通过接受用户输入的 Shell 命令来启动、暂停、停止的运行或对计算机进行控制。&lt;/p&gt;
&lt;p&gt;Shell 是一个应用程序，它连接了用户和 Linux 内核，让用户能够更加高效、安全、低成本地使用 Linux 内核，这就是 Shell 的本质。&lt;/p&gt;
&lt;p&gt;Shell 本身并不是内核的一部分，它中是站在内核的基础上编写的一个应用程序。&lt;/p&gt;
&lt;p&gt;那什么是 Shell 脚本。Shell 脚本就是由 Shell 命令组成的执行文件，将一些命令整合到一个文件中，进行处理业务逻辑，脚本不用编译即可运行。它通过解释器运行，所以速度相对来主说比较慢。&lt;/p&gt;
&lt;p&gt;一个简单的hello.sh脚本像下面这样，第一行#！/bin/bash标识该脚本由哪个Shell解释：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-shell&#34;&gt;#!/bin/bash

echo &amp;quot;Hello World!&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;赋予权限才可以执行&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-shell&#34;&gt;# 赋予可执行权限
chmod +x hello.sh

# 执行
./hello.sh

# 结果
Hello World!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Shell的编写流程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;编写Shell脚本&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;赋予可执行权限&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;执行，调试&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面来介绍具体的用法。&lt;/p&gt;
&lt;h3 id=&#34;shell_1&#34;&gt;Shell 注释&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;单行注释：#&lt;/li&gt;
&lt;li&gt;多行注释：:,&amp;lt;&amp;lt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;看个例子&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-shell&#34;&gt;# 这个是单行注释
&lt;/code&gt;&lt;/pre&gt;

&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-shell&#34;&gt;&amp;lt;&amp;lt;COMMENT
    这个是多行注释
    这个是多行注释
    这个是多行注释
COMMENT

: &#39;
这个也是多行注释(: + 空格 + 单引号)
这个也是多行注释(: + 空格 + 单引号)
这个也是多行注释(: + 空格 + 单引号)
&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;shell_2&#34;&gt;Shell关键字&lt;/h3&gt;
&lt;p&gt;常用的关键字如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;echo: 打印文字到屏幕&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;exec: 执行另一个Shell脚本&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;read: 读标准输入&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;expr: 对整数型变量进行算术运算&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;test: 用于测试变量是否相等、是否为空、文件类型等&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;exit: 退出&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;看个例子：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-shell&#34;&gt;#!/bin/bash

echo &amp;quot;hello Shell&amp;quot;

# 读入变量
read VAR
echo &amp;quot;VAE is $VAR&amp;quot;

# 计算变量
expr $VAR -5

# 测试字符串
test &amp;quot;Hello&amp;quot;=&amp;quot;Helloword&amp;quot;

# 测试整数
test -d ./Android

# 执行其他Shell脚本
exec ./othershell.sh

# 退出
exit
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行前，你需要新建一个&lt;code&gt;othershell.sh&lt;/code&gt;的文件，让它输出&lt;code&gt;I&#39;m othershell&lt;/code&gt;，并且中途需要一次输入，我这里输入的是10：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-shell&#34;&gt;Hello Shell
10
VAR is 10
5
I&#39;m othershell
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;学习任何一门语言都要了解它的变量定义方法，Shell也不例外。&lt;/p&gt;
&lt;h3 id=&#34;shell_3&#34;&gt;Shell变量&lt;/h3&gt;
&lt;p&gt;Shell变量分为3种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;用户自定义变量&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;预定义变量&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;环境变量&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;定义变量需要注意下面2点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;等号前后不要有空格：NUM=10&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一般变量名用大写：M=1&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;使用$VAR调用变量：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-shell&#34;&gt;echo $VAR
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;1&#34;&gt;1. 用户自定义变量&lt;/h4&gt;
&lt;p&gt;这种变量只支持字符串类型，不支持其他字符，浮点等类型，常见有这3个前缀：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;unset: 删除变量&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;readonly: 标记只读变量&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;export: 指定全局变量&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;一个例子：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-shell&#34;&gt;#!/bin/bash

# 定义旁通变量
CITY=SHENZHEN

# 定义全局变量
export NAME=cdeveloper

# 定义只读变量
readonly AGE=21

# 打印变量的值
echo $CITY
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运维结果：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;SHENZHEN
cdeveloper
21
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;2&#34;&gt;2. 预定义变量&lt;/h4&gt;
&lt;p&gt;预定义变量常用来获取命令行的输入，有下面这些：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;$0: 脚本文件名&lt;/li&gt;
&lt;li&gt;$1-9: 第1-9命令行参数名&lt;/li&gt;
&lt;li&gt;$#: 命令行参数个数&lt;/li&gt;
&lt;li&gt;$@: 所有命令行参数&lt;/li&gt;
&lt;li&gt;$*: 所有命令行参数&lt;/li&gt;
&lt;li&gt;$?: 前一个命令的退出状态，可用于获取函数返回值&lt;/li&gt;
&lt;li&gt;\$$: 执行的进程ID&lt;/li&gt;
&lt;li&gt;$!: 后台运行的最后一个进程的ID&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;一个例子：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;#!/bin/bash

echo &amp;quot;print $&amp;quot;
echo &amp;quot;\$0 = $0&amp;quot;
echo &amp;quot;\$1 = $1&amp;quot;
echo &amp;quot;\$2 = $2&amp;quot;
echo &amp;quot;\$# = $#&amp;quot;
echo &amp;quot;\$@ = $@&amp;quot;
echo &amp;quot;\$* = $*&amp;quot;
echo &amp;quot;\$$ = $$&amp;quot;
echo &amp;quot;\$? = $?&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行&lt;code&gt;./hello.sh 1 2 3 4 5&lt;/code&gt;的结果：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;print $

# 程序名
$0 = ./hello.sh

# 第一个参数
$1 = 1

# 第二个参数
$2 = 2

# 一共有5个参数
$# = 5

# 打印出所有参数
$@ = 1 2 3 4 5

# 打印出所有参数
$* = 1 2 3 4 5

# 进程ID
$$ = 854

# 之前没有执行其他命令或者函数
$? = 0
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;3&#34;&gt;3. 环境变量&lt;/h4&gt;
&lt;p&gt;环境变量默认存在，常用的有下面这几个：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;HOME：用户主目录&lt;/li&gt;
&lt;li&gt;PATH：系统环境变量PATH&lt;/li&gt;
&lt;li&gt;TERM：当前终端&lt;/li&gt;
&lt;li&gt;UID: 当前用户ID&lt;/li&gt;
&lt;li&gt;PWD：当前工作目录，绝对路径&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;还是看例子：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;#!/bin/bash

echo &amp;quot;print env&amp;quot;

echo $HOME
echo $PATH
echo $TERM
echo $PWD
echo $UID
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;print env

# 当前主目录
/home/poo

# PATH环境变量
/usr/local/bin:/usr/bin:/bin:/usr/local/games:/usr/games

# 当前终端
xterm

# 当前目录
/home/poo/poo

# 用户ID
1000
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;4&#34;&gt;4.字符串变量&lt;/h4&gt;
&lt;p&gt;1）单引号&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单引号变量var=&#39;test&#39;，只能原样输出，变量无效&lt;/li&gt;
&lt;li&gt;单引号不能出现一个单独的单引号，转义也不可以&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2）双引号&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;双引号变量&lt;code&gt;var=&#34;my name is ${name}&#34;&lt;/code&gt;，变量有效&lt;/li&gt;
&lt;li&gt;可以出现转义符&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;3）拼接字符串&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;中间无任何+,之类的字符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;name=&#34;this is&#34;&#34; my name&#34;;name=&#34;this is my name&#34;;name=&#34;this&#34; is &#34;my name&#34;等效&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;name=&#39;this is&#39;&#39; my name&#39;; name=&#39;this is my name&#39;; name=&#39;this&#39; is &#39;my name&#39; 等效&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;4）获取字符串长度&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在${}中使用“#”获取长度&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;name=&#34;test&#34;;
  echo ${#name}; # 输出为4&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;5）提取子字符串&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1:4 从第2个开始 往后截取4个字符&lt;/li&gt;
&lt;li&gt;::4 从第一个字符开始 往后截取4个字符&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;name=&#34;this is my name&#34;;
  echo ${name:1:4} #输出 is i
  echo ${name::4} #输出 this&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;5&#34;&gt;5. 数组&lt;/h4&gt;
&lt;p&gt;bash只支持一维数组，不支持多维数组&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;定义数组：array_name=(li wang xiang zhang) （小括号做边界、使用空格分离）&lt;/li&gt;
&lt;li&gt;单独定义数组的元素： array_para[0]=&#34;w&#34;; array_para[3]=&#34;s&#34; （定义时下标不连续也可以）&lt;/li&gt;
&lt;li&gt;赋值数组元素：array_name[0]=&#34;zhao&#34;;&lt;/li&gt;
&lt;li&gt;获取数组元素：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;  array_name[0]=&amp;quot;li&amp;quot;
  array_name[3]=&amp;quot;zhang&amp;quot;
  echo ${array_name[0]} # 输出&amp;quot;li&amp;quot;
  echo ${array_name[1]} # 输出&amp;quot; &amp;quot;
  echo ${array_name[3]} # 输出&amp;quot;zhang&amp;quot;
  echo ${array_name[@]} # 输出&amp;quot;li zhang&amp;quot; 输出数组所有元素，没有元素的下标省略
  取得元素个数：${#array_name[@]} 或者 ${#array_name}
  取得单个元素长度：${#array_name[1]}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Shell变量就介绍到这里，下面来介绍Shell的变量运算。&lt;/p&gt;
&lt;h3 id=&#34;shell_4&#34;&gt;Shell运算&lt;/h3&gt;
&lt;h4 id=&#34;1_1&#34;&gt;1. 算数运算&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;+ 、-、*、\ ： 乘号前必须加\进行转义才可以进行乘法运算&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们经常需要在Shell脚本中计算，掌握基本的运算方法很有必要，下面就是4种比较常见的运算方法，功能都是将m + 1:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;m=$[m+1]&lt;/li&gt;
&lt;li&gt;m=`expr $m + 1` # 用``字符包起来&lt;/li&gt;
&lt;li&gt;let m=m+1&lt;/li&gt;
&lt;li&gt;m=$(( m + 1 ))&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;来看一个实际的例子：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;#!/bin/bash

m=1
m=$[ m + 1 ]
echo $m

m=`expr $m + 1`
echo $m

# 注意：+ 号左右不要加空格
let m=m+1
echo $m

m=$(( m + 1 ))
echo $m
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;2
3
4
5
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;2_1&#34;&gt;2. 数字关系运算符&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;关系运算符只支持数字，不支持字符串，除非字符串的值是数字。下面假定变量 a 为 10，变量 b 为 20&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;-eq ：检测两个数是否相等，相等返回 true。 [ $a -eq $b ] 返回 false。&lt;/li&gt;
&lt;li&gt;-ne： 检测两个数是否不相等，不相等返回 true。 [ $a -ne $b ] 返回 true。&lt;/li&gt;
&lt;li&gt;-gt： 检测左边的数是否大于右边的，如果是，则返回 true。 [ $a -gt $b ] 返回 false。&lt;/li&gt;
&lt;li&gt;-lt ： 检测左边的数是否小于右边的，如果是，则返回 true。 [ $a -lt $b ] 返回 true。&lt;/li&gt;
&lt;li&gt;-ge： 检测左边的数是否大于等于右边的，如果是，则返回 true。 [ $a -ge $b ] 返回 false。&lt;/li&gt;
&lt;li&gt;-le ： 检测左边的数是否小于等于右边的，如果是，则返回 true。 [ $a -le $b ] 返回 true。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;3_1&#34;&gt;3. 字符串运算符&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;下表列出了常用的字符串运算符，假定变量 a 为 &#34;abc&#34;，变量 b 为 &#34;efg&#34;：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;= ：检测两个字符串是否相等，相等返回 true。 [ $a = $b ] 返回 false。&lt;/li&gt;
&lt;li&gt;!= ：检测两个字符串是否相等，不相等返回 true。 [ $a != $b ] 返回 true。&lt;/li&gt;
&lt;li&gt;-z ：检测字符串长度是否为0，为0返回 true。 [ -z $a ] 返回 false。&lt;/li&gt;
&lt;li&gt;-n ：检测字符串长度是否为0，不为0返回 true。 [ -n &#34;$a&#34; ] 返回 true。&lt;/li&gt;
&lt;li&gt;$ ：检测字符串是否为空，不为空返回 true。 [ $a ] 返回 true。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;4_1&#34;&gt;4. 布尔运算符&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;下表列出了常用的布尔运算符，假定变量 a 为 10，变量 b 为 20：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;! ：非运算，表达式为 true 则返回 false，否则返回 true。 [ ! false ] 返回 true。&lt;/li&gt;
&lt;li&gt;-o ：或运算，有一个表达式为 true 则返回 true。 [ $a -lt 20 -o $b -gt 100 ] 返回 true。&lt;/li&gt;
&lt;li&gt;-a ：与运算，两个表达式都为 true 才返回 true。 [ $a -lt 20 -a $b -gt 100 ] 返回 false。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;5_1&#34;&gt;5. 逻辑运算符&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;以下介绍 Shell 的逻辑运算符，假定变量 a 为 10，变量 b 为 20:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&amp;amp;&amp;amp; ：逻辑的 AND [[ $a -lt 100 &amp;amp;&amp;amp; $b -gt 100 ]] 返回 false&lt;/li&gt;
&lt;li&gt;|| ：逻辑的 OR [[ $a -lt 100 || $b -gt 100 ]] 返回 true&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;6&#34;&gt;6. 文件运算符&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;-b file ：检测文件是否是块设备文件，如果是，则返回 true。 [ -b $file ] 返回 false。&lt;/li&gt;
&lt;li&gt;-c file ：检测文件是否是字符设备文件，如果是，则返回 true。 [ -c $file ] 返回 false。&lt;/li&gt;
&lt;li&gt;-d file ：检测文件是否是目录，如果是，则返回 true。 [ -d $file ] 返回 false。&lt;/li&gt;
&lt;li&gt;-f file ：检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。 [ -f $file ] 返回 true。&lt;/li&gt;
&lt;li&gt;-g file ：检测文件是否设置了 SGID 位，如果是，则返回 true。 [ -g $file ] 返回 false。&lt;/li&gt;
&lt;li&gt;-k file ：检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。 [ -k $file ] 返回 false。&lt;/li&gt;
&lt;li&gt;-p file ：检测文件是否是有名管道，如果是，则返回 true。 [ -p $file ] 返回 false。&lt;/li&gt;
&lt;li&gt;-u file ：检测文件是否设置了 SUID 位，如果是，则返回 true。 [ -u $file ] 返回 false。&lt;/li&gt;
&lt;li&gt;-r file ：检测文件是否可读，如果是，则返回 true。 [ -r $file ] 返回 true。&lt;/li&gt;
&lt;li&gt;-w file ：检测文件是否可写，如果是，则返回 true。 [ -w $file ] 返回 true。&lt;/li&gt;
&lt;li&gt;-x file ：检测文件是否可执行，如果是，则返回 true。 [ -x $file ] 返回 true。&lt;/li&gt;
&lt;li&gt;-s file ：检测文件是否为空（文件大小是否大于0），不为空返回 true。 [ -s $file ] 返回 true。&lt;/li&gt;
&lt;li&gt;-e file ：检测文件（包括目录）是否存在，如果是，则返回 true。 [ -e $file ] 返回 true。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;了解了基本的运算方法，下面进一步来学习shell的语句。&lt;/p&gt;
&lt;h3 id=&#34;shell_5&#34;&gt;Shell语句&lt;/h3&gt;
&lt;p&gt;Shell语句跟高级语言有些类似，也包括分支、跳转、循环，下面就带大家一个一个突破。&lt;/p&gt;
&lt;h4 id=&#34;1-if&#34;&gt;1. if语句&lt;/h4&gt;
&lt;p&gt;这个跟高级语言的&lt;code&gt;if - else - if&lt;/code&gt;类似，只是格式有些不同而已，也来看个例子吧：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;#!/bin/bash

read VAR

# 下面这两种判断方法都可以，使用 [] 注意左右加空格
# if test $VAR -eq 10
if [ $VART -eq 10 ]
then 
    echo &amp;quot;true&amp;quot;
else
    echo &amp;quot;false&amp;quot;
fi
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;2-case&#34;&gt;2. case语句&lt;/h4&gt;
&lt;p&gt;case语句有些复杂，要注意格式：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;#!/bin/bash

read NAME
# 格式有点复杂，一定要注意
case $NAME in
    &amp;quot;Linux&amp;quot;)
        echo &amp;quot;Linux&amp;quot;
        ;;
    &amp;quot;cdeveloper&amp;quot;)
        echo &amp;quot;cdeveloper&amp;quot;
        ;;
    *)
        echo &amp;quot;other&amp;quot;
        ;;
esac
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;# 输入 Linux
Linux
Linux

# 输入 cdeveloper
cdeveloper
cdeveloper

# 输入其他的字段
hello
other
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;3-for&#34;&gt;3. for循环&lt;/h4&gt;
&lt;p&gt;这是一个for循环的使用例子，挺简单的，有点类似Python：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;#!/bin/bash

# 普通 for 循环
for ((i = 1; i &amp;lt;= 3; i++))
do
    echo $i
done

# VAR 依次代表每个元素
for VAR in 1 2 3
do
    echo $VAR
done
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;1
2
3
1
2
3
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;4-while&#34;&gt;4. while 循环&lt;/h4&gt;
&lt;p&gt;注意与 for 循环的区别：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;#!/bin/bash

VAR=1

# 如果 VAR 小于 10，就打印出来
while [ $VAR -lt 10 ]
do
    echo $VAR
    # VAR  自增 1
    VAR=$[ $VAR + 1 ]
done
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;1
2
3
4
5
6
7
8
9
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;5until&#34;&gt;5.until 循环&lt;/h4&gt;
&lt;p&gt;until 语句与上面的循环的不同点是它的结束条件为1：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;#!/bin/bash

i=0

# i 大于 5 时，循环结束
until [[ &amp;quot;$i&amp;quot; -gt 5 ]]
do
    echo $i
    i=$[ $i + 1 ]
done
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;0
1
2
3
4
5
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;6-break&#34;&gt;6. break&lt;/h4&gt;
&lt;p&gt;Shell 中的 &lt;code&gt;break&lt;/code&gt; 用法与高级语言相同，都是跳出循环，来看个例子：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;#!/bin/bash

for VAR in 1 2 3
do
# 如何 VAR 等于 2 就跳出循环
    if [ $VAR -eq 2 ]
    then
        break
    fi

    echo $VAR
done
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;1
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;7-continue&#34;&gt;7. continue&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;continue&lt;/code&gt;用来跳过本次循环，进入下一次循环，再来看看上面的例子：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;#!/bin/bash

for VAR in 1 2 3
do
# 如果 VAR 等于 2，就跳过，直接进入下一次 VAR = 3 的循环
    if [ $VAR -eq 2 ]
    then
        continue
    fi

    echo $VAR
done
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;1
3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面介绍 Shell 编程中比较重要的函数，好像每种编程语言的函数都很重要。&lt;/p&gt;
&lt;h3 id=&#34;shell_6&#34;&gt;Shell 函数&lt;/h3&gt;
&lt;p&gt;函数可以用一句话解释：带有输入输出的具有一定功能的黑盒子，相信有过编程经验的同学不会陌生。那么，我们先来看看 Shell 中函数定义的格式。&lt;/p&gt;
&lt;h4 id=&#34;1_2&#34;&gt;1. 定义函数&lt;/h4&gt;
&lt;p&gt;有 2 种常见格式：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;function fun_name()
{

}

fun_name()
{

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例如：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;#!/bin/bash

function hello_world()
{
    echo &amp;quot;hello world fun&amp;quot;
    echo $1 $2
    return 1
}

hello()
{
    echo &amp;quot;hello fun&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;2_2&#34;&gt;2. 调用函数&lt;/h4&gt;
&lt;p&gt;如何调用上面的 2 个函数&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;# 1. 直接用函数名调用 hello 函数
hello

# 2. 使用[函数名 函数参数]来传递参数
hello_world 1 2

# 3. 使用[FUN=`函数名 函数参数`]来间接调用
FUN=`hello_world 1 2`
echo $FUN
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;3_2&#34;&gt;3. 获取返回值&lt;/h4&gt;
&lt;p&gt;如何获取 &lt;code&gt;hello_world&lt;/code&gt; 函数的返回值？还记得 &lt;code&gt;$?&lt;/code&gt; 吗？&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;hello_world 1 2
# $? 可用于获取前一个函数的返回值，这里的结果是1
echo $?
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;4_2&#34;&gt;4. 定义本地变量&lt;/h4&gt;
&lt;p&gt;使用 &lt;code&gt;local&lt;/code&gt; 来在函数中定义本地变量：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;fun()
{
    local x=1
    echo $x
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;俗话说，程序 3 分靠写，7 分靠调，下面我们就来看看如何调试 Shell 程序。&lt;/p&gt;
&lt;h3 id=&#34;_2&#34;&gt;调试&lt;/h3&gt;
&lt;p&gt;使用下面的命令来检查是否有语法错误：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;sh -n script_name.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用下面的命令来执行并调试 Shell 脚本：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;sh -x script_name.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;来看个实际的例子，我们来调试下面这个 &lt;code&gt;test.sh&lt;/code&gt; 程序：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;#!/bin/bash

for VAR in 1 2 3
do
    if [ $VAR -eq 2 ]
    then
        continue
    fi
    echo $VAR
done
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先检查有无语法错误：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;sh -n test.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;没有输出，说明没有错误，开始实际高度：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;sh -x test.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;调试结果如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;+ [ 1 -eq 2 ]
+ echo 1
1
+ [ 2 -eq 2 ]
+ continue
+ [ 3 -eq 2 ]
+ echo 3
3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中&lt;strong&gt;带有 &lt;code&gt;+&lt;/code&gt; 表示的是 Shell 调试器的输出，不带 &lt;code&gt;+&lt;/code&gt; 表示我们程序的输出。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;shell_7&#34;&gt;Shell 易错点&lt;/h3&gt;
&lt;p&gt;这里我总结了一些初学 Shell 编程容易犯的错误，大多都是语法错误：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;[]&lt;/code&gt; 内不能嵌套 &lt;code&gt;()&lt;/code&gt;，可以嵌套 &lt;code&gt;[]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$[ val + 1 ]&lt;/code&gt; 是变量加 1 的常用方法&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[]&lt;/code&gt; 在测试或者计算中里面的内容最好都加空格&lt;/li&gt;
&lt;li&gt;单引号和双引号差不多，单引号更加严格，双引号可以嵌套单引号&lt;/li&gt;
&lt;li&gt;一定要注意语句的格式，例如缩进&lt;/li&gt;
&lt;/ol&gt;</description>  
      <pubDate>2025-10-09 17:54:40</pubDate>  
      <link>https://testpoo.github.io/shell简介.html</link>  
      <guid isPermaLink="true">https://testpoo.github.io/shell简介.html</guid>
       
      <category>技术</category> 
      
    </item>
    
    <item> 
      <title>Docker入门教程</title>  
      <description>&lt;div class=&#34;toc&#34;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#_1&#34;&gt;一、环境配置的难题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_2&#34;&gt;二、虚拟机&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#linux&#34;&gt;三、Linux 容器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#docker&#34;&gt;四、Docker 是什么？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#docker_1&#34;&gt;五、Docker 的用途&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#docker_2&#34;&gt;六、Docker 的安装&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#image&#34;&gt;六、image 文件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#hello-world&#34;&gt;七、实例：hello world&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_3&#34;&gt;八、容器文件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#dockerfile&#34;&gt;九、Dockerfile 文件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#docker_3&#34;&gt;十、实例：制作 Docker 容器&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#101-dockerfile&#34;&gt;10.1 编写 Dockerfile 文件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#102-image&#34;&gt;10.2 创建 image 文件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#103&#34;&gt;10.3 生成容器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#104-cmd&#34;&gt;10.4 CMD 命令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#105-image&#34;&gt;10.5 发布 image 文件&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_4&#34;&gt;十一、其他有用的命令&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;p&gt;2013年发布至今， &lt;a href=&#34;https://www.docker.com/&#34;&gt;Docker&lt;/a&gt; 一直广受瞩目，被认为可能会改变软件行业。本文简单介绍一下docker，以便于大家日常使用。&lt;/p&gt;
&lt;h2 id=&#34;_1&#34;&gt;一、环境配置的难题&lt;/h2&gt;
&lt;p&gt;软件开发最大的麻烦事之一，就是环境配置。用户计算机的环境都不相同，你怎么知道自家的软件，能在那些机器跑起来？&lt;/p&gt;
&lt;p&gt;用户必须保证两件事：操作系统的设置，各种库和组件的安装。只有它们都正确，软件才能运行。举例来说，安装一个 Python 应用，计算机必须有 Python 引擎，还必须有各种依赖，可能还要配置环境变量。&lt;/p&gt;
&lt;p&gt;如果某些老旧的模块与当前环境不兼容，那就麻烦了。开发者常常会说：&#34;它在我的机器可以跑了，言下之意就是，其他机器很可能跑不了。&lt;/p&gt;
&lt;p&gt;环境配置如此麻烦，换一台机器，就要重来一次，旷日费时。很多人想到，能不能从根本上解决问题，软件可以带环境安装？也就是说，安装的时候，把原始环境一模一样地复制过来。&lt;/p&gt;
&lt;h2 id=&#34;_2&#34;&gt;二、虚拟机&lt;/h2&gt;
&lt;p&gt;虚拟机就是带环境安装的一种解决方案。它可以在一种操作系统里面运行另一种操作系统，比如在 Windows 系统里面运行 Linux 系统。应用程序对此毫无感知，因为虚拟机看上去跟真实系统一模一样，而对于底层系统来说，虚拟机就是一个普通文件，不需要了就删掉，对其他部分毫无影响。&lt;/p&gt;
&lt;p&gt;虽然用户可以通过虚拟机还原软件的原始环境。但是，这个方案有几个缺点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（1）资源占用多&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;虚拟机会独占一部分内存和硬盘空间。它运行的时候，其他程序就不能使用这些资源了。哪怕虚拟机里面的应用程序，真正使用的内存只有 1MB，虚拟机依然需要几百 MB 的内存才能运行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（2）冗余步骤多&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;虚拟机是完整的操作系统，一些系统级别的操作步骤，往往无法跳过，比如用户登录。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（3）启动慢&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;启动操作系统需要多久，启动虚拟机就需要多久。可能要等几分钟，应用程序才能真正运行。&lt;/p&gt;
&lt;h2 id=&#34;linux&#34;&gt;三、Linux 容器&lt;/h2&gt;
&lt;p&gt;由于虚拟机存在这些缺点，Linux 发展出了另一种虚拟化技术：Linux 容器（Linux Containers，缩写为 LXC）。&lt;/p&gt;
&lt;p&gt;Linux 容器不是模拟一个完整的操作系统，而是对进程进行隔离。或者说，在正常进程的外面套了一个保护层。由于容器是进程级别的，相比虚拟机有很多优势。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（1）启动快&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;容器里面的应用，直接就是底层系统的一个进程，而不是虚拟机内部的进程。所以，启动容器相当于启动本机的一个进程，而不是启动一个操作系统，速度就快很多。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（2）资源占用少&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;容器只占用需要的资源，不占用那些没有用到的资源；虚拟机由于是完整的操作系统，不可避免要占用所有资源。另外，多个容器可以共享资源，虚拟机都是独享资源。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（3）体积小&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;容器只要包含用到的组件即可，而虚拟机是整个操作系统的打包，所以容器文件比虚拟机文件要小很多。&lt;/p&gt;
&lt;p&gt;总之，容器有点像轻量级的虚拟机，能够提供虚拟化的环境，但是成本开销小得多。&lt;/p&gt;
&lt;h2 id=&#34;docker&#34;&gt;四、Docker 是什么？&lt;/h2&gt;
&lt;p&gt;Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。它是目前最流行的 Linux 容器解决方案。&lt;/p&gt;
&lt;p&gt;Docker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 Docker，就不用担心环境问题。&lt;/p&gt;
&lt;p&gt;总体来说，Docker 的接口相当简单，用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。&lt;/p&gt;
&lt;h2 id=&#34;docker_1&#34;&gt;五、Docker 的用途&lt;/h2&gt;
&lt;p&gt;Docker 的主要用途，目前有三大类。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;提供一次性的环境。比如，本地测试他人的软件、持续集成的时候提供单元测试和构建的环境。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;提供弹性的云服务。因为 Docker 容器可以随开随关，很适合动态扩容和缩容。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;组建微服务架构。通过多个容器，一台机器可以跑多个服务，因此在本机就可以模拟出微服务架构。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;docker_2&#34;&gt;六、Docker 的安装&lt;/h2&gt;
&lt;p&gt;Docker 是一个开源的商业产品，有两个版本：社区版（Community Edition，缩写为 CE）和企业版（Enterprise Edition，缩写为 EE）。企业版包含了一些收费服务，个人开发者一般用不到。下面的介绍都针对社区版。&lt;/p&gt;
&lt;p&gt;Docker CE 的安装请参考官方文档。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.docker.com/docker-for-mac/install/&#34;&gt;Mac&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.docker.com/docker-for-windows/install/&#34;&gt;Windows&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.docker.com/install/linux/docker-ce/ubuntu/&#34;&gt;Ubuntu&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.docker.com/install/linux/docker-ce/debian/&#34;&gt;Debian&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.docker.com/install/linux/docker-ce/centos/&#34;&gt;CentOS&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.docker.com/install/linux/docker-ce/fedora/&#34;&gt;Fedora&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.docker.com/install/linux/docker-ce/binaries/&#34;&gt;其他 Linux 发行版&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本次以CentOS为例，说明如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;卸载老版本&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;老版本的Docker叫&lt;code&gt;docker&lt;/code&gt; 或者&lt;code&gt;docker-engine&lt;/code&gt;，如果它们安装了，需要先卸载它们以及相关的依赖，如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;sudo yum remove docker \
                docker-client \
                docker-client-latest \
                docker-common \
                docker-latest \
                docker-latest-logrotate \
                docker-logrotate \
                docker-engine
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;安装方法&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;安装包含&lt;code&gt;yum-config-manager&lt;/code&gt;程序的 &lt;code&gt;yum-utils&lt;/code&gt;包，然后添加稳定源，如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;sudo yum install -y yum-utils
sudo yum-config-manager \
   --add-repo \
   https://download.docker.com/linux/centos/docker-ce.repo
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;安装Docker引擎&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安装最新的Docker引擎和容器&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;sudo yum install docker-ce docker-ce-cli containerd.io
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该命令只安装Docker，但不会启动Docker。不过它会创建一个docker组，默认情况下不会向该组添加任何用户。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;安装一个特殊版本的Docker引擎，首先查出可用的版本，然后选择安装。如下：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;$ yum list docker-ce --showduplicates | sort -r
docker-ce.x86_64  3:18.09.1-3.el7                     docker-ce-stable
docker-ce.x86_64  3:18.09.0-3.el7                     docker-ce-stable
docker-ce.x86_64  18.06.1.ce-3.el7                    docker-ce-stable
docker-ce.x86_64  18.06.0.ce-3.el7                    docker-ce-stable
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;选择一个版本安装，安装特殊版本需要写上全称，如&lt;code&gt;docker-ce-18.09.1&lt;/code&gt;，如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;sudo yum install docker-ce-&amp;lt;VERSION_STRING&amp;gt; docker-ce-cli-&amp;lt;VERSION_STRING&amp;gt; containerd.io
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该命令只安装Docker，但不会启动Docker。不过它会创建一个docker组，默认情况下不会向该组添加任何用户。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;启动docker&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;sudo systemctl start docker
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装完成后，运行下面的命令，验证是否安装成功。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;$ docker version
# 或者
$ docker info
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Docker 需要用户具有 sudo 权限，为了避免每次命令都输入&lt;code&gt;sudo&lt;/code&gt;，可以把用户加入 Docker 用户组。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;# 创建docker用户组.
sudo groupadd docker

# 把你的用户加入到docker用户组.
$ sudo usermod -aG docker $USER
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Docker 是服务器----客户端架构。命令行运行&lt;code&gt;docker&lt;/code&gt;命令的时候，需要本机有 Docker 服务。如果这项服务没有启动，可以用下面的命令启动。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;# service 命令的用法
$ sudo service docker start

# systemctl 命令的用法
$ sudo systemctl start docker
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;image&#34;&gt;六、image 文件&lt;/h2&gt;
&lt;p&gt;Docker 把应用程序及其依赖，打包在 image 文件里面。只有通过这个文件，才能生成 Docker 容器。image 文件可以看作是容器的模板。Docker 根据 image 文件生成容器的实例。同一个 image 文件，可以生成多个同时运行的容器实例。&lt;/p&gt;
&lt;p&gt;image 是二进制文件。实际开发中，一个 image 文件往往通过继承另一个 image 文件，加上一些个性化设置而生成。举例来说，你可以在 Ubuntu 的 image 基础上，往里面加入 Apache 服务器，形成你的 image。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;# 列出本机的所有 image 文件。
$ docker image ls

# 删除 image 文件
$ docker image rm [imageName]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;image 文件是通用的，一台机器的 image 文件拷贝到另一台机器，照样可以使用。一般来说，为了节省时间，我们应该尽量使用别人制作好的 image 文件，而不是自己制作。即使要定制，也应该基于别人的 image 文件进行加工，而不是从零开始制作。&lt;/p&gt;
&lt;p&gt;为了方便共享，image 文件制作完成后，可以上传到网上的仓库。Docker 的官方仓库 &lt;a href=&#34;https://hub.docker.com/&#34;&gt;Docker Hub&lt;/a&gt; 是最重要、最常用的 image 仓库。此外，出售自己制作的 image 文件也是可以的。&lt;/p&gt;
&lt;h2 id=&#34;hello-world&#34;&gt;七、实例：hello world&lt;/h2&gt;
&lt;p&gt;操作之前需要从仓库下载 image 文件，但是国内访问 Docker 的官方仓库很慢，还经常断线，所以要把仓库网址改成国内的镜像站。这里推荐使用官方镜像 registry.docker-cn.com 。下面是Debian 系统的默认仓库修改方法：&lt;/p&gt;
&lt;p&gt;打开&lt;code&gt;/etc/default/docker&lt;/code&gt;文件（需要&lt;code&gt;root&lt;/code&gt;权限），在文件的底部加上一行。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;DOCKER_OPTS=&amp;quot;--registry-mirror=https://registry.docker-cn.com&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后，重启 Docker 服务。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;$ sudo service docker restart
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面，我们通过最简单的 image 文件&#34;hello world&#34;，感受一下 Docker。&lt;/p&gt;
&lt;p&gt;首先，运行下面的命令，将 image 文件从仓库抓取到本地。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;$ docker image pull library/hello-world
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码中，&lt;code&gt;docker image pull&lt;/code&gt;是抓取 image 文件的命令。&lt;code&gt;library/hello-world&lt;/code&gt;是 image 文件在仓库里面的位置，其中&lt;code&gt;library&lt;/code&gt;是 image 文件所在的组，&lt;code&gt;hello-world&lt;/code&gt;是 image 文件的名字。&lt;/p&gt;
&lt;p&gt;由于 Docker 官方提供的 image 文件，都放在&lt;code&gt;library&lt;/code&gt;组里面，所以它的是默认组，可以省略。因此，上面的命令可以写成下面这样。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;$ docker image pull hello-world
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;抓取成功以后，就可以在本机看到这个 image 文件了。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;$ docker image ls
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在，运行这个 image 文件。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;$ docker container run hello-world
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;docker container run&lt;/code&gt;命令会从 image 文件，生成一个正在运行的容器实例。&lt;/p&gt;
&lt;p&gt;注意，&lt;code&gt;docker container run&lt;/code&gt;命令具有自动抓取 image 文件的功能。如果发现本地没有指定的 image 文件，就会从仓库自动抓取。因此，前面的&lt;code&gt;docker image pull&lt;/code&gt;命令并不是必需的步骤。&lt;/p&gt;
&lt;p&gt;如果运行成功，你会在屏幕上读到下面的输出。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;$ docker container run hello-world

Hello from Docker!
This message shows that your installation appears to be working correctly.

... ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出这段提示以后，&lt;code&gt;hello world&lt;/code&gt;就会停止运行，容器自动终止。&lt;/p&gt;
&lt;p&gt;有些容器不会自动终止，因为提供的是服务。比如，安装运行 Ubuntu 的 image，就可以在命令行体验 Ubuntu 系统。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;$ docker container run -it ubuntu bash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于那些不会自动终止的容器，必须使用&lt;code&gt;docker container kill&lt;/code&gt;命令手动终止。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;$ docker container kill [containID]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;_3&#34;&gt;八、容器文件&lt;/h2&gt;
&lt;p&gt;image 文件生成的容器实例，本身也是一个文件，称为容器文件。也就是说，一旦容器生成，就会同时存在两个文件： image 文件和容器文件。而且关闭容器并不会删除容器文件，只是容器停止运行而已。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;# 列出本机正在运行的容器
$ docker container ls

# 列出本机所有容器，包括终止运行的容器
$ docker container ls --all
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面命令的输出结果之中，包括容器的 ID。很多地方都需要提供这个 ID，比如上一节终止容器运行的&lt;code&gt;docker container kill&lt;/code&gt;命令。&lt;/p&gt;
&lt;p&gt;终止运行的容器文件，依然会占据硬盘空间，可以使用&lt;code&gt;docker container rm&lt;/code&gt;命令删除。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;$ docker container rm [containerID]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行上面的命令之后，再使用&lt;code&gt;docker container ls --all&lt;/code&gt;命令，就会发现被删除的容器文件已经消失了。&lt;/p&gt;
&lt;h2 id=&#34;dockerfile&#34;&gt;九、Dockerfile 文件&lt;/h2&gt;
&lt;p&gt;学会使用 image 文件以后，接下来的问题就是，如何可以生成 image 文件。这就需要用到 Dockerfile 文件。它是一个文本文件，用来配置 image。Docker 根据该文件生成二进制的 image 文件。下面通过一个实例，演示如何编写 Dockerfile 文件。&lt;/p&gt;
&lt;h2 id=&#34;docker_3&#34;&gt;十、实例：制作 Docker 容器&lt;/h2&gt;
&lt;p&gt;下面介绍怎么写 Dockerfile 文件，实现让用户在 Docker 容器里面运行 test框架。&lt;/p&gt;
&lt;p&gt;开始前，我们需要下载一个软件的源码做为制作Docker 容器的材料。我们以一个node项目为例，如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;$ git clone https://github.com/testpoo/test.git
$ cd test
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;101-dockerfile&#34;&gt;10.1 编写 Dockerfile 文件&lt;/h3&gt;
&lt;p&gt;首先，在项目的根目录下，新建一个文本文件&lt;code&gt;.dockerignore&lt;/code&gt;，写入下面的内容。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;.git
node_modules
npm-debug.log
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码表示，这三个路径要排除，不要打包进入 image 文件。如果你没有路径要排除，这个文件可以不新建。&lt;/p&gt;
&lt;p&gt;然后，在项目的根目录下，新建一个文本文件 Dockerfile，写入下面的内容。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;FROM node:8.4
COPY . /app
WORKDIR /app
RUN npm install --registry=https://registry.npm.taobao.org
EXPOSE 3000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码一共五行，含义如下。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;FROM node:8.4&lt;/code&gt;：该 image 文件继承官方的 node image，冒号表示标签，这里标签是&lt;code&gt;8.4&lt;/code&gt;，即8.4版本的 node。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;COPY . /app&lt;/code&gt;：将当前目录下的所有文件（除了&lt;code&gt;.dockerignore&lt;/code&gt;排除的路径），都拷贝进入 image 文件的&lt;code&gt;/app&lt;/code&gt;目录。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;WORKDIR /app&lt;/code&gt;：指定接下来的工作路径为&lt;code&gt;/app&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RUN npm install&lt;/code&gt;：在&lt;code&gt;/app&lt;/code&gt;目录下，运行&lt;code&gt;npm install&lt;/code&gt;命令安装依赖。注意，安装后所有的依赖，都将打包进入 image 文件。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;EXPOSE 3000&lt;/code&gt;：将容器 3000 端口暴露出来， 允许外部连接这个端口。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;102-image&#34;&gt;10.2 创建 image 文件&lt;/h3&gt;
&lt;p&gt;有了 Dockerfile 文件以后，就可以使用&lt;code&gt;docker image build&lt;/code&gt;命令创建 image 文件了。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;$ docker image build -t test .
# 或者
$ docker image build -t test:0.0.1 .
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码中，&lt;code&gt;-t&lt;/code&gt;参数用来指定 image 文件的名字，后面还可以用冒号指定标签。如果不指定，默认的标签就是&lt;code&gt;latest&lt;/code&gt;。最后的那个点表示 Dockerfile 文件所在的路径，上例是当前路径，所以是一个点。&lt;/p&gt;
&lt;p&gt;如果运行成功，就可以看到新生成的 image 文件&lt;code&gt;test&lt;/code&gt;了。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;$ docker image ls
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;103&#34;&gt;10.3 生成容器&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;docker container run&lt;/code&gt;命令会从 image 文件生成容器。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;$ docker container run -p 8000:3000 -it test /bin/bash
# 或者
$ docker container run -p 8000:3000 -it test:0.0.1 /bin/bash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面命令的各个参数含义如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-p&lt;/code&gt;参数：容器的 3000 端口映射到本机的 8000 端口。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-it&lt;/code&gt;参数：容器的 Shell 映射到当前的 Shell，然后你在本机窗口输入的命令，就会传入容器。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;test:0.0.1&lt;/code&gt;：image 文件的名字（如果有标签，还需要提供标签，默认是 latest 标签）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/bin/bash&lt;/code&gt;：容器启动以后，内部第一个执行的命令。这里是启动 Bash，保证用户可以使用 Shell。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果一切正常，运行上面的命令以后，就会返回一个命令行提示符。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;root@66d80f4aaf1e:/app#
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这表示你已经在容器里面了，返回的提示符就是容器内部的 Shell 提示符。执行下面的命令。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;root@66d80f4aaf1e:/app# node demos/01.js
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这时，test框架已经运行起来了。这个例子中，Node 进程运行在 Docker 容器的虚拟环境里面，进程接触到的文件系统和网络接口都是虚拟的，与本机的文件系统和网络接口是隔离的，因此需要定义容器与物理机的端口映射（map）。&lt;/p&gt;
&lt;p&gt;现在，在容器的命令行，按下 Ctrl + c 停止 Node 进程，然后按下 Ctrl + d （或者输入 exit）退出容器。此外，也可以用&lt;code&gt;docker container kill&lt;/code&gt;终止容器运行。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;# 在本机的另一个终端窗口，查出容器的 ID
$ docker container ls

# 停止指定的容器运行
$ docker container kill [containerID]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;容器停止运行之后，并不会消失，用下面的命令删除容器文件。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;# 查出容器的 ID
$ docker container ls --all

# 删除指定的容器文件
$ docker container rm [containerID]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也可以使用&lt;code&gt;docker container run&lt;/code&gt;命令的&lt;code&gt;--rm&lt;/code&gt;参数，在容器终止运行后自动删除容器文件。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;$ docker container run --rm -p 8000:3000 -it test /bin/bash
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;104-cmd&#34;&gt;10.4 CMD 命令&lt;/h3&gt;
&lt;p&gt;上一节的例子里面，容器启动以后，需要手动输入命令&lt;code&gt;node demos/01.js&lt;/code&gt;。我们可以把这个命令写在 Dockerfile 里面，这样容器启动以后，这个命令就已经执行了，不用再手动输入了。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;FROM node:8.4
COPY . /app
WORKDIR /app
RUN npm install --registry=https://registry.npm.taobao.org
EXPOSE 3000
CMD node demos/01.js
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的 Dockerfile 里面，多了最后一行&lt;code&gt;CMD node demos/01.js&lt;/code&gt;，它表示容器启动后自动执行&lt;code&gt;node demos/01.js&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;你可能会问，&lt;code&gt;RUN&lt;/code&gt;命令与&lt;code&gt;CMD&lt;/code&gt;命令的区别在哪里？简单说，&lt;code&gt;RUN&lt;/code&gt;命令在 image 文件的构建阶段执行，执行结果都会打包进入 image 文件；&lt;code&gt;CMD&lt;/code&gt;命令则是在容器启动后执行。另外，一个 Dockerfile 可以包含多个&lt;code&gt;RUN&lt;/code&gt;命令，但是只能有一个&lt;code&gt;CMD&lt;/code&gt;命令。&lt;/p&gt;
&lt;p&gt;注意，指定了&lt;code&gt;CMD&lt;/code&gt;命令以后，&lt;code&gt;docker container run&lt;/code&gt;命令就不能附加命令了（比如前面的&lt;code&gt;/bin/bash&lt;/code&gt;），否则它会覆盖&lt;code&gt;CMD&lt;/code&gt;命令。现在，启动容器可以使用下面的命令。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;$ docker container run --rm -p 8000:3000 -it test:0.0.1
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;105-image&#34;&gt;10.5 发布 image 文件&lt;/h3&gt;
&lt;p&gt;容器运行成功后，就确认了 image 文件的有效性。这时，我们就可以考虑把 image 文件分享到网上，让其他人使用。&lt;/p&gt;
&lt;p&gt;首先，去 &lt;a href=&#34;https://hub.docker.com/&#34;&gt;hub.docker.com&lt;/a&gt; 或 &lt;a href=&#34;https://cloud.docker.com/&#34;&gt;cloud.docker.com&lt;/a&gt; 注册一个账户。然后，用下面的命令登录。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;$ docker login
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接着，为本地的 image 标注用户名和版本。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;$ docker image tag [imageName] [username]/[repository]:[tag]
# 实例
$ docker image tag test:0.0.1 testpoo/test:0.0.1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也可以不标注用户名，重新构建一下 image 文件。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;$ docker image build -t [username]/[repository]:[tag] .
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后，发布 image 文件。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;$ docker image push [username]/[repository]:[tag]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;发布成功以后，登录 hub.docker.com，就可以看到已经发布的 image 文件。&lt;/p&gt;
&lt;h2 id=&#34;_4&#34;&gt;十一、其他有用的命令&lt;/h2&gt;
&lt;p&gt;docker 的主要用法就是上面这些，此外还有几个命令，也非常有用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（1）docker container start&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;前面的&lt;code&gt;docker container run&lt;/code&gt;命令是新建容器，每运行一次，就会新建一个容器。同样的命令运行两次，就会生成两个一模一样的容器文件。如果希望重复使用容器，就要使用&lt;code&gt;docker container start&lt;/code&gt;命令，它用来启动已经生成、已经停止运行的容器文件。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;$ docker container start [containerID]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;（2）docker container stop&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;前面的&lt;code&gt;docker container kill&lt;/code&gt;命令终止容器运行，相当于向容器里面的主进程发出 SIGKILL 信号。而&lt;code&gt;docker container stop&lt;/code&gt;命令也是用来终止容器运行，相当于向容器里面的主进程发出 SIGTERM 信号，然后过一段时间再发出 SIGKILL 信号。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;$ docker container stop [containerID]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这两个信号的差别是，应用程序收到 SIGTERM 信号以后，可以自行进行收尾清理工作，但也可以不理会这个信号。如果收到 SIGKILL 信号，就会强行立即终止，那些正在进行中的操作会全部丢失。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（3）docker container logs&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;docker container logs&lt;/code&gt;命令用来查看 docker 容器的输出，即容器里面 Shell 的标准输出。如果&lt;code&gt;docker run&lt;/code&gt;命令运行容器的时候，没有使用&lt;code&gt;-it&lt;/code&gt;参数，就要用这个命令查看输出。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;$ docker container logs [containerID]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;（4）docker container exec&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;docker container exec&lt;/code&gt;命令用于进入一个正在运行的 docker 容器。如果&lt;code&gt;docker run&lt;/code&gt;命令运行容器的时候，没有使用&lt;code&gt;-it&lt;/code&gt;参数，就要用这个命令进入容器。一旦进入了容器，就可以在容器的 Shell 执行命令了。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;$ docker container exec -it [containerID] /bin/bash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;（5）docker container cp&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;docker container cp&lt;/code&gt;命令用于从正在运行的 Docker 容器里面，将文件拷贝到本机。下面是拷贝到当前目录的写法。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;$ docker container cp [containID]:[/path/to/file] .
&lt;/code&gt;&lt;/pre&gt;</description>  
      <pubDate>2025-10-09 17:54:40</pubDate>  
      <link>https://testpoo.github.io/Docker入门教程.html</link>  
      <guid isPermaLink="true">https://testpoo.github.io/Docker入门教程.html</guid>
       
      <category>技术</category> 
      
    </item>
    
    <item> 
      <title>性能监控各指令详解</title>  
      <description>&lt;div class=&#34;toc&#34;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#_1&#34;&gt;常用命令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_2&#34;&gt;命令详解&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#top&#34;&gt;top&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1&#34;&gt;1. 指标详解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2&#34;&gt;2. 进程信息&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3-top&#34;&gt;3. top命令的一些用法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#uptime&#34;&gt;uptime&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1_1&#34;&gt;1. 指标详解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-uptime&#34;&gt;2. uptime命令的一些用法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#vmstat&#34;&gt;vmstat&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1_2&#34;&gt;1. 指标详解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2_1&#34;&gt;2. 常用参数&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#pidstat&#34;&gt;pidstat&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1_3&#34;&gt;1. 指标详解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-pidstat&#34;&gt;2. pidstat命令的一些用法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#mpstat&#34;&gt;mpstat&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1_4&#34;&gt;1. 指标详解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2_2&#34;&gt;2. 常用参数&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#iostat&#34;&gt;iostat&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1_5&#34;&gt;1. 指标详解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2_3&#34;&gt;2. 常用参数&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#dstat&#34;&gt;dstat&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1_6&#34;&gt;1. 指标详解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2_4&#34;&gt;2. 常用参数&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#free&#34;&gt;free&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1_7&#34;&gt;1. 指标详解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-free&#34;&gt;2. free命令的一些用法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#perf&#34;&gt;perf&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-perf&#34;&gt;1. perf命令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2_5&#34;&gt;2. 全局性概况&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3&#34;&gt;3. 常用命令&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#sar&#34;&gt;sar&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1_8&#34;&gt;1. 指标详解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2_6&#34;&gt;2. 常用参数&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#execsnoop&#34;&gt;execsnoop&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#atop&#34;&gt;atop&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1_9&#34;&gt;1. 指标详解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-atop&#34;&gt;2. atop命令的一些用法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#htop&#34;&gt;htop&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-htop&#34;&gt;1. htop命令优点&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-htop&#34;&gt;2. htop常用功能键&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3_1&#34;&gt;3. 指标详解&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h3 id=&#34;_1&#34;&gt;常用命令&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;常用的性能指标分析工具&lt;/li&gt;
&lt;/ol&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;性能指标&lt;/th&gt;
&lt;th&gt;工具&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;平均负载&lt;/td&gt;
&lt;td&gt;uptime&lt;br /&gt;top&lt;/td&gt;
&lt;td&gt;uptime最简单&lt;br /&gt;top提供了更全的指标&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;系统整体CPU使用率&lt;/td&gt;
&lt;td&gt;vmstat&lt;br /&gt;mpstat&lt;br /&gt;top&lt;br /&gt;sar&lt;br /&gt;/proc/stat&lt;/td&gt;
&lt;td&gt;top、vmstat、mpstat只可以动态查看，而sar还可以记录历史数据，/proc/stat是其他性能工具的来源&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;进程CPU使用率&lt;/td&gt;
&lt;td&gt;top&lt;br /&gt;pidstat&lt;br /&gt;ps&lt;br /&gt;htop&lt;br /&gt;atop&lt;/td&gt;
&lt;td&gt;top和ps可以按CPU使用率给进程排序，而pidstat只显示实际用了CPU的进程，htop和atop以不同颜色显示更直观&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;系统上下文切换&lt;/td&gt;
&lt;td&gt;vmstat&lt;/td&gt;
&lt;td&gt;除了上下文切换次数，还提供运行状态和不可中断状态进程的数量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;进程上下文切换&lt;/td&gt;
&lt;td&gt;pidstat&lt;/td&gt;
&lt;td&gt;注意加上-w选项&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;软中断&lt;/td&gt;
&lt;td&gt;top&lt;br /&gt;/proc/softirqs&lt;br /&gt;mpstat&lt;/td&gt;
&lt;td&gt;top提供软中断CPU使用率。而/proc/softirqs和mpstat提供了各种软中断在每个CPU上运行的累计次数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;硬中断&lt;/td&gt;
&lt;td&gt;vmstat&lt;br /&gt;/proc/interrupts&lt;/td&gt;
&lt;td&gt;vmstat提供总的中断次数，而/proc/interrupts提供各种中断在每个CPU上运行的累积次数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;网络&lt;/td&gt;
&lt;td&gt;dstat&lt;br /&gt;sar&lt;br /&gt;tcpdump&lt;/td&gt;
&lt;td&gt;dstat和sar提供总的网络接收和发送情况，而tcpdump则是动态抓取正在进行的网络通讯&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;I/O&lt;/td&gt;
&lt;td&gt;dstat&lt;br /&gt;sar&lt;br /&gt;iostat&lt;/td&gt;
&lt;td&gt;dstat和sar都提供了I/O的整体情况&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CPU个数&lt;/td&gt;
&lt;td&gt;/proc/cpuinfo&lt;br /&gt;lscpu&lt;/td&gt;
&lt;td&gt;lscpu更直观&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;事件剖析&lt;/td&gt;
&lt;td&gt;perf&lt;br /&gt;execsnoop&lt;/td&gt;
&lt;td&gt;perf可以用来分析CPU的缓存以及内核调用链，execsnoop用来监控短时进程&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;附录：&lt;/p&gt;
&lt;p&gt;安装&lt;code&gt;mpstat sar pidstat&lt;/code&gt;命令&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;apt-get install sysstat
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装&lt;code&gt;execsnoop&lt;/code&gt;命令&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;git clone --depth 1 https://github.com/brendangregg/perf-tools
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装atop, htop命令&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;apt insatll atop htop
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装dstat命令&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;apt insatll dstat
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;_2&#34;&gt;命令详解&lt;/h3&gt;
&lt;p&gt;Linux系统查看命令详解，可能用man命令来看，比如man iostat这种格式。&lt;/p&gt;
&lt;h4 id=&#34;top&#34;&gt;top&lt;/h4&gt;
&lt;p&gt;top命令是Linux下常用的性能分析工具，能够实时显示系统中的资源占用状况&lt;/p&gt;
&lt;h5 id=&#34;1&#34;&gt;1. 指标详解&lt;/h5&gt;
&lt;p&gt;进入linux服务器，输入top命令，展示以下界面，各种进程是按照CPU的占用量来排序的：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;top - 14:01:50 up 5 days, 21:52,  1 user,  load average: 0.45, 0.49, 0.46
Tasks: 258 total,   2 running, 256 sleeping,   0 stopped,   0 zombie
%Cpu(s):  1.9 us,  1.2 sy,  0.0 ni, 96.9 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
KiB Mem : 32782800 total, 12324952 free, 11637784 used,  8820064 buff/cache
KiB Swap: 32948220 total, 32948220 free,        0 used. 20842336 avail Mem

  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND
 4100 root      20   0 12.319g 1.958g  35072 S   1.7  6.3   8:43.25 java
 3610 root      20   0 11.759g 731148  30100 S   1.3  2.2   3:31.85 java
 3691 root      20   0 11.979g 0.996g  30356 S   1.3  3.2   4:26.58 java
 3794 root      20   0 3957140 415912  13960 S   1.3  1.3   3:33.77 java
 3403 root      20   0 11.803g 0.996g  30572 S   1.0  3.2   4:13.56 java
 3551 root      20   0 11.756g 828176  30900 S   1.0  2.5   3:28.33 java
 3962 root      20   0 11.902g 741900  34856 S   1.0  2.3   3:44.89 java
 1053 rabbitmq  20   0 3365540  90616   4696 S   0.7  0.3  54:54.88 beam.smp
 2219 mysql     20   0 12.168g 1.094g  10360 S   0.7  3.5  51:50.41 mysqld
 3874 root      20   0 11.641g 530360  29816 S   0.7  1.6   2:29.60 java
   13 root      20   0       0      0      0 S   0.3  0.0   3:44.90 rcu_sched
  478 root      20   0  237904  91436  88128 S   0.3  0.3  50:40.08 systemd-journal
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;显示信息可以分为两大块：&lt;/p&gt;
&lt;p&gt;（1）统计信息-前5行 &lt;/p&gt;
&lt;p&gt;（2）进程信息&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;统计信息（统计信息-第1行）&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;统计信息&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;14:01:50&lt;/td&gt;
&lt;td&gt;当前时间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;up 5 days, 21:52&lt;/td&gt;
&lt;td&gt;系统运行时间，格式为天，时:分&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1 user&lt;/td&gt;
&lt;td&gt;当前登录用户数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;load average: 0.45, 0.49, 0.46&lt;/td&gt;
&lt;td&gt;系统在之前 1 分钟、5 分钟、15 分钟的平均负载。这个数一般认为不应该超过服务器 CPU 的核数&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;进程信息（统计信息行）&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;进程信息&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Tasks: 258 total&lt;/td&gt;
&lt;td&gt;系统中的进程总数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2 running&lt;/td&gt;
&lt;td&gt;正在运行的进程数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;256 sleeping&lt;/td&gt;
&lt;td&gt;睡眠的进程数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0 stopped&lt;/td&gt;
&lt;td&gt;停止的进程数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0 zombie&lt;/td&gt;
&lt;td&gt;僵尸进程数&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;CPU信息（统计信息第3行）&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;CPU信息&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0.2% us&lt;/td&gt;
&lt;td&gt;用户空间占用CPU百分比&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0.0% sy&lt;/td&gt;
&lt;td&gt;内核空间占用CPU百分比&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0.0% ni&lt;/td&gt;
&lt;td&gt;用户进程空间内改变过优先级的进程占用CPU百分比&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;99.7% id&lt;/td&gt;
&lt;td&gt;空闲CPU百分比&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0.0% wa&lt;/td&gt;
&lt;td&gt;等待IO的CPU时间百分比&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0.0% hi&lt;/td&gt;
&lt;td&gt;硬件中断时间百分比&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0.0% si&lt;/td&gt;
&lt;td&gt;软件中断时间百分比&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0.0% st&lt;/td&gt;
&lt;td&gt;st（steal time）意为虚拟时间百分比，就是当有虚拟机时，虚拟 CPU 等待实际 CPU 的时间百分比&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;物理内存信息区（统计信息第4行）&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;物理内存信息&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;16267716 total&lt;/td&gt;
&lt;td&gt;物理内存总量 KB&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;9197036 free&lt;/td&gt;
&lt;td&gt;空闲内存总量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4680308 used&lt;/td&gt;
&lt;td&gt;使用的物理内存总量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2390188 buff/cache&lt;/td&gt;
&lt;td&gt;用作内核缓存的内存量&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;交换分区信息区（统计信息第5行）&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;交换分区信息&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;16777212 total&lt;/td&gt;
&lt;td&gt;交换分区（虚拟内存）的总大小&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;16777212 free&lt;/td&gt;
&lt;td&gt;空闲交换分区的大小&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0 used&lt;/td&gt;
&lt;td&gt;已经使用的交换分区的大小&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;11141172 avail Mem&lt;/td&gt;
&lt;td&gt;实际可用内存&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h5 id=&#34;2&#34;&gt;2. 进程信息&lt;/h5&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;列名&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;PID&lt;/td&gt;
&lt;td&gt;进程id&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;USER&lt;/td&gt;
&lt;td&gt;进程所有者的用户名&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;PR&lt;/td&gt;
&lt;td&gt;优先级&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;NI&lt;/td&gt;
&lt;td&gt;nice值。负值表示高优先级，正值表示低优先级&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;VIRT&lt;/td&gt;
&lt;td&gt;进程虚拟内存的大小，&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;RES&lt;/td&gt;
&lt;td&gt;常驻内存的大小，也就是进程实际使用的物理内存大小&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SHR&lt;/td&gt;
&lt;td&gt;共享内存的大小，比如与其他进程共同使用的共享、加载的动态链接库以及程序的代码段等，单位kb&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;S&lt;/td&gt;
&lt;td&gt;进程状态。&lt;br /&gt;D=不可中断的睡眠状态&lt;br/&gt;R=运行&lt;br/&gt;S=睡眠&lt;br/&gt;T=跟踪/停止&lt;br/&gt;Z=僵尸进程&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%CPU&lt;/td&gt;
&lt;td&gt;上次更新到现在的CPU时间占用百分比&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%MEM&lt;/td&gt;
&lt;td&gt;进程使用物理内存占系统总内存的百分比&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TIME+&lt;/td&gt;
&lt;td&gt;进程使用的CPU时间总计，单位1/100秒&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;COMMAND&lt;/td&gt;
&lt;td&gt;命令名/命令行&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h5 id=&#34;3-top&#34;&gt;3. top命令的一些用法&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;top命令常用参数&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;选项&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;-b&lt;/td&gt;
&lt;td&gt;批处理。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-c&lt;/td&gt;
&lt;td&gt;显示完整的命令。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-d&lt;/td&gt;
&lt;td&gt;表示top命令显示的页面更新一次的间隔，默认是 5 秒。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-I&lt;/td&gt;
&lt;td&gt;忽略失效过程。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-s&lt;/td&gt;
&lt;td&gt;保密模式。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-S&lt;/td&gt;
&lt;td&gt;累积模式。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-i&amp;lt;时间&amp;gt;&lt;/td&gt;
&lt;td&gt;设置间隔时间。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-u&amp;lt;用户名&amp;gt;&lt;/td&gt;
&lt;td&gt;指定用户名。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-p&amp;lt;进程号&amp;gt;&lt;/td&gt;
&lt;td&gt;指定进程。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-n&amp;lt;次数&amp;gt;&lt;/td&gt;
&lt;td&gt;循环显示的次数。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;Linux top命令交互指令&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;交互指令&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;?, h&lt;/td&gt;
&lt;td&gt;显示交互模式的帮助。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P&lt;/td&gt;
&lt;td&gt;按照 CPU 的使用率排序，默认就是此选项。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;M&lt;/td&gt;
&lt;td&gt;按照内存的使用率排序。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;N&lt;/td&gt;
&lt;td&gt;按照 PID 排序。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;T&lt;/td&gt;
&lt;td&gt;按照 CPU 的累积运算时间排序，也就是按照 TIME+ 项排序。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;k&lt;/td&gt;
&lt;td&gt;按照 PID 给予某个进程一个信号。一般用于中止某个进程，信号 9 是强制中止的信号。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;r&lt;/td&gt;
&lt;td&gt;按照 PID 给某个进程重设优先级（Nice）值。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;q&lt;/td&gt;
&lt;td&gt;退出 top 命令。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;显示各个CPU的资源占用情况&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在top基本视图中，按键盘数字“1”，可监控每个逻辑CPU的状况：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;top - 14:33:51 up 5 days, 22:24,  1 user,  load average: 0.18, 0.24, 0.41
Tasks: 259 total,   1 running, 258 sleeping,   0 stopped,   0 zombie
%Cpu0  :  3.3 us,  1.3 sy,  0.0 ni, 95.3 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu1  :  2.0 us,  1.0 sy,  0.0 ni, 96.6 id,  0.3 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu2  :  3.0 us,  1.0 sy,  0.0 ni, 96.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu3  :  2.0 us,  1.0 sy,  0.0 ni, 97.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
KiB Mem : 32782800 total, 12410600 free, 11485304 used,  8886896 buff/cache
KiB Swap: 32948220 total, 32948220 free,        0 used. 20994224 avail Mem
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再次输入1，可回到之前的视图，按所有CPU平均值显示&lt;/p&gt;
&lt;h4 id=&#34;uptime&#34;&gt;uptime&lt;/h4&gt;
&lt;p&gt;uptime命令显示系统已经运行了多长时间，它依次显示下列信息：当前时间、系统已经运行了多长时间、有多少登录用户、系统在过去的1分钟、5分钟和15分钟内的平均负载。平均负载是指单位时间内，系统处于可运行状态和不可中断的平均进程数，也就是平均活跃进程数。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-python&#34;&gt; 14:44:20 up 5 days, 22:35,  1 user,  load average: 0.13, 0.34, 0.40
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;1_1&#34;&gt;1. 指标详解&lt;/h5&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;统计信息&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;14:44:20&lt;/td&gt;
&lt;td&gt;系统当前时间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;up 5 days, 22:35&lt;/td&gt;
&lt;td&gt;主机已运行时间,时间越大，说明你的机器越稳定。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1 user&lt;/td&gt;
&lt;td&gt;用户连接数，是总连接数而不是用户数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;load average: 0.13, 0.34, 0.40&lt;/td&gt;
&lt;td&gt;系统平均负载，统计最近1，5，15分钟的系统平均负载&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h5 id=&#34;2-uptime&#34;&gt;2. uptime命令的一些用法&lt;/h5&gt;
&lt;p&gt;watch -d uptime命令可持续观测系统负载情况，-d是高亮显示变化值&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;wacth -d uptime
Every 2.0s: uptime                                                                                                          

 14:45:03 up 5 days, 22:36,  1 user,  load average: 0.06, 0.29, 0.38
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;vmstat&#34;&gt;vmstat&lt;/h4&gt;
&lt;p&gt;vmstat命令可以展现给定时间间隔的服务器的状态值，包括服务器的CPU使用率，内存使用，虚拟内存交换情况，IO读写情况。相比top，可以看到整个机器的CPU、内存、IO的使用情况，而不是单单看到各个进程的CPU使用率和内存使用率（使用场景不一样）。&lt;/p&gt;
&lt;h5 id=&#34;1_2&#34;&gt;1. 指标详解&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;指标详情&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;vmstat命令使用的一般格式为：vmstat 2 5，其中2表示每隔2秒，5表示采样次数，共打印5次信息。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;vmstat 2 5
procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
 1  0      0 12393280 659532 8275800    0    0     0    21    5   10  4  3 92  1  0
 0  0      0 12392696 659532 8275812    0    0     0    88 7264 16765  2  1 97  0  0
 0  0      0 12393100 659532 8275820    0    0     0   571 7361 16875  2  1 96  1  0
 2  0      0 12393212 659532 8275728    0    0     0     0 7650 17094  2  1 97  0  0
 0  0      0 12392668 659532 8275740    0    0     0    28 7431 16937  2  1 97  0  0
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;详细说明&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;procs&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;项目&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;r&lt;/td&gt;
&lt;td&gt;等待执行的任务数&lt;/td&gt;
&lt;td&gt;包括了ready和running的线程，展示了正在执行和等待cpu资源的任务个数。当这个值超过了cpu个数，就会出现cpu瓶颈&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;b&lt;/td&gt;
&lt;td&gt;等待IO的进程数量&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;memory&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;项目&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;swpd&lt;/td&gt;
&lt;td&gt;正在使用虚拟的内存大小，单位k&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;free&lt;/td&gt;
&lt;td&gt;空闲物理内存大小&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;buff&lt;/td&gt;
&lt;td&gt;已用的buff大小，对块设备的读写进行缓冲&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;cache&lt;/td&gt;
&lt;td&gt;已用的cache大小，文件系统的cache&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;swap&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;项目&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;si&lt;/td&gt;
&lt;td&gt;每秒从交换区写入内存的大小（单位：kb/s）&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;so&lt;/td&gt;
&lt;td&gt;每秒从内存写到交换区的大小&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;io&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;项目&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;bi&lt;/td&gt;
&lt;td&gt;每秒读取的块数（读磁盘）&lt;/td&gt;
&lt;td&gt;块设备每秒接收的块数量，单位是block，这里的块设备是指系统上所有的磁盘和其他块设备，现在的Linux版本块的大小为1024bytes&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;bo&lt;/td&gt;
&lt;td&gt;每秒写入的块数（写磁盘）&lt;/td&gt;
&lt;td&gt;块设备每秒发送的块数量，单位是block&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;system&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;项目&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;in&lt;/td&gt;
&lt;td&gt;每秒中断数，包括时钟中断&lt;/td&gt;
&lt;td&gt;这两个值越大，会看到由内核消耗的cpu时间sy会越多&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;cs&lt;/td&gt;
&lt;td&gt;每秒上下文切换数&lt;/td&gt;
&lt;td&gt;秒上下文切换次数，例如我们调用系统函数，就要进行上下文切换，线程的切换，也要进程上下文切换，这个值要越小越好，太大了，要考虑调低线程或者进程的数目&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;cpu（以百分比表示）&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;项目&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;us&lt;/td&gt;
&lt;td&gt;用户进程执行消耗cpu时间(user time)百分比&lt;/td&gt;
&lt;td&gt;us的值比较高时，说明用户进程消耗的cpu时间多，但是如果长期超过50%的使用，那么我们就该考虑优化程序算法或其他措施了&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;sy&lt;/td&gt;
&lt;td&gt;系统进程消耗cpu时间(system time)百分比&lt;/td&gt;
&lt;td&gt;sys的值过高时，说明系统内核消耗的cpu资源多，这个不是良性的表现，我们应该检查原因。这里us + sy的参考值为80%，如果us+sy 大于 80%说明可能存在CPU不足&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Id&lt;/td&gt;
&lt;td&gt;空闲时间(包括IO等待时间)百分比&lt;/td&gt;
&lt;td&gt;一般来说 us+sy+id=100&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;wa&lt;/td&gt;
&lt;td&gt;等待IO时间百分比&lt;/td&gt;
&lt;td&gt;wa过高时，说明io等待比较严重，这可能是由于磁盘大量随机访问造成的，也有可能是磁盘的带宽出现瓶颈。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h5 id=&#34;2_1&#34;&gt;2. 常用参数&lt;/h5&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;选项&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;-a&lt;/td&gt;
&lt;td&gt;显示活动内页&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-f&lt;/td&gt;
&lt;td&gt;显示启动后创建的进程总数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-m&lt;/td&gt;
&lt;td&gt;显示slab信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-n&lt;/td&gt;
&lt;td&gt;头信息仅显示一次&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-s&lt;/td&gt;
&lt;td&gt;以表格方式显示事件计数器和内存状态&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-d&lt;/td&gt;
&lt;td&gt;报告磁盘状态&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-p&lt;/td&gt;
&lt;td&gt;显示指定的硬盘分区状态&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-S&lt;/td&gt;
&lt;td&gt;输出信息的单位。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;pidstat&#34;&gt;pidstat&lt;/h4&gt;
&lt;p&gt;pidstat主要用于监控全部或指定进程占用系统资源的情况，如CPU，内存、设备IO、任务切换、线程等。pidstat首次运行时显示自系统启动开始的各项统计信息，之后运行pidstat将显示自上次运行该命令以后的统计信息。用户可以通过指定统计的次数和时间来获得所需的统计信息。&lt;/p&gt;
&lt;h5 id=&#34;1_3&#34;&gt;1. 指标详解&lt;/h5&gt;
&lt;p&gt;直接执行pidstat，输出系统启动后所有活动进程的cpu统计信息&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;Linux 5.10.0-8-amd64 (debian)   08/19/2021      _x86_64_        (2 CPU)

03:45:19 PM   UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command
03:45:19 PM     0         1    0.07    0.45    0.00    0.07    0.52     0  systemd
03:45:19 PM     0         2    0.00    0.00    0.00    0.00    0.00     0  kthreadd
03:45:19 PM     0        12    0.01    0.00    0.00    0.04    0.01     0  ksoftirqd/0
03:45:19 PM     0        13    0.01    0.02    0.00    0.08    0.03     0  rcu_sched
03:45:19 PM     0        14    0.00    0.00    0.00    0.00    0.00     0  migration/0
03:45:19 PM     0        17    0.14    0.00    0.00    0.00    0.14     1  migration/1
03:45:19 PM     0        18    0.01    0.00    0.00    0.05    0.01     1  ksoftirqd/1
03:45:19 PM     0        26    0.00    0.06    0.00    0.04    0.06     0  kworker/0:2-mpt_poll_0
03:45:19 PM     0        30    0.00    0.00    0.00    0.01    0.01     1  kcompactd0
03:45:19 PM     0        32    0.00    0.02    0.00    0.00    0.02     1  khugepaged
03:45:19 PM     0        56    0.00    0.04    0.00    0.00    0.04     0  kworker/0:1H-kblockd
03:45:19 PM     0       127    0.00    0.03    0.00    0.00    0.03     1  kworker/1:1H-kblockd
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;统计信息&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;%usr&lt;/td&gt;
&lt;td&gt;用户空间CPU占用率&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%system&lt;/td&gt;
&lt;td&gt;内核空间CPU占用率&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%guest&lt;/td&gt;
&lt;td&gt;客户 CPU 使用率&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%CPU&lt;/td&gt;
&lt;td&gt;总的cpu占用率&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CPU&lt;/td&gt;
&lt;td&gt;cpu编号信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Command&lt;/td&gt;
&lt;td&gt;拉起进程对应的命令&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h5 id=&#34;2-pidstat&#34;&gt;2. pidstat命令的一些用法&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;指定采样周期和采样次数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;执行命令： pidstat 2 5；2表示每隔2s采样一次，5表示共采样5次；跟采样周期跟采样次数时，持续输出信息；也可只跟采样周期，测试时可持续观测&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;Linux 5.10.0-8-amd64 (debian)   08/19/2021      _x86_64_        (2 CPU)

03:46:07 PM   UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command
03:46:09 PM     0        26    0.00    0.50    0.00    0.00    0.50     0  kworker/0:2-events
03:46:09 PM     0       445    0.50    0.00    0.00    0.00    0.50     1  vmtoolsd
03:46:09 PM  1000       980    0.00    0.50    0.00    0.00    0.50     0  panel-8-pulseau
03:46:09 PM     0      1573    0.00    0.50    0.00    0.00    0.50     1  kworker/1:0-events
03:46:09 PM  1000      1580    0.00    0.50    0.00    0.00    0.50     0  pidstat

03:46:09 PM   UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command
03:46:11 PM     0       445    0.50    0.00    0.00    0.00    0.50     1  vmtoolsd
03:46:11 PM  1000      1569    0.00    0.50    0.00    0.00    0.50     0  sshd

03:46:11 PM   UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command
03:46:13 PM  1000      1580    0.50    0.50    0.00    0.00    1.00     0  pidstat

03:46:13 PM   UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command
03:46:15 PM     0        13    0.00    0.50    0.00    0.00    0.50     1  rcu_sched
03:46:15 PM     0       445    0.50    0.00    0.00    0.00    0.50     0  vmtoolsd
03:46:15 PM  1000      1580    0.00    0.50    0.00    0.00    0.50     1  pidstat

03:46:15 PM   UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command
03:46:17 PM     0       445    0.00    0.50    0.00    0.00    0.50     1  vmtoolsd
03:46:17 PM  1000       980    0.50    0.00    0.00    0.00    0.50     0  panel-8-pulseau
03:46:17 PM     0      1573    0.00    0.50    0.00    0.00    0.50     1  kworker/1:0-events

Average:      UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command
Average:        0        13    0.00    0.10    0.00    0.00    0.10     -  rcu_sched
Average:        0        26    0.00    0.10    0.00    0.00    0.10     -  kworker/0:2-events
Average:        0       445    0.30    0.10    0.00    0.00    0.40     -  vmtoolsd
Average:     1000       980    0.10    0.10    0.00    0.00    0.20     -  panel-8-pulseau
Average:     1000      1569    0.00    0.10    0.00    0.00    0.10     -  sshd
Average:        0      1573    0.00    0.20    0.00    0.00    0.20     -  kworker/1:0-events
Average:     1000      1580    0.10    0.30    0.00    0.00    0.40     -  pidstat
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;CPU使用情况统计(-u)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;命令格式：pidstat -u （后面可以跟间隔时间及采样次数）;使用-u选项，pidstat将显示各活动进程的cpu使用统计，执行”pidstat -u”与单独执行”pidstat”的效果一样。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;pidstat -u 1 3
Linux 5.10.0-8-amd64 (debian)   08/19/2021      _x86_64_        (2 CPU)

03:47:47 PM   UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command
03:47:48 PM  1000      1582    1.98    0.00    0.00    0.00    1.98     0  pidstat

03:47:48 PM   UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command
03:47:49 PM     0       445    1.00    0.00    0.00    0.00    1.00     0  vmtoolsd
03:47:49 PM     0      1573    0.00    1.00    0.00    0.00    1.00     1  kworker/1:0-mm_percpu_wq

03:47:49 PM   UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command
03:47:50 PM  1000      1582    0.99    0.00    0.00    0.00    0.99     0  pidstat

Average:      UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command
Average:        0       445    0.33    0.00    0.00    0.00    0.33     -  vmtoolsd
Average:        0      1573    0.00    0.33    0.00    0.00    0.33     -  kworker/1:0-mm_percpu_wq
Average:     1000      1582    0.99    0.00    0.00    0.00    0.99     -  pidstat
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;内存使用情况统计(-r)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;命令格式： pidstat -r 1&lt;/p&gt;
&lt;p&gt;使用-r选项，pidstat将显示各活动进程的内存使用统计&lt;/p&gt;
&lt;p&gt;输出的各指标详情：&lt;/p&gt;
&lt;p&gt;minflt/s：每秒次缺页错误次数(minor page faults)，次缺页错误次数意即虚拟内存地址映射成物理内存地址产生的page fault次数&lt;/p&gt;
&lt;p&gt;majflt/s：每秒主缺页错误次数(major page faults)，当虚拟内存地址映射成物理内存地址时，相应的page在swap中，这样的page fault为major page fault，一般在内存使用紧张时产生&lt;/p&gt;
&lt;p&gt;VSZ：该进程使用的虚拟内存(以kB为单位)&lt;/p&gt;
&lt;p&gt;RSS：该进程使用的物理内存(以kB为单位)&lt;/p&gt;
&lt;p&gt;%MEM：该进程使用内存的百分比&lt;/p&gt;
&lt;p&gt;Command：拉起进程对应的命令&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;pidstat -r 1
Linux 5.10.0-8-amd64 (debian)   08/19/2021      _x86_64_        (2 CPU)

03:49:39 PM   UID       PID  minflt/s  majflt/s     VSZ     RSS   %MEM  Command
03:49:40 PM     0       445      0.99      0.00  162680    6876   0.17  vmtoolsd
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;指定进程的信息(-p)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;命令格式： pidstat -p $pid 2 3&lt;/p&gt;
&lt;p&gt;使用-p选项，pidstat将显示制定进程的CPU使用统计&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;pidstat -p 990 2 3
Linux 5.10.0-8-amd64 (debian)   08/19/2021      _x86_64_        (2 CPU)

03:51:42 PM   UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command
03:51:44 PM  1000       990    0.00    0.00    0.00    0.00    0.00     0  applet.py
03:51:46 PM  1000       990    0.00    0.00    0.00    0.00    0.00     0  applet.py
03:51:48 PM  1000       990    0.00    0.00    0.00    0.00    0.00     0  applet.py
Average:     1000       990    0.00    0.00    0.00    0.00    0.00     -  applet.py
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;IO情况统计(-d)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;命令格式：pidstat -d 2 3&lt;/p&gt;
&lt;p&gt;使用-d选项，我们可以查看进程IO的统计信息&lt;/p&gt;
&lt;p&gt;输出的各指标详情：&lt;/p&gt;
&lt;p&gt;kB_rd/s: 每秒进程从磁盘读取的数据量(以kB为单位)&lt;/p&gt;
&lt;p&gt;kB_wr/s: 每秒进程向磁盘写的数据量(以kB为单位)&lt;/p&gt;
&lt;p&gt;Command: 拉起进程对应的命令&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;pidstat -d 2 3
Linux 5.10.0-8-amd64 (debian)   08/19/2021      _x86_64_        (2 CPU)

03:52:20 PM   UID       PID   kB_rd/s   kB_wr/s kB_ccwr/s iodelay  Command

03:52:22 PM   UID       PID   kB_rd/s   kB_wr/s kB_ccwr/s iodelay  Command

03:52:24 PM   UID       PID   kB_rd/s   kB_wr/s kB_ccwr/s iodelay  Command

Average:      UID       PID   kB_rd/s   kB_wr/s kB_ccwr/s iodelay  Command
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;查看进程上下文切换(-w)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;命令格式：pidstat -w 2 3&lt;/p&gt;
&lt;p&gt;使用-w选项，可以查看进程上下文切换情况，也可结合-p来查看指定进程的上下文切换情况&lt;/p&gt;
&lt;p&gt;输出的各项指标详情：&lt;/p&gt;
&lt;p&gt;cswch/s ，表示每秒自愿上下文切换的次数（是指进程无法获取所需资源，导致的上下文切换。比如说， I/O、内存等系统资源不足时，就会发生自愿上下文切换。）&lt;/p&gt;
&lt;p&gt;nvcswch/s ，表示每秒非自愿上下文切换的次数（是指进程由于时间片已到等原因，被系统强制调度，进而发生的上下文切换。比如说，大量进程都在争抢 CPU 时，就容易发生非自愿上下文切换）&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;pidstat -w 2 3
Linux 5.10.0-8-amd64 (debian)   08/19/2021      _x86_64_        (2 CPU)

03:53:19 PM   UID       PID   cswch/s nvcswch/s  Command
03:53:21 PM     0        13      4.48      0.00  rcu_sched
03:53:21 PM     0        14      0.50      0.00  migration/0
03:53:21 PM     0        17      0.50      0.00  migration/1
03:53:21 PM     0        26      4.48      0.00  kworker/0:2-events
03:53:21 PM     0        30      1.49      0.00  kcompactd0
03:53:21 PM     0       256      0.50      0.00  kworker/u256:26-flush-8:0
03:53:21 PM     0       445     11.44      0.00  vmtoolsd
03:53:21 PM     0       546      0.50      0.00  wpa_supplicant
03:53:21 PM  1000       858      1.00      0.00  dbus-daemon
03:53:21 PM  1000       905      0.50      0.00  ssh-agent
03:53:21 PM  1000       980      1.99      0.00  panel-8-pulseau
03:53:21 PM     0      1586      3.48      0.00  kworker/1:1-events
03:53:21 PM  1000      1604      0.50      0.00  pidstat
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;查看线程上下文切换(-t)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;-wt参数表示输出线程的上下文切换指标，可显示当前进程的多个线程的上下文切换情况&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;pidstat -wt -p 990 2
Linux 5.10.0-8-amd64 (debian)   08/19/2021      _x86_64_        (2 CPU)

03:54:12 PM   UID      TGID       TID   cswch/s nvcswch/s  Command
03:54:14 PM  1000       990         -      0.00      0.00  applet.py
03:54:14 PM  1000         -       990      0.00      0.00  |__applet.py
03:54:16 PM  1000       990         -      0.00      0.00  applet.py
03:54:16 PM  1000         -       990      0.00      0.00  |__applet.py
03:54:18 PM  1000       990         -      0.00      0.00  applet.py
03:54:18 PM  1000         -       990      0.00      0.00  |__applet.py
03:54:20 PM  1000       990         -      0.00      0.00  applet.py
03:54:20 PM  1000         -       990      0.00      0.00  |__applet.py
03:54:22 PM  1000       990         -      0.00      0.00  applet.py
03:54:22 PM  1000         -       990      0.00      0.00  |__applet.py
03:54:24 PM  1000       990         -      0.00      0.00  applet.py
03:54:24 PM  1000         -       990      0.00      0.00  |__applet.py
03:54:26 PM  1000       990         -      0.00      0.00  applet.py
03:54:26 PM  1000         -       990      0.00      0.00  |__applet.py
03:54:28 PM  1000       990         -      0.00      0.00  applet.py
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;mpstat&#34;&gt;mpstat&lt;/h4&gt;
&lt;p&gt;mpstat命令指令主要用于多CPU环境下，它显示各个可用CPU的状态。这些信息存放在&lt;code&gt;/proc/stat&lt;/code&gt;文件中。在多CPUs系统里，其不但能查看所有CPU的平均状况信息，而且能够查看特定CPU的信息。&lt;/p&gt;
&lt;h5 id=&#34;1_4&#34;&gt;1. 指标详解&lt;/h5&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;mpstat
Linux 4.19.0-17-amd64 (debian)  08/23/2021      _x86_64_        (2 CPU)

09:39:48 AM  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle
09:39:48 AM  all    0.18    0.00    0.64    0.08    0.00    0.14    0.00    0.00    0.00   98.95
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;统计信息&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;CPU&lt;/td&gt;
&lt;td&gt;处理器编号。关键字all表示统计信息计算为所有处理器之间的平均值。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%usr&lt;/td&gt;
&lt;td&gt;显示在用户级（应用程序）执行时发生的CPU利用率百分比。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%nice&lt;/td&gt;
&lt;td&gt;显示以优先级较高的用户级别执行时发生的CPU利用率百分比。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%sys&lt;/td&gt;
&lt;td&gt;显示在系统级（内核）执行时发生的CPU利用率百分比。请注意，这不包括维护硬件和软件的时间中断。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%iowait&lt;/td&gt;
&lt;td&gt;显示系统具有未完成磁盘I / O请求的CPU或CPU空闲的时间百分比。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%irq&lt;/td&gt;
&lt;td&gt;显示CPU或CPU用于服务硬件中断的时间百分比。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%soft&lt;/td&gt;
&lt;td&gt;显示CPU或CPU用于服务软件中断的时间百分比。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%steal&lt;/td&gt;
&lt;td&gt;显示虚拟CPU或CPU在管理程序为另一个虚拟处理器提供服务时非自愿等待的时间百分比。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%guest&lt;/td&gt;
&lt;td&gt;显示CPU或CPU运行虚拟处理器所花费的时间百分比。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%gnice&lt;/td&gt;
&lt;td&gt;显示CPU或CPU运行niced客户机所花费的时间百分比。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%idle&lt;/td&gt;
&lt;td&gt;显示CPU或CPU空闲且系统没有未完成的磁盘I / O请求的时间百分比。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h5 id=&#34;2_2&#34;&gt;2. 常用参数&lt;/h5&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;选项&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;-P&lt;/td&gt;
&lt;td&gt;指定CPU编号&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;每2秒产生一个报告，总共产生3个。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;mpstat -P ALL 2 3
Linux 5.10.0-8-amd64 (debian)   08/19/2021      _x86_64_        (2 CPU)

04:29:11 PM  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle
04:29:13 PM  all    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00
04:29:13 PM    0    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00
04:29:13 PM    1    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00

04:29:13 PM  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle
04:29:15 PM  all    0.00    0.00    0.25    0.00    0.00    0.00    0.00    0.00    0.00   99.75
04:29:15 PM    0    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00
04:29:15 PM    1    0.00    0.00    0.50    0.00    0.00    0.00    0.00    0.00    0.00   99.50

04:29:15 PM  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle
04:29:17 PM  all    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00
04:29:17 PM    0    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00
04:29:17 PM    1    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00

Average:     CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle
Average:     all    0.00    0.00    0.08    0.00    0.00    0.00    0.00    0.00    0.00   99.92
Average:       0    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00
Average:       1    0.00    0.00    0.17    0.00    0.00    0.00    0.00    0.00    0.00   99.83
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;iostat&#34;&gt;iostat&lt;/h4&gt;
&lt;p&gt;iostat命令被用于监视系统输入输出设备和CPU的使用情况。它的特点是汇报磁盘活动统计情况，同时也会汇报出CPU使用情况。&lt;/p&gt;
&lt;h5 id=&#34;1_5&#34;&gt;1. 指标详解&lt;/h5&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;iostat
Linux 5.10.0-8-amd64 (debian)   08/19/2021      _x86_64_        (2 CPU)

avg-cpu:  %user   %nice %system %iowait  %steal   %idle
           0.47    0.00    0.69    0.26    0.00   98.58

Device             tps    kB_read/s    kB_wrtn/s    kB_dscd/s    kB_read    kB_wrtn    kB_dscd
sda              11.54       409.15        68.23         0.00     432195      72072          0
sr0               0.01         0.00         0.00         0.00          2          0          0
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;标示&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Device&lt;/td&gt;
&lt;td&gt;监测设备名称&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;rrqm/s&lt;/td&gt;
&lt;td&gt;每秒需要读取需求的数量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;wrqm/s&lt;/td&gt;
&lt;td&gt;每秒需要写入需求的数量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;r/s&lt;/td&gt;
&lt;td&gt;每秒实际读取需求的数量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;http://man.linuxde.net/w&#34;&gt;w&lt;/a&gt;/s&lt;/td&gt;
&lt;td&gt;每秒实际写入需求的数量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;rsec/s&lt;/td&gt;
&lt;td&gt;每秒读取区段的数量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;wsec/s&lt;/td&gt;
&lt;td&gt;每秒写入区段的数量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;rkB/s&lt;/td&gt;
&lt;td&gt;每秒实际读取的大小，单位为KB&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;wkB/s&lt;/td&gt;
&lt;td&gt;每秒实际写入的大小，单位为KB&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;avgrq-sz&lt;/td&gt;
&lt;td&gt;需求的平均大小区段&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;avgqu-sz&lt;/td&gt;
&lt;td&gt;需求的平均队列长度&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;await&lt;/td&gt;
&lt;td&gt;等待I/O平均的时间（milliseconds）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;svctm&lt;/td&gt;
&lt;td&gt;I/O需求完成的平均时间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%util&lt;/td&gt;
&lt;td&gt;被I/O需求消耗的CPU百分比&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h5 id=&#34;2_3&#34;&gt;2. 常用参数&lt;/h5&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;参数&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;-c&lt;/td&gt;
&lt;td&gt;仅显示CPU使用情况&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-d&lt;/td&gt;
&lt;td&gt;仅显示设备利用率&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-k&lt;/td&gt;
&lt;td&gt;显示状态以千字节每秒为单位，而不使用块每秒&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-m&lt;/td&gt;
&lt;td&gt;显示状态以兆字节每秒为单位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-p&lt;/td&gt;
&lt;td&gt;仅显示块设备和所有被使用的其他分区的状态&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-t&lt;/td&gt;
&lt;td&gt;显示每个报告产生时的时间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-V&lt;/td&gt;
&lt;td&gt;显示版号并退出&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-x&lt;/td&gt;
&lt;td&gt;显示扩展状态&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;1秒展示一次结果&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;iostat -x 1
Linux 5.10.0-8-amd64 (debian)   08/19/2021      _x86_64_        (2 CPU)

avg-cpu:  %user   %nice %system %iowait  %steal   %idle
           0.47    0.00    0.68    0.25    0.00   98.59

Device            r/s     rkB/s   rrqm/s  %rrqm r_await rareq-sz     w/s     wkB/s   wrqm/s  %wrqm w_await wareq-sz     d/s     dkB/s   drqm/s  %drqm d_await dareq-sz     f/s f_await  aqu-sz  %util
sda              8.89    401.89     4.48  33.50    0.42    45.19    2.49     67.36     1.65  39.94    0.92    27.08    0.00      0.00     0.00   0.00    0.00     0.00    0.00    0.00    0.01   0.91
sr0              0.01      0.00     0.00   0.00    1.40     0.20    0.00      0.00     0.00   0.00    0.00     0.00    0.00      0.00     0.00   0.00    0.00     0.00    0.00    0.00    0.00   0.00
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;dstat&#34;&gt;dstat&lt;/h4&gt;
&lt;p&gt;dstat命令是一个用来替换vmstat、iostat、netstat、nfsstat和ifstat这些命令的工具，是一个全能系统信息统计工具。与sysstat相比，dstat拥有一个彩色的界面，在手动观察性能状况时，数据比较显眼容易观察；而且dstat支持即时刷新，譬如输入&lt;code&gt;dstat 3 5&lt;/code&gt;即每三秒收集一次，共收集5次，但最新的数据都会每秒刷新显示。和sysstat相同的是，dstat也可以收集指定的性能资源，譬如&lt;code&gt;dstat -c&lt;/code&gt;即显示CPU的使用情况。&lt;/p&gt;
&lt;h5 id=&#34;1_6&#34;&gt;1. 指标详解&lt;/h5&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;dstat
----total-cpu-usage---- -dsk/total- -net/total- ---paging-- ---system--
usr sys idl wai hiq siq| read  writ| recv  send|  in   out | int   csw
  0   0  99   0   0   0|7706B  164k|   0     0 |   0     0 | 189   225
  0   0 100   0   0   0|   0     0 |4436B  826B|   0     0 | 195   248
  1   0  99   0   0   0|   0     0 |4744B  346B|   0     0 | 203   242
  0   0 100   0   0   0|   0     0 |5080B  346B|   0     0 | 206   242
  0   1  99   0   0   0|   0     0 |5458B  444B|   0     0 | 214   244
  1   0  99   0   0   0|   0     0 |5080B  346B|   0     0 | 208   242
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;分组&lt;/th&gt;
&lt;th&gt;分组含义及子项字段含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;CPU状态&lt;/td&gt;
&lt;td&gt;CPU的使用率。显示了用户占比，系统占比、空闲占比、等待占比、硬中断和软中断情况。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;磁盘统计&lt;/td&gt;
&lt;td&gt;磁盘的读写，分别显示磁盘的读、写总数。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;网络统计&lt;/td&gt;
&lt;td&gt;网络设备发送和接受的数据，分别显示的网络收、发数据总数。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;分页统计&lt;/td&gt;
&lt;td&gt;系统的分页活动。分别显示换入（in）和换出（out）。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;系统统计&lt;/td&gt;
&lt;td&gt;统计中断（int）和上下文切换（csw）。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h5 id=&#34;2_4&#34;&gt;2. 常用参数&lt;/h5&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;参数&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;-c&lt;/td&gt;
&lt;td&gt;显示CPU系统占用，用户占用，空闲，等待，中断，软件中断等信息。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-C&lt;/td&gt;
&lt;td&gt;当有多个CPU时候，此参数可按需分别显示cpu状态，例：-C 0,1 是显示cpu0和cpu1的信息。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-d&lt;/td&gt;
&lt;td&gt;显示磁盘读写数据大小。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-D hda,total&lt;/td&gt;
&lt;td&gt;include hda and total。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-n&lt;/td&gt;
&lt;td&gt;显示网络状态。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-N eth1,total&lt;/td&gt;
&lt;td&gt;有多块网卡时，指定要显示的网卡。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-l&lt;/td&gt;
&lt;td&gt;显示系统负载情况。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-m&lt;/td&gt;
&lt;td&gt;显示内存使用情况。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-g&lt;/td&gt;
&lt;td&gt;显示页面使用情况。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-p&lt;/td&gt;
&lt;td&gt;显示进程状态。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-s&lt;/td&gt;
&lt;td&gt;显示交换分区使用情况。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-S&lt;/td&gt;
&lt;td&gt;类似D/N。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-r&lt;/td&gt;
&lt;td&gt;I/O请求情况。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-y&lt;/td&gt;
&lt;td&gt;系统状态。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;--ipc&lt;/td&gt;
&lt;td&gt;显示ipc消息队列，信号等信息。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;--socket&lt;/td&gt;
&lt;td&gt;用来显示tcp udp端口状态。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-a&lt;/td&gt;
&lt;td&gt;此为默认选项，等同于-cdngy。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-v&lt;/td&gt;
&lt;td&gt;等同于 -pmgdsc -D total。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;--output 文件&lt;/td&gt;
&lt;td&gt;此选项也比较有用，可以把状态信息以csv的格式重定向到指定的文件中，以便日后查看。例：dstat --output /root/dstat.csv &amp;amp; 此时让程序默默的在后台运行并把结果输出到/root/dstat.csv文件中。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;如想监控swap，process，sockets，filesystem并显示监控的时间：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;dstat -tsp --socket --fs
----system---- ----swap--- ---procs--- ------sockets------ --filesystem-
  date/time   | used  free|run blk new|tot tcp udp raw frg|files  inodes
26-07 09:23:48|   0     0 |  0   0 0.0|104   8   5   0   0|  704   6488
26-07 09:23:49|   0     0 |  0   0   0|104   8   5   0   0|  704   6488
26-07 09:23:50|   0     0 |  0   0   0|104   8   5   0   0|  704   6489
26-07 09:23:51|   0     0 |  0   0   0|104   8   5   0   0|  704   6489
26-07 09:23:52|   0     0 |  0   0   0|104   8   5   0   0|  704   6489
26-07 09:23:53|   0     0 |  0   0   0|104   8   5   0   0|  704   6489
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;若要将结果输出到文件可以加&lt;code&gt;--output filename&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;dstat -tsp --socket --fs --output /tmp/ds.csv
----system---- ----swap--- ---procs--- ------sockets------ --filesystem-
  date/time   | used  free|run blk new|tot tcp udp raw frg|files  inodes
26-07 09:25:31|   0     0 |  0   0 0.0|104   8   5   0   0|  736   6493
26-07 09:25:32|   0     0 |  0   0   0|104   8   5   0   0|  736   6493
26-07 09:25:33|   0     0 |  0   0   0|104   8   5   0   0|  736   6493
26-07 09:25:34|   0     0 |  0   0   0|104   8   5   0   0|  736   6493
26-07 09:25:35|   0     0 |  0   0   0|104   8   5   0   0|  736   6494
26-07 09:25:36|   0     0 |  0   0   0|104   8   5   0   0|  736   6494
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过&lt;code&gt;dstat --list&lt;/code&gt;可以查看dstat能使用的所有参数，其中上面internal是dstat本身自带的一些监控参数，下面&lt;code&gt;/usr/share/dstat&lt;/code&gt;中是dstat的插件，这些插件可以扩展dstat的功能，如可以监控电源（battery）、mysql等。&lt;/p&gt;
&lt;p&gt;下面这些插件并不是都可以直接使用的，有的还依赖其他包，如想监控mysql，必须要装python连接mysql的一些包。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;dstat --list
internal:
        aio, cpu, cpu24, disk, disk24, disk24old, epoch, fs, int, int24, io, ipc, load, lock, mem, net, page, page24, proc, raw, socket, swap, swapold, sys, tcp, time, udp, unix, vm
/usr/share/dstat:
        battery, battery-remain, cpufreq, dbus, disk-util, fan, freespace, gpfs, gpfs-ops, helloworld, innodb-buffer, innodb-io, innodb-ops, lustre, memcache-hits, mysql-io, mysql-keys, mysql5-cmds, mysql5-conn, mysql5-io, mysql5-keys,
        net-packets, nfs3, nfs3-ops, nfsd3, nfsd3-ops, ntp, postfix, power, proc-count, rpc, rpcd, sendmail, snooze, thermal, top-bio, top-cpu, top-cputime, top-cputime-avg, top-io, top-latency, top-latency-avg, top-mem, top-oom, utmp,
        vm-memctl, vmk-hba, vmk-int, vmk-nic, vz-cpu, vz-io, vz-ubc, wifi
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;free&#34;&gt;free&lt;/h4&gt;
&lt;p&gt;free命令可以显示当前系统未使用的和已使用的内存数目，还可以显示被内核使用的内存缓冲区。&lt;/p&gt;
&lt;h5 id=&#34;1_7&#34;&gt;1. 指标详解&lt;/h5&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;free
               total        used        free      shared  buff/cache   available
Mem:         3993720      549132     2950872       12320      493716     3201568
Swap:         998396           0      998396
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;统计信息&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;total&lt;/td&gt;
&lt;td&gt;总内存大小&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;used&lt;/td&gt;
&lt;td&gt;已使用内存的大小，包含了共享内存&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;free&lt;/td&gt;
&lt;td&gt;未使用内存的大小&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;shared&lt;/td&gt;
&lt;td&gt;共享内存的大小&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;buff/cache&lt;/td&gt;
&lt;td&gt;缓存和缓冲区的大小&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;available&lt;/td&gt;
&lt;td&gt;新进程可用内存的大小；不仅包含未使用内存，还包括了可回收的缓存，所以一般会比未使用内存更大。不过，并不是所有缓存都可以回收，因为有些缓存可能正在使用中&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h5 id=&#34;2-free&#34;&gt;2. free命令的一些用法&lt;/h5&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;free -m
              total        used        free      shared  buff/cache   available
Mem:           1970         105        1770           3          94        1743
Swap:           974           0         974
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;perf&#34;&gt;perf&lt;/h4&gt;
&lt;p&gt;perf是一款Linux性能分析工具。Linux性能计数器是一个新的基于内核的子系统，它提供一个性能分析框架，比如硬件（CPU、PMU(Performance Monitoring Unit)）功能和软件(软件计数器、tracepoint)功能。&lt;/p&gt;
&lt;h5 id=&#34;1-perf&#34;&gt;1. perf命令&lt;/h5&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;序号&lt;/th&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;annotate&lt;/td&gt;
&lt;td&gt;解析perf record生成的perf.data文件，显示被注释的代码。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;archive&lt;/td&gt;
&lt;td&gt;根据数据文件记录的build-id，将所有被采样到的elf文件打包。利用此压缩包，可以再任何机器上分析数据文件中记录的采样数据。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;bench&lt;/td&gt;
&lt;td&gt;perf中内置的benchmark，目前包括两套针对调度器和内存管理子系统的benchmark。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;buildid-cache&lt;/td&gt;
&lt;td&gt;管理perf的buildid缓存，每个elf文件都有一个独一无二的buildid。buildid被perf用来关联性能数据与elf文件。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;buildid-list&lt;/td&gt;
&lt;td&gt;列出数据文件中记录的所有buildid。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;diff&lt;/td&gt;
&lt;td&gt;对比两个数据文件的差异。能够给出每个符号（函数）在热点分析上的具体差异。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;evlist&lt;/td&gt;
&lt;td&gt;列出数据文件perf.data中所有性能事件。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;inject&lt;/td&gt;
&lt;td&gt;该工具读取perf record工具记录的事件流，并将其定向到标准输出。在被分析代码中的任何一点，都可以向事件流中注入其它事件。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;kmem&lt;/td&gt;
&lt;td&gt;针对内核内存（slab）子系统进行追踪测量的工具&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;kvm&lt;/td&gt;
&lt;td&gt;用来追踪测试运行在KVM虚拟机上的Guest OS。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;11&lt;/td&gt;
&lt;td&gt;list&lt;/td&gt;
&lt;td&gt;列出当前系统支持的所有性能事件。包括硬件性能事件、软件性能事件以及检查点。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;12&lt;/td&gt;
&lt;td&gt;lock&lt;/td&gt;
&lt;td&gt;分析内核中的锁信息，包括锁的争用情况，等待延迟等。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;13&lt;/td&gt;
&lt;td&gt;mem&lt;/td&gt;
&lt;td&gt;内存存取情况&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;14&lt;/td&gt;
&lt;td&gt;record&lt;/td&gt;
&lt;td&gt;收集采样信息，并将其记录在数据文件中。随后可通过其它工具对数据文件进行分析。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;15&lt;/td&gt;
&lt;td&gt;report&lt;/td&gt;
&lt;td&gt;读取perf record创建的数据文件，并给出热点分析结果。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;16&lt;/td&gt;
&lt;td&gt;sched&lt;/td&gt;
&lt;td&gt;针对调度器子系统的分析工具。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;17&lt;/td&gt;
&lt;td&gt;script&lt;/td&gt;
&lt;td&gt;执行perl或python写的功能扩展脚本、生成脚本框架、读取数据文件中的数据信息等。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;18&lt;/td&gt;
&lt;td&gt;stat&lt;/td&gt;
&lt;td&gt;执行某个命令，收集特定进程的性能概况，包括CPI、Cache丢失率等。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;19&lt;/td&gt;
&lt;td&gt;test&lt;/td&gt;
&lt;td&gt;perf对当前软硬件平台进行健全性测试，可用此工具测试当前的软硬件平台是否能支持perf的所有功能。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;20&lt;/td&gt;
&lt;td&gt;timechart&lt;/td&gt;
&lt;td&gt;针对测试期间系统行为进行可视化的工具&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;21&lt;/td&gt;
&lt;td&gt;top&lt;/td&gt;
&lt;td&gt;类似于linux的top命令，对系统性能进行实时分析。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;22&lt;/td&gt;
&lt;td&gt;trace&lt;/td&gt;
&lt;td&gt;关于syscall的工具。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;23&lt;/td&gt;
&lt;td&gt;probe&lt;/td&gt;
&lt;td&gt;用于定义动态检查点。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h5 id=&#34;2_5&#34;&gt;2. 全局性概况&lt;/h5&gt;
&lt;blockquote&gt;
&lt;p&gt;perf list查看当前系统支持的性能事件；&lt;/p&gt;
&lt;p&gt;perf bench对系统性能进行摸底；&lt;/p&gt;
&lt;p&gt;perf test对系统进行健全性测试；&lt;/p&gt;
&lt;p&gt;perf stat对全局性能进行统计；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;全局细节：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;perf top可以实时查看当前系统进程函数占用率情况；&lt;/p&gt;
&lt;p&gt;perf probe可以自定义动态事件；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;特定功能分析：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;perf kmem针对slab子系统性能分析；&lt;/p&gt;
&lt;p&gt;perf kvm针对kvm虚拟化分析；&lt;/p&gt;
&lt;p&gt;perf lock分析锁性能；&lt;/p&gt;
&lt;p&gt;perf mem分析内存slab性能；&lt;/p&gt;
&lt;p&gt;perf sched分析内核调度器性能；&lt;/p&gt;
&lt;p&gt;perf trace记录系统调用轨迹；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最常用功能perf record，可以系统全局，也可以具体到某个进程，更甚具体到某一进程某一事件；可宏观，也可以很微观。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;pref record记录信息到perf.data；&lt;/p&gt;
&lt;p&gt;perf report生成报告；&lt;/p&gt;
&lt;p&gt;perf diff对两个记录进行diff；&lt;/p&gt;
&lt;p&gt;perf evlist列出记录的性能事件；&lt;/p&gt;
&lt;p&gt;perf annotate显示perf.data函数代码；&lt;/p&gt;
&lt;p&gt;perf archive将相关符号打包，方便在其它机器进行分析；&lt;/p&gt;
&lt;p&gt;perf script将perf.data输出可读性文本；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可视化工具perf timechart&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;perf timechart record记录事件；&lt;/p&gt;
&lt;p&gt;perf timechart生成output.svg文档；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&#34;3&#34;&gt;3. 常用命令&lt;/h5&gt;
&lt;blockquote&gt;
&lt;p&gt;pef bench: perf中内置的benchmark，目前包括两套针对调度器和内存管理子系统的benchmark。&lt;/p&gt;
&lt;p&gt;pef list: 列出当前系统支持的所有性能事件。包括硬件性能事件、软件性能事件以及检查点。&lt;/p&gt;
&lt;p&gt;pef record: 收集采样信息，并将其记录在数据文件中。随后可通过其它工具对数据文件进行分析。&lt;/p&gt;
&lt;p&gt;pef report: 读取perf record创建的数据文件，并给出热点分析结果。&lt;/p&gt;
&lt;p&gt;pef sched: 针对调度器子系统的分析工具。&lt;/p&gt;
&lt;p&gt;pef stat: 执行某个命令，收集特定进程的性能概况，包括CPI、Cache丢失率等。&lt;/p&gt;
&lt;p&gt;pef timechart: 针对测试期间系统行为进行可视化的工具&lt;/p&gt;
&lt;p&gt;pef top: 类似于linux的top命令，对系统性能进行实时分析。&lt;/p&gt;
&lt;p&gt;pef trace: 关于syscall的工具。&lt;/p&gt;
&lt;p&gt;pef probe: 用于定义动态检查点。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;sar&#34;&gt;sar&lt;/h4&gt;
&lt;p&gt;sar命令是Linux下系统运行状态统计工具，它将指定的操作系统状态计数器显示到标准输出设备。sar工具将对系统当前的状态进行取样，然后通过计算数据和比例来表达系统的当前运行状态。它的特点是可以连续对系统取样，获得大量的取样数据。取样数据和分析的结果都可以存入文件，使用它时消耗的系统资源很小。&lt;/p&gt;
&lt;h5 id=&#34;1_8&#34;&gt;1. 指标详解&lt;/h5&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;sar -u 1 3
Linux 4.19.0-17-amd64 (debian)  08/23/2021      _x86_64_        (2 CPU)

10:07:35 AM     CPU     %user     %nice   %system   %iowait    %steal     %idle
10:07:36 AM     all      0.00      0.00      0.51      0.00      0.00     99.49
10:07:37 AM     all      0.50      0.00      0.00      0.50      0.00     98.99
10:07:38 AM     all      0.00      0.00      0.00      0.00      0.00    100.00
Average:        all      0.17      0.00      0.17      0.17      0.00     99.50
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;统计信息&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;%user&lt;/td&gt;
&lt;td&gt;用户空间的CPU使用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%nice&lt;/td&gt;
&lt;td&gt;改变过优先级的进程的CPU使用率&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%system&lt;/td&gt;
&lt;td&gt;内核空间的CPU使用率&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%iowait&lt;/td&gt;
&lt;td&gt;CPU等待IO的百分比&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%steal&lt;/td&gt;
&lt;td&gt;虚拟机的虚拟机CPU使用的CPU&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%idle&lt;/td&gt;
&lt;td&gt;空闲的CPU&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h5 id=&#34;2_6&#34;&gt;2. 常用参数&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;选项&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;选项&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;-A&lt;/td&gt;
&lt;td&gt;显示所有的报告信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-b&lt;/td&gt;
&lt;td&gt;显示I/O速率&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-B&lt;/td&gt;
&lt;td&gt;显示换页状态&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-c&lt;/td&gt;
&lt;td&gt;显示进程创建活动&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-d&lt;/td&gt;
&lt;td&gt;显示每个块设备的状态&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-e&lt;/td&gt;
&lt;td&gt;设置显示报告的结束时间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-f&lt;/td&gt;
&lt;td&gt;从指定文件提取报告&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-i&lt;/td&gt;
&lt;td&gt;设状态信息刷新的间隔时间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-P&lt;/td&gt;
&lt;td&gt;报告每个CPU的状态&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-R&lt;/td&gt;
&lt;td&gt;显示内存状态&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-u&lt;/td&gt;
&lt;td&gt;显示CPU利用率&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-v&lt;/td&gt;
&lt;td&gt;显示索引节点，文件和其他内核表的状态&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-w&lt;/td&gt;
&lt;td&gt;显示交换分区状态&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-x&lt;/td&gt;
&lt;td&gt;显示给定进程的状态&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;参数&lt;/li&gt;
&lt;li&gt;间隔时间：每次报告的间隔时间（秒）；&lt;/li&gt;
&lt;li&gt;次数：显示报告的次数。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;execsnoop&#34;&gt;execsnoop&lt;/h4&gt;
&lt;p&gt;execsnoop-专门用于为追踪短时进程（瞬时进程）设计的工具；它通过 ftrace 实时监控进程的 exec() 行为，并输出短时进程的基本信息，包括进程 PID、父进程 PID、命令行参数以及执行的结果。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;#./execsnoop
59187  59186 /usr/local/bin/stress -t 1 -d 1
59188  28775            &amp;lt;...&amp;gt;-59188 [000] d... 40067.137167: execsnoop_sys_execve: (SyS_execve+0x0/0x30)
59191  59188 /usr/local/bin/stress -t 1 -d 1
59190  28778            &amp;lt;...&amp;gt;-59190 [003] d... 40067.138913: execsnoop_sys_execve: (SyS_execve+0x0/0x30)
59192  28776            &amp;lt;...&amp;gt;-59192 [003] d... 40067.139103: execsnoop_sys_execve: (SyS_execve+0x0/0x30)
59194  59192 /usr/local/bin/stress -t 1 -d 1
59196  59190 /usr/local/bin/stress -t 1 -d 1
59198  28770            &amp;lt;...&amp;gt;-59198 [001] d... 40067.145500: execsnoop_sys_execve: (SyS_execve+0x0/0x30)
59199  28779            &amp;lt;...&amp;gt;-59199 [001] d... 40067.146228: execsnoop_sys_execve: (SyS_execve+0x0/0x30)
59200  59198 /usr/local/bin/stress -t 1 -d 1
59202  59199 /usr/local/bin/stress -t 1 -d 1
59204  28778            &amp;lt;...&amp;gt;-59204 [002] d... 40067.155150: execsnoop_sys_execve: (SyS_execve+0x0/0x30)
59206  28775            &amp;lt;...&amp;gt;-59206 [001] d... 40067.157282: execsnoop_sys_execve: (SyS_execve+0x0/0x30)
59208  59206 /usr/local/bin/stress -t 1 -d 1
59209  28770            &amp;lt;...&amp;gt;-59209 [003] d... 40067.158381: execsnoop_sys_execve: (SyS_execve+0x0/0x30)
59205  59204 /usr/local/bin/stress -t 1 -d 1
59207  28776            &amp;lt;...&amp;gt;-59207 [002] d... 40067.158882: execsnoop_sys_execve: (SyS_execve+0x0/0x30)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到有大量的stress进程，不断的在启用，造成系统的负载和CPU使用率升高。&lt;/p&gt;
&lt;h4 id=&#34;atop&#34;&gt;atop&lt;/h4&gt;
&lt;p&gt;ATOP是一款用于观察Linux性能的ASCII全屏交互式工具。类似于top,每隔一段时间报告 &lt;code&gt;CPU，Memory，Disk，Network&lt;/code&gt; 等硬件的性能信息，对于严重过载的资源会高亮显示。 除此之外，还包括进程级的相关统计信息。比如进程的CPU、内存、磁盘利用率，用户名，进程状态，启动时间，进程ID等。对于在上一个周期内退出的进程还会显示退出状态码。所有进程信息默认按CPU占用率降序排列。&lt;/p&gt;
&lt;h5 id=&#34;1_9&#34;&gt;1. 指标详解&lt;/h5&gt;
&lt;p&gt;使用&lt;code&gt;atop&lt;/code&gt;就可以直接进行交互模式，默认情况下是每10秒更新，分别显示了进程数量、CPU使用率、负载、内存、SWAP、磁盘以及网卡等信息，所有的信息都在同一行上面展示。&lt;/p&gt;
&lt;h5 id=&#34;2-atop&#34;&gt;2. atop命令的一些用法&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;有如下模式：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;按 g 进入默认模式&lt;/li&gt;
&lt;li&gt;按 m 进入内存模式，详细显示子进程的内存使用的情况&lt;/li&gt;
&lt;li&gt;按 d 进入磁盘模式，详细显示子进程的磁盘读写的情况&lt;/li&gt;
&lt;li&gt;按 p 进入进程模式，显示进程所占用的数量、CPU、内存、磁盘读写，可以用来快速定位有异常的进程&lt;/li&gt;
&lt;li&gt;按 c 进入命令视图，该视图展示了与每个进程相对应的命令。&lt;/li&gt;
&lt;li&gt;按 u 查看用户占用资源情况&lt;/li&gt;
&lt;li&gt;按 P（大写）正则匹配，显示所有匹配到的进程&lt;/li&gt;
&lt;li&gt;按 n 进入&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;排序命令：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;大写C，CPU排序&lt;/li&gt;
&lt;li&gt;大写M，内存排序&lt;/li&gt;
&lt;li&gt;大写D，磁盘排序&lt;/li&gt;
&lt;li&gt;大写A，智能排序&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;查看历史：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;atop -b 15:30 -e 21:00 -r atop_20210822&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;htop&#34;&gt;htop&lt;/h4&gt;
&lt;p&gt;htop是Linux系统下一个基本文本模式的、交互式的进程查看器，主要用于控制台或shell中，可以替代top，或者说是top的高级版。&lt;/p&gt;
&lt;h5 id=&#34;1-htop&#34;&gt;1. htop命令优点&lt;/h5&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-undefined&#34;&gt;1) 快速查看关键性能统计数据，如CPU（多核布局）、内存/交换使用；
2) 可以横向或纵向滚动浏览进程列表，以查看所有的进程和完整的命令行；
3) 杀掉进程时可以直接选择而不需要输入进程号；
4) 通过鼠标操作条目；
5) 比top启动得更快
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;2-htop&#34;&gt;2. htop常用功能键&lt;/h5&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;F1 : 查看htop使用说明
F2 : 设置
F3 : 搜索进程
F4 : 过滤器，按关键字搜索
F5 : 显示树形结构
F6 : 选择排序方式
F7 : 减少nice值，这样就可以提高对应进程的优先级
F8 : 增加nice值，这样可以降低对应进程的优先级
F9 : 杀掉选中的进程
F10 : 退出htop

/ : 搜索字符
h : 显示帮助
l ：显示进程打开的文件: 如果安装了lsof，按此键可以显示进程所打开的文件
u ：显示所有用户，并可以选择某一特定用户的进程
s : 将调用strace追踪进程的系统调用
t : 显示树形结构

H ：显示/隐藏用户线程
I ：倒转排序顺序
K ：显示/隐藏内核线程    
M ：按内存占用排序
P ：按CPU排序    
T ：按运行时间排序

上下键或PgUP, PgDn : 移动选中进程
左右键或Home, End : 移动列表    
Space(空格) : 标记/取消标记一个进程。命令可以作用于多个进程，例如 &amp;quot;kill&amp;quot;，将应用于所有已标记的进程
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;3_1&#34;&gt;3. 指标详解&lt;/h5&gt;
&lt;p&gt;最上面的三行，1~2 表示的是CPU的核数，本文中CPU是2核的。
然后下面左边部分从上至下，分别为，内存、交换分区的使用情况
右边部分为：Tasks为进程总数，当前运行的进程数、Load average为系统1分钟，5分钟，10分钟的平均负载情况、Uptime为系统运行的时间。&lt;/p&gt;
&lt;p&gt;指标区各指标解释：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;PID：进行的标识号
USER：运行此进程的用户
PRI：进程的优先级
NI：进程的优先级别值，默认的为0，可以进行调整
VIRT：进程占用的虚拟内存值
RES：进程占用的物理内存值
SHR：进程占用的共享内存值
S：进程的运行状况，R表示正在运行、S表示休眠，等待唤醒、Z表示僵死状态
%CPU：该进程占用的CPU使用率
%MEM：该进程占用的物理内存和总内存的百分比
TIME+：该进程启动后占用的总的CPU时间
COMMAND：进程启动的启动命令名
&lt;/code&gt;&lt;/pre&gt;</description>  
      <pubDate>2025-10-09 17:54:40</pubDate>  
      <link>https://testpoo.github.io/性能监控各指令详解.html</link>  
      <guid isPermaLink="true">https://testpoo.github.io/性能监控各指令详解.html</guid>
       
      <category>测试</category> 
      
    </item>
    
    <item> 
      <title>Python进阶</title>  
      <description>&lt;div class=&#34;toc&#34;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#argskwargs&#34;&gt;*args和**kwargs&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#args&#34;&gt;*args&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#kwargs&#34;&gt;**kwargs的用法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#argskwargs_1&#34;&gt;使用*args和**kwargs来调用函数&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#debugging&#34;&gt;调试Debugging&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#_1&#34;&gt;从命令运行&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_2&#34;&gt;从脚本内部运行&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#generators&#34;&gt;生成器Generators&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#iterable&#34;&gt;可迭代对象（Iterable）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#iterator&#34;&gt;迭代器（Iterator）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#iteration&#34;&gt;迭代（Iteration）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#generators_1&#34;&gt;生成器（Generators）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#mapfilterreduce&#34;&gt;Map，Filter和Reduce&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#map&#34;&gt;Map&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#filter&#34;&gt;Filter&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#reduce&#34;&gt;Reduce&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#set&#34;&gt;set（集合）数据结构&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#set_1&#34;&gt;set&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_3&#34;&gt;交集&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_4&#34;&gt;差集&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_5&#34;&gt;三元运算符&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_6&#34;&gt;装饰器&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#_7&#34;&gt;第一个装饰器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_8&#34;&gt;使用场景&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_9&#34;&gt;带参数的装饰器&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#globalreturn&#34;&gt;Global和Return&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#return&#34;&gt;多个return值&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#mutation&#34;&gt;对象变动（Mutation)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#__slots__&#34;&gt;__slots__魔法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_10&#34;&gt;虚拟环境&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#virtualenv&#34;&gt;virtualenv&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#collections&#34;&gt;容器Collections&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#defaultdict&#34;&gt;defaultdict&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#counter&#34;&gt;Counter&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#deque&#34;&gt;deque&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#namedtuple&#34;&gt;namedtuple&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#enumenum&#34;&gt;enum.Enum&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#enumerate&#34;&gt;枚举Enumerate&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_11&#34;&gt;对象自省&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#dir&#34;&gt;dir&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#typeid&#34;&gt;type和id&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#inspect&#34;&gt;inspect模块&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#comprehension&#34;&gt;推导式Comprehension&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#_12&#34;&gt;列表推导式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_13&#34;&gt;字典推导式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_14&#34;&gt;集合推导式&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_15&#34;&gt;异常&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#_16&#34;&gt;处理多个异常&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#finally&#34;&gt;finally从句&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#tryelse&#34;&gt;try/else从句&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#lambda&#34;&gt;lambda表达式&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h3 id=&#34;argskwargs&#34;&gt;&lt;code&gt;*args&lt;/code&gt;和&lt;code&gt;**kwargs&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;大部分人学习Python，很多时间都搞不清楚&lt;code&gt;*args&lt;/code&gt;和&lt;code&gt;**kwargs&lt;/code&gt;这两个变量。其实这两个变量并不是必须写&lt;code&gt;*args&lt;/code&gt;和&lt;code&gt;**kwargs&lt;/code&gt;。只要变量前面的&lt;code&gt;*&lt;/code&gt;才是必须的。你也可以写成&lt;code&gt;*var&lt;/code&gt;和&lt;code&gt;**vars&lt;/code&gt;。写成&lt;code&gt;*args&lt;/code&gt;和&lt;code&gt;**kwargs&lt;/code&gt;只是一个通俗的命名约定。&lt;/p&gt;
&lt;h4 id=&#34;args&#34;&gt;&lt;code&gt;*args&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;*args&lt;/code&gt;和&lt;code&gt;**kwargs&lt;/code&gt;主要用于函数定义。你可以将不定数量的参数传递给一个函数。这里的不定的意思是：预先并不知道，函数使用者会传递多少个参数给你，所以在这个场景下使用这两个关键字。&lt;code&gt;*args&lt;/code&gt;是用来发送一个非键值对的可变数量的参数列表给一个函数。例如：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;def test_var_args(f_arg, *args):
    print(&amp;quot;第一个普通的参数：&amp;quot;, f_arg)
    for arg in args:
        print(&amp;quot;另外一些通过*argv传递的参数:&amp;quot;, arg)

test_var_args(&#39;苹果&#39;,&#39;香蕉&#39;,&#39;梨子&#39;,&#39;葡萄&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;第一个普通的参数： 苹果
另外一些通过*argv传递的参数: 香蕉
另外一些通过*argv传递的参数: 梨子
另外一些通过*argv传递的参数: 葡萄
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;kwargs&#34;&gt;&lt;code&gt;**kwargs&lt;/code&gt;的用法&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;**kwargs&lt;/code&gt;允许你将不定长度的键值对，作为参数传递给一个函数。如果你想要在一个函数里处理带名字的参数，你应该使用&lt;code&gt;**kwargs&lt;/code&gt;。例如：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;def greet_me(**kwargs):
    for key, value in kwargs.items():
        print(&amp;quot;{0} == {1}&amp;quot;.format(key, value))

greet_me(name=&amp;quot;苹果&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;name == 苹果
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在可以看出怎样在一个函数里，处理一个键值对参数了。&lt;/p&gt;
&lt;h4 id=&#34;argskwargs_1&#34;&gt;使用&lt;code&gt;*args&lt;/code&gt;和&lt;code&gt;**kwargs&lt;/code&gt;来调用函数&lt;/h4&gt;
&lt;p&gt;现在我们来看看怎样使用&lt;code&gt;*args&lt;/code&gt;和&lt;code&gt;**kwargs&lt;/code&gt;来调用一个函数。假设，有这样一个函数：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;def test_args_kwargs(arg1, arg2, arg3): 
    print(&amp;quot;arg1:&amp;quot;, arg1) 
    print(&amp;quot;arg2:&amp;quot;, arg2) 
    print(&amp;quot;arg3:&amp;quot;, arg3)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你可以使用&lt;code&gt;*args&lt;/code&gt;和&lt;code&gt;**kwargs&lt;/code&gt;来给这个函数传递参数，如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;# 首先使用*args
args = (&amp;quot;二&amp;quot;, 3, 5)
test_args_kwargs(*args)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;arg1: 二
arg2: 3
arg3: 5
&lt;/code&gt;&lt;/pre&gt;

&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;# 现在使⽤ **kwargs: 
kwargs = {&amp;quot;arg3&amp;quot;: 3, &amp;quot;arg2&amp;quot;: &amp;quot;二&amp;quot;, &amp;quot;arg1&amp;quot;: 5} 
test_args_kwargs(**kwargs) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;arg1: 5 
arg2: 二 
arg3: 3 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;标准参数与&lt;code&gt;*args&lt;/code&gt;和&lt;code&gt;**kwargs&lt;/code&gt;在使用时的顺序&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;那么如果你想在函数⾥同时使⽤所有这三种参数， 顺序是这样的： &lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;some_func(fargs, *args, **kwargs)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;debugging&#34;&gt;调试Debugging&lt;/h3&gt;
&lt;p&gt;利用好调试，能大提高我们捕捉代码的bug。大部分人忽略了Python debugger（pdb）的重要性。在这里会讲一些重要的命令，其他的可以从官方文档中学习。地址如下：&lt;/p&gt;
&lt;p&gt;https://docs.python.org/3/library/pdb.html &lt;/p&gt;
&lt;h4 id=&#34;_1&#34;&gt;从命令运行&lt;/h4&gt;
&lt;p&gt;你可以在命令行使用Python debugger运行一个脚本，举个例子：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;python -m pdb my_script.py
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这会触发debugger在脚本第一行指令处停止执行。这个对比较短的脚本很有帮助。&lt;/p&gt;
&lt;h4 id=&#34;_2&#34;&gt;从脚本内部运行&lt;/h4&gt;
&lt;p&gt;可以在脚本内设置数点，这样就可以在某些特定点查看变量信息和各种执行时信息了。使用&lt;code&gt;pdb.set_trace()&lt;/code&gt;方法来实现。举例说明：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;import pdb 
def make_bread(): 
    pdb.set_trace() 
    return &amp;quot;I don&#39;t have time&amp;quot; 

print(make_bread())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行上面的脚本，会立刻进入debugger模式。其操作命令如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;c：继续执行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;w：显示当前正在执行的代码行的上下文信息&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;a：打印当前函数的参数列表&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;s：执行当前代码行，并停在第一个能停的地方（相当于单步进入）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;n：继续执行到当前函数的下一行，或者当前行直接返回（单步跳过）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;单步路过和单步进入的区别在于，单步进入会进入当前行调用的函数内部停在里面，而单步跳过会全速执行完成当前调用的函数，并停在当前函数的下一行。&lt;/p&gt;
&lt;h3 id=&#34;generators&#34;&gt;生成器Generators&lt;/h3&gt;
&lt;p&gt;讲解生成器之前，我们先说一下迭代器。迭代器是一个让程序可以遍历一个容器（特别是列表）的对象。然而，一个迭代器在遍历并读取一个容器的数据元素时，并不会执行一个迭代。它有三个部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可迭代对象（Iterable）&lt;/li&gt;
&lt;li&gt;迭代器（Iterator）&lt;/li&gt;
&lt;li&gt;迭代（Iteration）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上面这些部分互相联系。我们先来讨论他们，然后再讨论生成器（generators）。&lt;/p&gt;
&lt;h4 id=&#34;iterable&#34;&gt;可迭代对象（Iterable）&lt;/h4&gt;
&lt;p&gt;Python中任意的对象，只要它定义了可以返回一个迭代器&lt;code&gt;__iter__&lt;/code&gt;方法，或者定义了可以支持下标索引的&lt;code&gt;__getitem__&lt;/code&gt;方法，那么安就是一个可迭代器。简单说，可迭代对象就是能提供迭代器的任意对象。&lt;/p&gt;
&lt;h4 id=&#34;iterator&#34;&gt;迭代器（Iterator）&lt;/h4&gt;
&lt;p&gt;任意对象，只要定义了&lt;code&gt;__next__&lt;/code&gt;方法，它就是一个迭代器。&lt;/p&gt;
&lt;h4 id=&#34;iteration&#34;&gt;迭代（Iteration）&lt;/h4&gt;
&lt;p&gt;迭代就是从某个地方（比如一个列表）取出一个元素的过程。当我们使用一个循环来遍历某个东西时，这个过程本身就叫迭代。&lt;/p&gt;
&lt;h4 id=&#34;generators_1&#34;&gt;生成器（Generators）&lt;/h4&gt;
&lt;p&gt;生成器也是一种迭代器，但是你只能对其迭代一次。这是因为他们并没有把所有的值存在内存中，而是在运行时生成值。你通过遍历来用不用它们，要么用一个”for“循环，要么将它们传递给任意可以进行迭代的函数和结构。大多数时个生成器是以函数来实现的。然而，他们并不返回一个值，而是yield一个值。如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;def generator_function():
    for i in range(10):
        yield i

for item in generator_function():
    print(item)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;0
1
2
3
4
5
6
7
8
9
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个例子并不是非常实用。生成器最佳应用场景是：你不想同一时间将所有计算出来的大量结果集分配到内存当中，特别是结果集里还包含循环。这样做会消耗大量的资源。&lt;/p&gt;
&lt;p&gt;下面是一个计算斐波那契数列的生成器：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;def fibon(n):
    a = b = 1
    for i in range(n):
        yield a
        a, b = b, a + b

for x in fibon(1000000):
    print(x)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用这种方式，我们可以不用担心它会使用大量资源。然而，之前如果我们这样实现的话：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;def fibon(n):
    a = b = 1
    result = []
    for i in range(n):
        result.append(a)
        a, b = b, a + b
    return result
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个会在计算很大的输入参数时，占用大量的资源。我们现在来测试一下生成器使用一次迭代，我们使用python的内置函数：&lt;code&gt;next()&lt;/code&gt;，它可以获取一个序列的下一个元素。如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;def generator_function():
    for i in range(3):
        yield i

gen = generator_function()

print(next(gen))
print(next(gen))
print(next(gen))
print(next(gen))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行结果:&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;0
1
2
Traceback (most recent call last):
  File &amp;quot;E:\公司文档\分享内容\markdown\python进阶\8.py&amp;quot;, line 12, in &amp;lt;module&amp;gt;
    print(next(gen))
StopIteration
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从结果中可以看出，在yield掉所有值后，next()触发了一个StopIteration的异常。这个说明所有的值都已经yield完了。for循环会自动捕捉这个异常并停止调用next()，所以for循环没有这个异常。&lt;/p&gt;
&lt;p&gt;Python中有些内置数据也支持迭代，如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;my_string = &amp;quot;tester&amp;quot; 
my_iter = iter(my_string) 
print(next(my_iter))
print(next(my_iter))
print(next(my_iter))
print(next(my_iter))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;t
e
s
t
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;mapfilterreduce&#34;&gt;Map，Filter和Reduce&lt;/h3&gt;
&lt;h4 id=&#34;map&#34;&gt;Map&lt;/h4&gt;
&lt;p&gt;Map会将一个函数映射到一个输入列表的所有元素上。如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;map(function_to_apply, list_of_inputs)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一般而言，要把列表中所有元素一个个地传递给一个函数，并收集输出。应做如下操作：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;items = [1, 2, 3, 4, 5]
squared = []
for i in items:
    squared.append(i**2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Map可以用一种简单得多的方式来实现。如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;items = [1, 2, 3, 4, 5]
squared = list(map(lambda x:x**2, items))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;大多数时候，我们使用匿名函数（lambda）来配合map。其不仅可用于列表的输入，甚至可以用于列表的函数。如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;def multiply(x):
    return (x*x)

def add(x):
    return (x+x)

funcs = [multiply, add]
for i in range(5):
    value = list(map(lambda x:x(i), funcs))
    print(value)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;[0, 0]
[1, 2]
[4, 4]
[9, 6]
[16, 8]
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;filter&#34;&gt;Filter&lt;/h4&gt;
&lt;p&gt;filter过滤列表中的元素，并返回一个由所有符合要求的元素所构成的列表。如下:&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;number_list = range(-5, 5)
less_than_zero = list(filter(lambda x:x&amp;lt;0, number_list))
print(less_than_zero)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;[-5, -4, -3, -2, -1]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;filter类似for循环，但它是一个内置函数，并且更快。&lt;/p&gt;
&lt;h4 id=&#34;reduce&#34;&gt;Reduce&lt;/h4&gt;
&lt;p&gt;当需要对一个列表进行一些计算并返回结果时，Reduce是个非常有用的函数。如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;from functools import reduce
product = reduce((lambda x, y:x *y), [1, 2, 3, 4])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;24
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;set&#34;&gt;set（集合）数据结构&lt;/h3&gt;
&lt;h4 id=&#34;set_1&#34;&gt;set&lt;/h4&gt;
&lt;p&gt;set（集合）是一个非常有用的数据结构。它与列表（list）的行为类似，区别在于set不能包含重复的值。这在去重和检查列表中是否包含重复元素很有用。如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;some_list = [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;b&#39;,&#39;d&#39;,&#39;m&#39;,&#39;n&#39;,&#39;n&#39;]
duplicates = set([x for x in some_list if some_list.count(x) &amp;gt; 1])

print(duplicates)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;{&#39;n&#39;, &#39;b&#39;}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;_3&#34;&gt;交集&lt;/h4&gt;
&lt;p&gt;对比两个集合的交集，如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;valid = set([&#39;yellow&#39;,&#39;red&#39;,&#39;blue&#39;,&#39;green&#39;,&#39;black&#39;])
input_set = set([&#39;red&#39;,&#39;brown&#39;])
print(input_set.intersection(valid))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行结果:&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;{&#39;red&#39;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注：intersection() 方法用于返回两个或更多集合中都包含的元素，即交集。&lt;/p&gt;
&lt;h4 id=&#34;_4&#34;&gt;差集&lt;/h4&gt;
&lt;p&gt;用差集找出无效的数据，如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;valid = set([&#39;yellow&#39;,&#39;red&#39;,&#39;blue&#39;,&#39;green&#39;,&#39;black&#39;])
input_set = set([&#39;red&#39;,&#39;brown&#39;])
print(input_set.difference(valid))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行结果:&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;{&#39;brown&#39;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注：difference() 方法用于返回集合的差集，即返回的集合元素包含在第一个集合中，但不包含在第二个集合(方法的参数)中。&lt;/p&gt;
&lt;h3 id=&#34;_5&#34;&gt;三元运算符&lt;/h3&gt;
&lt;p&gt;三元运算符通常被称为条件表达式，这些表达式基于真(true)/假(not)的条件判断。如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;condition_is_true if condiiton else condition_is_false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;举个例子：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;is_fat = True
state = &amp;quot;fat&amp;quot; if is_fat else &amp;quot;not fat&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;它还有一种不常用的用法，使用了元组，如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;(if_test_if_false, if_test_is_true)[test]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;举个例子：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;fat = True
fitness = (&amp;quot;skinny&amp;quot;, &amp;quot;fat&amp;quot;)[fat]
print(&amp;quot;All is&amp;quot;, fitness)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;All is fat
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一般不建议使用元组条件表达式的缘故是在元组中会把两个条件都执行，而if else的条件表达式不会。例如：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;condition = True
print(2 if condition else 1/0)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行如果：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;2
&lt;/code&gt;&lt;/pre&gt;

&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;condition = True
print((2, 1/0)[condition])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;ZeroDivisionError: division by zero
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;_6&#34;&gt;装饰器&lt;/h3&gt;
&lt;p&gt;装饰器是修改其他函数的功能的函数。&lt;/p&gt;
&lt;h4 id=&#34;_7&#34;&gt;第一个装饰器&lt;/h4&gt;
&lt;p&gt;如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;def a_new_decorator(a_func):

    def wrapTheFunction():
        print(&amp;quot;在执行a_func函数之前我正在干一些无趣的事情&amp;quot;)
        a_func()
        print(&amp;quot;在执行a_func函数之后我正在干一些无趣的事情&amp;quot;)

    return wrapTheFunction

def a_function_requiring_decoration():
    print(&amp;quot;我需要一些装饰来掩饰我的伤口&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行1及结果：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;a_function_requiring_decoration()
# 执行结果：
我需要一些装饰来掩饰我的伤口
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行2及结果：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;a_function_requiring_decoration = a_new_decorator(a_function_requiring_decoration)

a_function_requiring_decoration()
# 执行结果：
在执行a_func函数之前我正在干一些无趣的事情
我需要一些装饰来掩饰我的伤口
在执行a_func函数之后我正在干一些无趣的事情
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上就是python中装饰器的作用。它封装一个函数，并且用一些方式来修改它的行为。下面我们使用@来运行之前的代码：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;def a_new_decorator(a_func):

    def wrapTheFunction():
        print(&amp;quot;在执行a_func函数之前我正在干一些无趣的事情&amp;quot;)
        a_func()
        print(&amp;quot;在执行a_func函数之后我正在干一些无趣的事情&amp;quot;)

    return wrapTheFunction

@a_new_decorator
def a_function_requiring_decoration():
    # 装饰
    print(&amp;quot;我需要一些装饰来掩饰我的伤口&amp;quot;)

a_function_requiring_decoration()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;在执行a_func函数之前我正在干一些无趣的事情
我需要一些装饰来掩饰我的伤口
在执行a_func函数之后我正在干一些无趣的事情
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;附：&lt;code&gt;@a_new_decorator&lt;/code&gt;是&lt;code&gt;a_function_requiring_decoration = a_new_decorator(a_function_requiring_decoration)&lt;/code&gt;的缩略方式&lt;/p&gt;
&lt;p&gt;现在我们对装饰器有了一个基本的了解。如果我们运行下面的代码会有一个问题：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;print(a_function_requiring_decoration.__name__)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;wrapTheFunction
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个并不是我们想要的，Python提供了一个函数来解决这个问题，那就是functools.wraps。如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;from functools import wraps

def a_new_decorator(a_func):
    @wraps(a_func)
    def wrapTheFunction():
        print(&amp;quot;在执行a_func函数之前我正在干一些无趣的事情&amp;quot;)
        a_func()
        print(&amp;quot;在执行a_func函数之后我正在干一些无趣的事情&amp;quot;)

    return wrapTheFunction

@a_new_decorator
def a_function_requiring_decoration():
    # 装饰
    print(&amp;quot;我需要一些装饰来掩饰我的伤口&amp;quot;)

print(a_function_requiring_decoration.__name__)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;a_function_requiring_decoration
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;装饰器规范&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;from functools import wraps
def decorator_name(f):
    @wraps(f)
    def decorated(*args, **kwargs):
        if not can_run:
            return &amp;quot;Function will not run&amp;quot;
        return f(*args, **kwargs)
    return decorated
@decorator_name
def func():
    return(&amp;quot;Function is running&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行1及结果：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;can_run = True
print(func())
# 执行结果
Function is running
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行2及结果：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;can_run = False
print(func())
# 执行结果
Function is not running
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注：@wraps接受一个函数来进行装饰，并加入复制函数名称、注释文档、参数列表等功能。&lt;/p&gt;
&lt;h4 id=&#34;_8&#34;&gt;使用场景&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;授权(Authorization)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;装饰器有助于检查是否被授权去使用一个web应用的端点。它被大量用于Flask和Django框架中。如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;from functools import wraps

def requires_auth(f):
    @wraps(f)
    def decorated(*args, **kwargs):
        auth = request.authorization
        if not auth or not check_auth(auth.username, auth.password):
            authenticate()
        return f(*args, **kwargs)
    return decorated
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;日志(Logging)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;日志是装饰器运用的另一个亮点。如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;from functools import wraps
def logit(func):
    @wraps(func)
    def with_logging(*args, **kwargs):
        print(func.__name__ + &amp;quot;被调用&amp;quot;)
        return func(*args, **kwargs)
    return with_logging

@logit
def addition_func(x):
    return x + x

result = addition_func(4)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;addition_func被调用
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;_9&#34;&gt;带参数的装饰器&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;在函数中嵌入装饰器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在刚才的日志铺子中创建一个包裹函数，可以用来指定一个用于输出的日志文件。如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;from functools import wraps

def logit(logfile=&amp;quot;out.log&amp;quot;):
    def logging_decorator(func):
        @wraps(func)
        def wrapped_function(*args, **kwargs):
            lgo_string = func.__name__ + &amp;quot;被调用&amp;quot;
            print(lgo_string)
            with open(logfile, &#39;a&#39;) as opened_file:
                opened_file.write(lgo_string + &#39;\n&#39;)
            return func(*args, **kwargs)
        return wrapped_function
    return logging_decorator
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行1及结果：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;@logit()
def myfunc1():
    pass

myfunc1()
# 执行结果
myfunc1被调用
#当前目录下会生成文件out.log,而且“myfunc1被调用”被写入。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行2及结果：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;@logit(logfile=&amp;quot;func2.log&amp;quot;)
def myfunc2():
    pass

myfunc2()
# 执行结果
myfunc2被调用
#当前目录下会生成文件func2.log,而且“myfunc2被调用”被写入。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;装饰器类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;类也可以用来构建装饰器。如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;from functools import wraps

class logit(object):
    def __init__(self, logfile=&#39;out.log&#39;):
        self.logfile = logfile

    def __call__(self, func):
        @wraps(func)
        def wrapped_function(*args, **kwargs):
            log_string = func.__name__ + &amp;quot;被调用&amp;quot;
            print(log_string)
            with open(self.logfile, &#39;a&#39;) as opened_file:
                opened_file.write(log_string + &#39;\n&#39;)
            self.notify()
            return func(*args, **kwargs)
        return wrapped_function

    def notify(self):
        # 只用于日志
        pass
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行及结果：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;@logit()
def myfunc1():
    pass

myfunc1()
# 执行结果
myfunc1被调用
#当前目录下会生成文件out.log,而且“myfunc1被调用”被写入。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为了保存日志的同时，给相关人员发送邮件，可以给logit创建一个子类，来添加邮件功能。如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;class email_logit(logit):
    def __init__(self, email=&amp;quot;test@test.cn&amp;quot;, *args, **kwargs):
        self.email = email
        super(logit, self).__init__(*args, **kwargs)

    def notify(self):
        # 邮件功能实现略
        pass
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在&lt;code&gt;@email_logit&lt;/code&gt;在打日志的基础上，还有发邮件的功能。&lt;/p&gt;
&lt;h3 id=&#34;globalreturn&#34;&gt;Global和Return&lt;/h3&gt;
&lt;p&gt;return和global的作用，如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;def add(value1, value2):
    return value1 +  value2

result = add(3, 5)
print(result)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;return&amp;lt;函数把值赋给了调用它的变量。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;def add(value1,value2):
    global result
    result = value1 + value2

add(3,5)
print(result)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;global的作用是在函数以外的区域都能访问这个变量。举个例子：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;def add(value1, value2):
    result = value1 + value2

add(2, 4)
print(result)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;Traceback (most recent call last):
  File &amp;quot;E:\公司文档\分享内容\markdown\python进阶\29.py&amp;quot;, line 7, in &amp;lt;module&amp;gt;
    print(result)
NameError: name &#39;result&#39; is not defined
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;函数内的result只是局部变量，不要被用于函数外部。申明global后可正常执行，但应尽量避免使用global，它会引入多余的变量到全局作用域。&lt;/p&gt;
&lt;h4 id=&#34;return&#34;&gt;多个return值&lt;/h4&gt;
&lt;p&gt;返回多个值，不建议使用global关键字，使用元组(tuple)，列表(list)，字典(dict)是可行的，但并不是最好的，按照惯例如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;def profile():
    name = &amp;quot;Tester&amp;quot;
    age = 30
    return name, age

print(&amp;quot;name:&amp;quot;,profile()[0])
print(&amp;quot;age:&amp;quot;,profile()[1])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;name: Tester
age: 30
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;mutation&#34;&gt;对象变动（Mutation)&lt;/h3&gt;
&lt;p&gt;Python中有可变与不可变的数据类型。可变意味着“可以被改动”，而不变的意思就是“常量”。举例如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;poo = [&#39;hi&#39;]
print(poo)

bar = poo
bar += [&#39;bye&#39;]
print(poo)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;[&#39;hi&#39;]
[&#39;hi&#39;, &#39;bye&#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这不是一个问题。这个是对象可变性。每当你将一个变量赋值为另一个可变类型的变量时，对这个数据的任意改动会同时反映到这两个变量上去。新变量不过是老变量的一个别名。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;def add_to(num, target=[]):
    target.append(num)
    return target

print(add_to(1))
print(add_to(2))
print(add_to(3))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;[1]
[1, 2]
[1, 2, 3]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在Python中当函数被定义时，默认参数只运算一次，而不是每次用时都会重新运算。所以不要定义可变类型的默认参数，除非这个默认参数是你真的需要的。为了达到效果，你可以这样做：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;def add_to(element, target=None):
    if target is None:
        target = []
    target.append(element)
    return target

print(add_to(1))
print(add_to(2))
print(add_to(3))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;[1]
[2]
[3]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;__slots__&#34;&gt;&lt;code&gt;__slots__&lt;/code&gt;魔法&lt;/h3&gt;
&lt;p&gt;在Python中，每个类都有实例属性。默认情况下Python用一个字典来保存一个对象的实例属性。不过，这个字典浪费了很多内存。Python不能在对象创建时直接分配一个固定量的来保存所有属性。因此创建许多象，会消耗很多内存。不过可以用&lt;code&gt;__slots__&lt;/code&gt;来告诉Python不要使用字典，而且只给一个固定集合的属性分配空间。举个列子：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不使用&lt;code&gt;__slots__&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;class MyClass(object):
    def __init__(self, name, age):
        self.name = name
        self.age = age
        self.set_up()
    # ...
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;使用&lt;code&gt;__slots__&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;class MyClass(object):
    __slots__ = [&#39;name&#39;, &#39;age&#39;]
    def __init__(self, name, age):
        self.name = name
        self.age = age
        self.set_up()
    # ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第二段代码会减少40~50%的内存占用，可以通过&lt;a href=&#34;https://github.com/ianozsvald/ipython_memory_usage&#34;&gt;ipython_memory_usage&lt;/a&gt;来查看效果，这里安装失败了，暂不对比。&lt;/p&gt;
&lt;h3 id=&#34;_10&#34;&gt;虚拟环境&lt;/h3&gt;
&lt;h4 id=&#34;virtualenv&#34;&gt;virtualenv&lt;/h4&gt;
&lt;p&gt;virtualenv是一个可以创建独立（隔离）的Python环境的工具。它可以为每一个程序创建一个独立的环境，只为自己安装依赖的模块，而不用全局安装所有依赖的模块。&lt;/p&gt;
&lt;p&gt;安装virtualenv&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;pip install virtualenv
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;常用的命令：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;# 在myproject文件夹下创建一个隔离的virtualenv环境
virtualenv myproject
# 激活这个隔离的环境
source bin/activate
# 退出当前virtualenv
deactivate  # 恢复使用系统全局Python模块
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你想让你的virtualenv使用全局模块，可以用&lt;code&gt;--system-site-packages&lt;/code&gt;参数创建virtualenv，如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;virtualenv --system-site-packages myproject
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;collections&#34;&gt;容器Collections&lt;/h3&gt;
&lt;p&gt;Python附带一个模块collections，它包含许多容器数据类型，如&lt;code&gt;defaultdict&lt;/code&gt;，&lt;code&gt;counter&lt;/code&gt;,&lt;code&gt;deque&lt;/code&gt;,&lt;code&gt;namedtuple&lt;/code&gt;,&lt;code&gt;enum.Enum&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id=&#34;defaultdict&#34;&gt;defaultdict&lt;/h4&gt;
&lt;p&gt;defaultdict，与dict类型不同，不需要检查key是否存在，举例如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;from collections import defaultdict

colours = (
    (&#39;张三&#39;, &#39;黄色&#39;),
    (&#39;李四&#39;, &#39;蓝色&#39;),
    (&#39;王五&#39;, &#39;绿色&#39;),
    (&#39;李四&#39;, &#39;黑色&#39;),
    (&#39;张三&#39;, &#39;红色&#39;),
    (&#39;赵六&#39;, &#39;紫色&#39;),
    )

favourite_colours = defaultdict(list)

for name, colour in colours:
    favourite_colours[name].append(colour)

print(favourite_colours)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;defaultdict(&amp;lt;class &#39;list&#39;&amp;gt;, {&#39;张三&#39;: [&#39;黄色&#39;, &#39;红色&#39;], &#39;李四&#39;: [&#39;蓝色&#39;, &#39;黑色&#39;], &#39;王五&#39;: [&#39;绿色&#39;], &#39;赵六&#39;: [&#39;紫色&#39;]})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当在一个字典中对一个键进行嵌套赋值时，如果这个键不存在，会触发keyError异常。defaultdict允许绕过这个问题。举例如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;some_dict = {}
some_dict[&#39;colours&#39;][&#39;favourite&#39;] = &amp;quot;yellow&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;Traceback (most recent call last):
  File &amp;quot;E:\公司文档\分享内容\markdown\python进阶\35.py&amp;quot;, line 2, in &amp;lt;module&amp;gt;
    some_dict[&#39;colours&#39;][&#39;favourite&#39;] = &amp;quot;yellow&amp;quot;
KeyError: &#39;colours&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;解决方案：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;import collections
import json

tree = lambda:collections.defaultdict(tree)
some_dict = tree()
some_dict[&#39;colours&#39;][&#39;favourite&#39;] = &amp;quot;yellow&amp;quot;

print(json.dumps(some_dict))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;{&amp;quot;colours&amp;quot;: {&amp;quot;favourite&amp;quot;: &amp;quot;yellow&amp;quot;}}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;counter&#34;&gt;Counter&lt;/h4&gt;
&lt;p&gt;Counter是一个计数器，它可以帮助我们针对某项数据进行计数。如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;from collections import Counter

colours = (
    (&#39;张三&#39;, &#39;黄色&#39;),
    (&#39;李四&#39;, &#39;蓝色&#39;),
    (&#39;王五&#39;, &#39;绿色&#39;),
    (&#39;李四&#39;, &#39;黑色&#39;),
    (&#39;张三&#39;, &#39;红色&#39;),
    (&#39;赵六&#39;, &#39;紫色&#39;),
    )

favs = Counter(name for name, colour in colours)
print(favs)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;Counter({&#39;张三&#39;: 2, &#39;李四&#39;: 2, &#39;王五&#39;: 1, &#39;赵六&#39;: 1})
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;deque&#34;&gt;deque&lt;/h4&gt;
&lt;p&gt;deque提供了一个双端队列，你可以从头/尾两端添加或删除元素。如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;from collections import deque

d = deque()
# 用法和list差不多
d.append(&#39;1&#39;)
d.append(&#39;2&#39;)
d.append(&#39;3&#39;)

print(len(d))
print(d[0])
print(d[-1])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;3
1
3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从两端删除数据：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;from collections import deque

d = deque(range(5))
print(len(d))
print(d.popleft())
print(d.pop())
print(d)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;5
0
4
deque([1, 2, 3])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以限制deque的大小，当超过这个限制时，会把左边的数据挤出去。如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;from collections import deque

d = deque(maxlen=2)

d.append(&#39;1&#39;)
d.append(&#39;2&#39;)
d.append(&#39;3&#39;)

print(d)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;deque([&#39;2&#39;, &#39;3&#39;], maxlen=2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从两端扩展数据：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;from collections import deque

d = deque([1,2,3,4,5])
d.extendleft([0])
d.extend([6,7,8])
print(d)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;deque([0, 1, 2, 3, 4, 5, 6, 7, 8])
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;namedtuple&#34;&gt;namedtuple&lt;/h4&gt;
&lt;p&gt;namedtuple把元组变成一个简单任务的容器，不用像元组那样使用整数索引来访问一个namedtuple数据，而是像字典一样访问namedtuple，namedtuple也是不可娈的。如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;from collections import namedtuple

Animal = namedtuple(&#39;Animal&#39;, &#39;name age type&#39;)
perry = Animal(name=&amp;quot;perry&amp;quot;, age=31, type=&amp;quot;cat&amp;quot;)

print(perry)
print(perry.name)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;Animal(name=&#39;perry&#39;, age=31, type=&#39;cat&#39;)
perry
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;命名元组是不可娈的。如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;from collections import namedtuple

Animal = namedtuple(&#39;Animal&#39;, &#39;name age type&#39;)
perry = Animal(name=&amp;quot;perry&amp;quot;, age=31, type=&amp;quot;cat&amp;quot;)
perry.age = 42
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;Traceback (most recent call last):
  File &amp;quot;E:\公司文档\分享内容\markdown\python进阶\44.py&amp;quot;, line 7, in &amp;lt;module&amp;gt;
    perry.age = 42
AttributeError: can&#39;t set attribute
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;命名元组可以兼容普通元组，就是说你也可以用整数索引来访问namedtuple。如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;from collections import namedtuple

Animal = namedtuple(&#39;Animal&#39;, &#39;name age type&#39;)
perry = Animal(name=&amp;quot;perry&amp;quot;, age=31, type=&amp;quot;cat&amp;quot;)
print(perry[0])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;perry
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;命名元组可以转换为字典。如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;from collections import namedtuple

Animal = namedtuple(&#39;Animal&#39;, &#39;name age type&#39;)
perry = Animal(name=&amp;quot;perry&amp;quot;, age=31, type=&amp;quot;cat&amp;quot;)
print(perry._asdict())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;{&#39;name&#39;: &#39;perry&#39;, &#39;age&#39;: 31, &#39;type&#39;: &#39;cat&#39;}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;enumenum&#34;&gt;enum.Enum&lt;/h4&gt;
&lt;p&gt;让我们回顾⼀下上⼀个&#39;Animal&#39;命名元组的例⼦。它有⼀个type字段，问题是，type是⼀个字符串。那么问题来了，万⼀程序员输⼊了Cat，因为他按到了Shift键，或者输⼊了&#39;CAT&#39;，甚⾄&#39;kitten&#39;？枚举可以帮助我们避免这个问题，通过不使⽤字符串。如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;from collections import namedtuple
from enum import Enum

class Species(Enum):
    cat = 1
    dog = 2
    horse = 3
    aardvark = 4
    butterfly = 5
    owl = 6
    platypus = 7
    dragon = 8
    unicorn = 9
    # ……

    kitten = 1
    puppy = 2

Animal = namedtuple(&#39;Animal&#39;, &#39;name age type&#39;)
perry = Animal(name=&amp;quot;Perry&amp;quot;, age=31, type=Species.cat)
drogon = Animal(name=&amp;quot;Drogon&amp;quot;, age=4, type=Species.dragon)
tom = Animal(name=&amp;quot;Tom&amp;quot;, age=75, type=Species.cat)
charlie = Animal(name=&amp;quot;Charlie&amp;quot;, age=2, type=Species.kitten)

print(charlie.type == tom.type)
print(charlie.type)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;True
Species.cat
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样就没有那么容易错误了，但应该只使用定义了的枚举类型。有三种方法访问枚举类型，如以下方法都可以获取&lt;code&gt;cat&lt;/code&gt;的值：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;Species(1)
Species[&#39;cat&#39;]
Species.cat
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;enumerate&#34;&gt;枚举Enumerate&lt;/h3&gt;
&lt;p&gt;枚举是python的内置函数。它的作用举例来说明，如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;枚举允许遍历数据并自动计数。&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;some_list = [&#39;苹果&#39;, &#39;香蕉&#39;, &#39;葡萄&#39;, &#39;梨子&#39;]
for counter, value in enumerate(some_list):
    print(counter, value)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;0 苹果
1 香蕉
2 葡萄
3 梨子
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;枚举还可以接受一些可选参数。&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;some_list = [&#39;苹果&#39;, &#39;香蕉&#39;, &#39;葡萄&#39;, &#39;梨子&#39;]
for counter, value in enumerate(some_list,2):   # 计数从2开始
    print(counter, value)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;2 苹果
3 香蕉
4 葡萄
5 梨子
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;枚举可以用来创建包含索引的元组列表。&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;some_list = [&#39;苹果&#39;, &#39;香蕉&#39;, &#39;葡萄&#39;, &#39;梨子&#39;]
counter_list = list(enumerate(some_list))
print(counter_list)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;[(0, &#39;苹果&#39;), (1, &#39;香蕉&#39;), (2, &#39;葡萄&#39;), (3, &#39;梨子&#39;)]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;_11&#34;&gt;对象自省&lt;/h3&gt;
&lt;p&gt;自省，上指在运行时来判断一个对象的类型的能力。&lt;/p&gt;
&lt;h4 id=&#34;dir&#34;&gt;dir&lt;/h4&gt;
&lt;p&gt;dir是用于自省的最重要的函数之一。它返回一个列表，列出一个对象所拥有的属性和方法。如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;my_list = [1, 2, 3]
print(dir(my_list))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;[&#39;__add__&#39;, &#39;__class__&#39;, &#39;__class_getitem__&#39;, &#39;__contains__&#39;, &#39;__delattr__&#39;, &#39;__delitem__&#39;, &#39;__dir__&#39;, &#39;__doc__&#39;, &#39;__eq__&#39;, &#39;__format__&#39;, &#39;__ge__&#39;, &#39;__getattribute__&#39;, &#39;__getitem__&#39;, &#39;__gt__&#39;, &#39;__hash__&#39;, &#39;__iadd__&#39;, &#39;__imul__&#39;, &#39;__init__&#39;, &#39;__init_subclass__&#39;, &#39;__iter__&#39;, &#39;__le__&#39;, &#39;__len__&#39;, &#39;__lt__&#39;, &#39;__mul__&#39;, &#39;__ne__&#39;, &#39;__new__&#39;, &#39;__reduce__&#39;, &#39;__reduce_ex__&#39;, &#39;__repr__&#39;, &#39;__reversed__&#39;, &#39;__rmul__&#39;, &#39;__setattr__&#39;, &#39;__setitem__&#39;, &#39;__sizeof__&#39;, &#39;__str__&#39;, &#39;__subclasshook__&#39;, &#39;append&#39;, &#39;clear&#39;, &#39;copy&#39;, &#39;count&#39;, &#39;extend&#39;, &#39;index&#39;, &#39;insert&#39;, &#39;pop&#39;, &#39;remove&#39;, &#39;reverse&#39;, &#39;sort&#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的自省给了这个列表对象所有的方法的名字，如果你不清楚其所具有的方法，可以使用dir()来查询。&lt;/p&gt;
&lt;h4 id=&#34;typeid&#34;&gt;type和id&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;type函数返回一个对象的类型。如下：&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;print(type(&#39;&#39;))
print(type([]))
print(type({}))
print(type(dict))
print(type(3))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;&amp;lt;class &#39;str&#39;&amp;gt;
&amp;lt;class &#39;list&#39;&amp;gt;
&amp;lt;class &#39;dict&#39;&amp;gt;
&amp;lt;class &#39;type&#39;&amp;gt;
&amp;lt;class &#39;int&#39;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;id()函数返回任意不同各类对象的唯一id。如下：&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;name = &amp;quot;tester&amp;quot;
print(id(name))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;1546700355120
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;inspect&#34;&gt;inspect模块&lt;/h4&gt;
&lt;p&gt;inspect模块也提供了许多有用的函数，来获取活跃对象的信息。比如，你可以查看一个对象的成员，只需运行：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;import inspect
print(inspect.getmembers(str))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;[(&#39;__add__&#39;, &amp;lt;slot wrapper &#39;__add__&#39; of &#39;str&#39; objects&amp;gt;), (&#39;__class__&#39;, &amp;lt;class &#39;type&#39;&amp;gt;), (&#39;__contains__&#39;, &amp;lt;slot wrapper &#39;__contains__&#39; of &#39;str&#39; objects&amp;gt;), (&#39;__delattr__&#39;, &amp;lt;slot wrapper &#39;__delattr__&#39; of &#39;object&#39; objects&amp;gt;), (&#39;__dir__&#39;, &amp;lt;method &#39;__dir__&#39; of &#39;object&#39; objects&amp;gt;), (&#39;__doc__&#39;, &amp;quot;str(object=&#39;&#39;) -&amp;gt; str\nstr(bytes_or_buffer[, encoding[, errors]]) -&amp;gt; str\n\nCreate a new string object from the given object. If encoding or\nerrors is specified, then the object must expose a data buffer\nthat will be decoded using the given encoding and error handler.\nOtherwise, returns the result of object.__str__() (if defined)\nor repr(object).\nencoding defaults to sys.getdefaultencoding().\nerrors defaults to &#39;strict&#39;.&amp;quot;), (&#39;__eq__&#39;, &amp;lt;slot wrapper &#39;__eq__&#39; of &#39;str&#39; objects&amp;gt;), (&#39;__format__&#39;, &amp;lt;method &#39;__format__&#39; of &#39;str&#39; objects&amp;gt;), (&#39;__ge__&#39;, &amp;lt;slot wrapper &#39;__ge__&#39; of &#39;str&#39; objects&amp;gt;), (&#39;__getattribute__&#39;, &amp;lt;slot wrapper &#39;__getattribute__&#39; of &#39;str&#39; objects&amp;gt;), (&#39;__getitem__&#39;, &amp;lt;slot wrapper &#39;__getitem__&#39; of &#39;str&#39; objects&amp;gt;), (&#39;__getnewargs__&#39;, &amp;lt;method &#39;__getnewargs__&#39; of &#39;str&#39; objects&amp;gt;), (&#39;__gt__&#39;, &amp;lt;slot wrapper &#39;__gt__&#39; of &#39;str&#39; objects&amp;gt;), (&#39;__hash__&#39;, &amp;lt;slot wrapper &#39;__hash__&#39; of &#39;str&#39; objects&amp;gt;), (&#39;__init__&#39;, &amp;lt;slot wrapper &#39;__init__&#39; of &#39;object&#39; objects&amp;gt;), (&#39;__init_subclass__&#39;, &amp;lt;built-in method __init_subclass__ of type object at 0x00007FF9D967AC60&amp;gt;), (&#39;__iter__&#39;, &amp;lt;slot wrapper &#39;__iter__&#39; of &#39;str&#39; objects&amp;gt;), (&#39;__le__&#39;, &amp;lt;slot wrapper &#39;__le__&#39; of &#39;str&#39; objects&amp;gt;), (&#39;__len__&#39;, &amp;lt;slot wrapper &#39;__len__&#39; of &#39;str&#39; objects&amp;gt;), (&#39;__lt__&#39;, &amp;lt;slot wrapper &#39;__lt__&#39; of &#39;str&#39; objects&amp;gt;), (&#39;__mod__&#39;, &amp;lt;slot wrapper &#39;__mod__&#39; of &#39;str&#39; objects&amp;gt;), (&#39;__mul__&#39;, &amp;lt;slot wrapper &#39;__mul__&#39; of &#39;str&#39; objects&amp;gt;), (&#39;__ne__&#39;, &amp;lt;slot wrapper &#39;__ne__&#39; of &#39;str&#39; objects&amp;gt;), (&#39;__new__&#39;, &amp;lt;built-in method __new__ of type object at 0x00007FF9D967AC60&amp;gt;), (&#39;__reduce__&#39;, &amp;lt;method &#39;__reduce__&#39; of &#39;object&#39; objects&amp;gt;), (&#39;__reduce_ex__&#39;, &amp;lt;method &#39;__reduce_ex__&#39; of &#39;object&#39; objects&amp;gt;), (&#39;__repr__&#39;, &amp;lt;slot wrapper &#39;__repr__&#39; of &#39;str&#39; objects&amp;gt;), (&#39;__rmod__&#39;, &amp;lt;slot wrapper &#39;__rmod__&#39; of &#39;str&#39; objects&amp;gt;), (&#39;__rmul__&#39;, &amp;lt;slot wrapper &#39;__rmul__&#39; of &#39;str&#39; objects&amp;gt;), (&#39;__setattr__&#39;, &amp;lt;slot wrapper &#39;__setattr__&#39; of &#39;object&#39; objects&amp;gt;), (&#39;__sizeof__&#39;, &amp;lt;method &#39;__sizeof__&#39; of &#39;str&#39; objects&amp;gt;), (&#39;__str__&#39;, &amp;lt;slot wrapper &#39;__str__&#39; of &#39;str&#39; objects&amp;gt;), (&#39;__subclasshook__&#39;, &amp;lt;built-in method __subclasshook__ of type object at 0x00007FF9D967AC60&amp;gt;), (&#39;capitalize&#39;, &amp;lt;method &#39;capitalize&#39; of &#39;str&#39; objects&amp;gt;), (&#39;casefold&#39;, &amp;lt;method &#39;casefold&#39; of &#39;str&#39; objects&amp;gt;), (&#39;center&#39;, &amp;lt;method &#39;center&#39; of &#39;str&#39; objects&amp;gt;), (&#39;count&#39;, &amp;lt;method &#39;count&#39; of &#39;str&#39; objects&amp;gt;), (&#39;encode&#39;, &amp;lt;method &#39;encode&#39; of &#39;str&#39; objects&amp;gt;), (&#39;endswith&#39;, &amp;lt;method &#39;endswith&#39; of &#39;str&#39; objects&amp;gt;), (&#39;expandtabs&#39;, &amp;lt;method &#39;expandtabs&#39; of &#39;str&#39; objects&amp;gt;), (&#39;find&#39;, &amp;lt;method &#39;find&#39; of &#39;str&#39; objects&amp;gt;), (&#39;format&#39;, &amp;lt;method &#39;format&#39; of &#39;str&#39; objects&amp;gt;), (&#39;format_map&#39;, &amp;lt;method &#39;format_map&#39; of &#39;str&#39; objects&amp;gt;), (&#39;index&#39;, &amp;lt;method &#39;index&#39; of &#39;str&#39; objects&amp;gt;), (&#39;isalnum&#39;, &amp;lt;method &#39;isalnum&#39; of &#39;str&#39; objects&amp;gt;), (&#39;isalpha&#39;, &amp;lt;method &#39;isalpha&#39; of &#39;str&#39; objects&amp;gt;), (&#39;isascii&#39;, &amp;lt;method &#39;isascii&#39; of &#39;str&#39; objects&amp;gt;), (&#39;isdecimal&#39;, &amp;lt;method &#39;isdecimal&#39; of &#39;str&#39; objects&amp;gt;), (&#39;isdigit&#39;, &amp;lt;method &#39;isdigit&#39; of &#39;str&#39; objects&amp;gt;), (&#39;isidentifier&#39;, &amp;lt;method &#39;isidentifier&#39; of &#39;str&#39; objects&amp;gt;), (&#39;islower&#39;, &amp;lt;method &#39;islower&#39; of &#39;str&#39; objects&amp;gt;), (&#39;isnumeric&#39;, &amp;lt;method &#39;isnumeric&#39; of &#39;str&#39; objects&amp;gt;), (&#39;isprintable&#39;, &amp;lt;method &#39;isprintable&#39; of &#39;str&#39; objects&amp;gt;), (&#39;isspace&#39;, &amp;lt;method &#39;isspace&#39; of &#39;str&#39; objects&amp;gt;), (&#39;istitle&#39;, &amp;lt;method &#39;istitle&#39; of &#39;str&#39; objects&amp;gt;), (&#39;isupper&#39;, &amp;lt;method &#39;isupper&#39; of &#39;str&#39; objects&amp;gt;), (&#39;join&#39;, &amp;lt;method &#39;join&#39; of &#39;str&#39; objects&amp;gt;), (&#39;ljust&#39;, &amp;lt;method &#39;ljust&#39; of &#39;str&#39; objects&amp;gt;), (&#39;lower&#39;, &amp;lt;method &#39;lower&#39; of &#39;str&#39; objects&amp;gt;), (&#39;lstrip&#39;, &amp;lt;method &#39;lstrip&#39; of &#39;str&#39; objects&amp;gt;), (&#39;maketrans&#39;, &amp;lt;built-in method maketrans of type object at 0x00007FF9D967AC60&amp;gt;), (&#39;partition&#39;, &amp;lt;method &#39;partition&#39; of &#39;str&#39; objects&amp;gt;), (&#39;removeprefix&#39;, &amp;lt;method &#39;removeprefix&#39; of &#39;str&#39; objects&amp;gt;), (&#39;removesuffix&#39;, &amp;lt;method &#39;removesuffix&#39; of &#39;str&#39; objects&amp;gt;), (&#39;replace&#39;, &amp;lt;method &#39;replace&#39; of &#39;str&#39; objects&amp;gt;), (&#39;rfind&#39;, &amp;lt;method &#39;rfind&#39; of &#39;str&#39; objects&amp;gt;), (&#39;rindex&#39;, &amp;lt;method &#39;rindex&#39; of &#39;str&#39; objects&amp;gt;), (&#39;rjust&#39;, &amp;lt;method &#39;rjust&#39; of &#39;str&#39; objects&amp;gt;), (&#39;rpartition&#39;, &amp;lt;method &#39;rpartition&#39; of &#39;str&#39; objects&amp;gt;), (&#39;rsplit&#39;, &amp;lt;method &#39;rsplit&#39; of &#39;str&#39; objects&amp;gt;), (&#39;rstrip&#39;, &amp;lt;method &#39;rstrip&#39; of &#39;str&#39; objects&amp;gt;), (&#39;split&#39;, &amp;lt;method &#39;split&#39; of &#39;str&#39; objects&amp;gt;), (&#39;splitlines&#39;, &amp;lt;method &#39;splitlines&#39; of &#39;str&#39; objects&amp;gt;), (&#39;startswith&#39;, &amp;lt;method &#39;startswith&#39; of &#39;str&#39; objects&amp;gt;), (&#39;strip&#39;, &amp;lt;method &#39;strip&#39; of &#39;str&#39; objects&amp;gt;), (&#39;swapcase&#39;, &amp;lt;method &#39;swapcase&#39; of &#39;str&#39; objects&amp;gt;), (&#39;title&#39;, &amp;lt;method &#39;title&#39; of &#39;str&#39; objects&amp;gt;), (&#39;translate&#39;, &amp;lt;method &#39;translate&#39; of &#39;str&#39; objects&amp;gt;), (&#39;upper&#39;, &amp;lt;method &#39;upper&#39; of &#39;str&#39; objects&amp;gt;), (&#39;zfill&#39;, &amp;lt;method &#39;zfill&#39; of &#39;str&#39; objects&amp;gt;)]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;comprehension&#34;&gt;推导式Comprehension&lt;/h3&gt;
&lt;p&gt;推导式是可以从一个数据序列构建另一个新的数据序列的结构体。共有三种推导：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;列表（list）推导式&lt;/li&gt;
&lt;li&gt;字典（dict）推导式&lt;/li&gt;
&lt;li&gt;集合（set）推导式&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;_12&#34;&gt;列表推导式&lt;/h4&gt;
&lt;p&gt;列表推导式是在一个中括号里包含一个表达式，然后是一个for语句，然后是0个或多个for或者if语句。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;规范&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;variable = [out_exp for out_exp in input_list if out_exp == 2]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;举例如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;multiples = [i for i in range(30) if i%3 == 0]
print(multiples)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;[0, 3, 6, 9, 12, 15, 18, 21, 24, 27]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个对快速生成列表很有用。列表推导式在使用for循环生成一个新列表时，非常好用，如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;squared = []
for x in range(10):
    squared.append(x**2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个用推导式就可以简化为：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;squared = [x**2 for x in range(10)]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;_13&#34;&gt;字典推导式&lt;/h4&gt;
&lt;p&gt;字典推导式和列表推导式用法是类似的。如下：&lt;/p&gt;
&lt;p&gt;将字典中一个字母但不同大小写的值合并起来：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;mcase = {&#39;a&#39;: 10, &#39;b&#39;: 34, &#39;A&#39;: 7, &#39;Z&#39;: 3}

mcase_frequency = {
    k.lower():mcase.get(k.lower(), 0) + mcase.get(k.upper(), 0)
    for k in mcase.keys()
}

print(mcase_frequency)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;{&#39;a&#39;: 17, &#39;b&#39;: 34, &#39;z&#39;: 3}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;_14&#34;&gt;集合推导式&lt;/h4&gt;
&lt;p&gt;它和列表推导式也是类似的。唯一区别在于它作用大括号{}。举个例子：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;squared = {x**2 for x in [1, 1, 2]}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;{1, 4}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;_15&#34;&gt;异常&lt;/h3&gt;
&lt;p&gt;最基本的就是&lt;code&gt;try/except&lt;/code&gt;从句。可能触发异常的代码会放到try语句块里，而处理异常的代码会在except语句块中。举个例子：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;try:
    file = open(&#39;test.txe&#39;, &#39;rb&#39;)
except IOError as e:
    print(&amp;quot;一个读写错误发生:{}&amp;quot;.format(e.args[-1]))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;一个读写错误发生:No such file or directory
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;_16&#34;&gt;处理多个异常&lt;/h4&gt;
&lt;p&gt;有三种方法可以用来处理多个异常。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;需要把所有可能发生的异常放到一个元组里面。如下：&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;try:
       file = open(&#39;test.txe&#39;, &#39;rb&#39;)
   except (IOError, EOFError) as e:
       print(&#34;一个读写错误发生:{}&#34;.format(e.args[-1]))&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对每个单独的异常在单独的except语句块中处理。如下：&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;try:
       file = open(&#39;test.txe&#39;, &#39;rb&#39;)
   except EOFError as e:
       print(&#34;一个EOF错误发生。&#34;)
       raise e
   except IOError as e:
       print(&#34;一个读写错误发生。&#34;)
       raise e&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;直接捕获所有异常&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;try:
       file = open(&#39;test.txe&#39;, &#39;rb&#39;)
   except Exception:
       # 打印一些想要的异常日志
       raise&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;当你不知道程序会抛什么异常的时候，第三种方法比较好用。&lt;/p&gt;
&lt;h4 id=&#34;finally&#34;&gt;finally从句&lt;/h4&gt;
&lt;p&gt;除了try和eccept从句，还有第三个从句，就是finally从句。finally从句中的代码不管异常是否触发都会执行。如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;try:
    file = open(&#39;test.txe&#39;, &#39;rb&#39;)
except (IOError, EOFError) as e:
    print(&amp;quot;一个读写错误发生:{}&amp;quot;.format(e.args[-1]))
finally:
    print(&amp;quot;不管是否触发异常都会执行。&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;一个读写错误发生:No such file or directory
不管是否触发异常都会执行。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;tryelse&#34;&gt;try/else从句&lt;/h4&gt;
&lt;p&gt;如果想在没有触发异常的时候执行一些代码，可以用else从句来达到目的。如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;try:
    print(&amp;quot;我确信没有异常发生。&amp;quot;)
except Exception:
    print(&amp;quot;exception.&amp;quot;)
else:
    # 这里的代码只会在try语句没有触发异常时运行
    # 但这里的异常将不会被捕获
    print(&amp;quot;这里的代码只会在try语句没有触发异常时运行,异常将不会被捕获。&amp;quot;)
finally:
    print(&amp;quot;这里将一直被执行。&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;我确信没有异常发生。
这里的代码只会在try语句没有触发异常时运行,异常将不会被捕获。
这里将一直被执行。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;else从句只会在没有异常的情况下执行，而且它会在finally语句之前执行。&lt;/p&gt;
&lt;h3 id=&#34;lambda&#34;&gt;lambda表达式&lt;/h3&gt;
&lt;p&gt;lambada表达式是一行函数，也被称为匿名表达式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;原型&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;lambda 参数:操作(参数)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;add = lambda x, y:x + y
print(add(3, 5))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;lambda表达式，可以在一些特殊的情况下使用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;列表排序&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;a = [(1, 2), (4, 1), (9, 10), (13, -3)]
  a.sort(key=lambda x:x[1])&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;执行结果：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;[(13, -3), (4, 1), (1, 2), (9, 10)]&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;列表并行排序&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;```
  list1 = [1,2,3]
  list2 = [4,5,6]
  data = list(zip(list1, list2))
  data.sort()
  list1, list2 = map(lambda t:list(t), zip(*data))&lt;/p&gt;
&lt;p&gt;print(list1)
  print(list2)
  ```&lt;/p&gt;
&lt;p&gt;执行结果：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;[1, 2, 3]
  [4, 5, 6]&lt;/code&gt;&lt;/p&gt;</description>  
      <pubDate>2025-10-09 17:54:40</pubDate>  
      <link>https://testpoo.github.io/Python进阶.html</link>  
      <guid isPermaLink="true">https://testpoo.github.io/Python进阶.html</guid>
       
      <category>技术</category> 
      
    </item>
    
    <item> 
      <title>Git简介</title>  
      <description>&lt;div class=&#34;toc&#34;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1&#34;&gt;1. 起步&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#11-git&#34;&gt;1.1 Git 简史&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#12-git&#34;&gt;1.2 Git是什么&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#13-git&#34;&gt;1.3 安装 Git&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#14-git&#34;&gt;1.4 初次运行 Git 前的配置&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#15&#34;&gt;1.5 获取帮助&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-git&#34;&gt;2. Git基础&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#21-git&#34;&gt;2.1 获取 Git 仓库&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#21&#34;&gt;2.1 记录每次更新到仓库&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#22&#34;&gt;2.2 查看提交历史&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#23&#34;&gt;2.3 撤消操作&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#24&#34;&gt;2.4 远程仓库的使用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#25&#34;&gt;2.5 打标签&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#26-git&#34;&gt;2.6 Git 别名&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3&#34;&gt;3. 分支简介&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#31&#34;&gt;3.1 分支简介&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#32&#34;&gt;3.2 分支的新建与合并&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#33&#34;&gt;3.3 分支管理&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h2 id=&#34;1&#34;&gt;1. 起步&lt;/h2&gt;
&lt;h3 id=&#34;11-git&#34;&gt;1.1 Git 简史&lt;/h3&gt;
&lt;p&gt;同生活中的许多伟大事物一样，Git 诞生于一个极富纷争大举创新的年代。&lt;/p&gt;
&lt;p&gt;Linux 内核开源项目有着为数众多的参与者。 绝大多数的 Linux 内核维护工作都花在了提交补丁和保存归档的繁琐事务上（1991－2002年间）。 到 2002 年，整个项目组开始启用一个专有的分布式版本控制系统 BitKeeper 来管理和维护代码。&lt;/p&gt;
&lt;p&gt;到了 2005 年，开发 BitKeeper 的商业公司同 Linux 内核开源社区的合作关系结束，他们收回了 Linux 内核社区免费使用 BitKeeper 的权力。 这就迫使 Linux 开源社区（特别是 Linux 的缔造者 Linus Torvalds）基于使用 BitKeeper 时的经验教训，开发出自己的版本系统。 他们对新的系统制订了若干目标：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;速度&lt;/li&gt;
&lt;li&gt;简单的设计&lt;/li&gt;
&lt;li&gt;对非线性开发模式的强力支持（允许成千上万个并行开发的分支）&lt;/li&gt;
&lt;li&gt;完全分布式&lt;/li&gt;
&lt;li&gt;有能力高效管理类似 Linux 内核一样的超大规模项目（速度和数据量）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;自诞生于 2005 年以来，Git 日臻成熟完善，在高度易用的同时，仍然保留着初期设定的目标。 它的速度飞快，极其适合管理大项目，有着令人难以置信的非线性分支管理系统&lt;/p&gt;
&lt;h3 id=&#34;12-git&#34;&gt;1.2 Git是什么&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;直接记录快照，而非差异比较&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Git 和其它版本控制系统（包括 Subversion 和近似工具）的主要差别在于 Git 对待数据的方式。 从概念上来说，其它大部分系统以文件变更列表的方式存储信息，这类系统（CVS、Subversion、Perforce、Bazaar 等等） 将它们存储的信息看作是一组基本文件和每个文件随时间逐步累积的差异 （它们通常称作 &lt;strong&gt;基于差异（delta-based）&lt;/strong&gt; 的版本控制）。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;存储每个文件与初始版本的差异.&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Git 不按照以上方式对待或保存数据。反之，Git 更像是把数据看作是对小型文件系统的一系列快照。 在 Git 中，每当你提交更新或保存项目状态时，它基本上就会对当时的全部文件创建一个快照并保存这个快照的索引。 为了效率，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。 Git 对待数据更像是一个 &lt;strong&gt;快照流&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;存储项目随时间改变的快照&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这是 Git 与几乎所有其它版本控制系统的重要区别。 因此 Git 重新考虑了以前每一代版本控制系统延续下来的诸多方面。 Git 更像是一个小型的文件系统，提供了许多以此为基础构建的超强工具，而不只是一个简单的 VCS。 &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;近乎所有操作都是本地执行&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在 Git 中的绝大多数操作都只需要访问本地文件和资源，一般不需要来自网络上其它计算机的信息。举个例子，要浏览项目的历史，Git 不需外连到服务器去获取历史，然后再显示出来——它只需直接从本地数据库中读取。 你能立即看到项目历史。如果你想查看当前版本与一个月前的版本之间引入的修改， Git 会查找到一个月前的文件做一次本地的差异计算，而不是由远程服务器处理或从远程服务器拉回旧版本文件再来本地处理。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Git 保证完整性&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Git 中所有的数据在存储前都计算校验和，然后以校验和来引用。 这意味着不可能在 Git 不知情时更改任何文件内容或目录内容&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Git 一般只添加数据&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;你执行的 Git 操作，几乎只往 Git 数据库中 &lt;strong&gt;添加&lt;/strong&gt; 数据。 你很难使用 Git 从数据库中删除数据，也就是说 Git 几乎不会执行任何可能导致文件不可恢复的操作。 &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;三种状态&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Git 有三种状态，你的文件可能处于其中之一： &lt;strong&gt;已修改（modified）&lt;/strong&gt; 、 &lt;strong&gt;已暂存（staged）&lt;/strong&gt;、&lt;strong&gt;已提交（committed）&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;已修改表示修改了文件，但还没保存到数据库中。&lt;/li&gt;
&lt;li&gt;已暂存表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。&lt;/li&gt;
&lt;li&gt;已提交表示数据已经安全地保存在本地数据库中。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;工作目录、暂存区域以及 Git 仓库&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;工作区是对项目的某个版本独立提取出来的内容。 这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;基本的 Git 工作流程如下：&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;在工作区中修改文件。&lt;/li&gt;
&lt;li&gt;将你想要下次提交的更改选择性地暂存，这样只会将更改的部分添加到暂存区。&lt;/li&gt;
&lt;li&gt;提交更新，找到暂存区的文件，将快照永久性存储到 Git 目录。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果 Git 目录中保存着特定版本的文件，就属于 &lt;strong&gt;已提交&lt;/strong&gt; 状态。 如果文件已修改并放入暂存区，就属于 &lt;strong&gt;已暂存&lt;/strong&gt; 状态。&lt;/p&gt;
&lt;h3 id=&#34;13-git&#34;&gt;1.3 安装 Git&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;在 Linux 上安装&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果你在基于 Debian 的发行版上，如 Ubuntu，请使用 &lt;code&gt;apt&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-console&#34;&gt;$ sudo apt install git
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;在 Windows上安装&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在windows上可以通过下面的链接直接下载&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;https://git-scm.com/download/win
https://gitforwindows.org/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最新的链接为&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;https://github.com/git-for-windows/git/releases/download/v2.33.0.windows.2/Git-2.33.0.2-64-bit.exe
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;14-git&#34;&gt;1.4 初次运行 Git 前的配置&lt;/h3&gt;
&lt;p&gt;通过以下命令查看所有的配置以及它们所在的文件：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;git config --list --show-origin
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;用户信息&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;安装完 Git 之后，要做的第一件事就是设置你的用户名和邮件地址。 这一点很重要，因为每一个 Git 提交都会使用这些信息，它们会写入到你的每一次提交中，不可更改：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-console&#34;&gt;$ git config --global user.name &amp;quot;John Doe&amp;quot;
$ git config --global user.email johndoe@example.com
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;文本编辑器&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;既然用户信息已经设置完毕，你可以配置默认文本编辑器了，当 Git 需要你输入信息时会调用它。 如果未配置，Git 会使用操作系统默认的文本编辑器。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-console&#34;&gt;git config --global core.editor EditPlus
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;检查配置信息&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果想要检查你的配置，可以使用 &lt;code&gt;git config --list&lt;/code&gt; 命令来列出所有 Git 当时能找到的配置。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-console&#34;&gt;$ git config --list
user.name=John Doe
user.email=johndoe@example.com
color.status=auto
color.branch=auto
color.interactive=auto
color.diff=auto
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你可以通过输入 &lt;code&gt;git config &amp;lt;key&amp;gt;&lt;/code&gt;： 来检查 Git 的某一项配置&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-console&#34;&gt;$ git config user.name
John Doe
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;15&#34;&gt;1.5 获取帮助&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;获取帮助&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;若你使用 Git 时需要获取帮助，有三种等价的方法可以找到 Git 命令的综合手册（manpage）：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-console&#34;&gt;$ git help &amp;lt;verb&amp;gt;
$ git &amp;lt;verb&amp;gt; --help
$ man git-&amp;lt;verb&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例如，要想获得 &lt;code&gt;git config&lt;/code&gt; 命令的手册，执行&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-console&#34;&gt;$ git help config
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此外，如果你不需要全面的手册，只需要可用选项的快速参考，那么可以用 &lt;code&gt;-h&lt;/code&gt; 选项获得更简明的 “help” 输出：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-console&#34;&gt;$ git add -h
usage: git add [&amp;lt;options&amp;gt;] [--] &amp;lt;pathspec&amp;gt;...

    -n, --dry-run         dry run
    -v, --verbose         be verbose

    -i, --interactive     interactive picking
    -p, --patch           select hunks interactively
    -e, --edit            edit current diff and apply
    -f, --force           allow adding otherwise ignored files
    -u, --update          update tracked files
    --renormalize         renormalize EOL of tracked files (implies -u)
    -N, --intent-to-add   record only the fact that the path will be added later
    -A, --all             add changes from all tracked and untracked files
    --ignore-removal      ignore paths removed in the working tree (same as --no-all)
    --refresh             don&#39;t add, only refresh the index
    --ignore-errors       just skip files which cannot be added because of errors
    --ignore-missing      check if - even missing - files are ignored in dry run
    --chmod (+|-)x        override the executable bit of the listed files
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;2-git&#34;&gt;2. Git基础&lt;/h2&gt;
&lt;h3 id=&#34;21-git&#34;&gt;2.1 获取 Git 仓库&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;获取 Git 仓库&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;通常有两种获取 Git 项目仓库的方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将尚未进行版本控制的本地目录转换为 Git 仓库；&lt;/li&gt;
&lt;li&gt;从其它服务器 &lt;strong&gt;克隆&lt;/strong&gt; 一个已存在的 Git 仓库。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;两种方式都会在你的本地机器上得到一个工作就绪的 Git 仓库。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;在已存在目录中初始化仓库&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果你有一个尚未进行版本控制的项目目录，想要用 Git 来控制它，那么首先需要进入该项目目录中。 如果你还没这样做过，那么不同系统上的做法有些不同：&lt;/p&gt;
&lt;p&gt;在 Linux 上：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-console&#34;&gt;$ cd /home/user/my_project
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在 macOS 上：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-console&#34;&gt;$ cd /Users/user/my_project
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在 Windows 上：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-console&#34;&gt;$ cd /c/user/my_project
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;之后执行：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-console&#34;&gt;$ git init
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该命令将创建一个名为 &lt;code&gt;.git&lt;/code&gt; 的子目录，这个子目录含有你初始化的 Git 仓库中所有的必须文件，这些文件是 Git 仓库的骨干。 但是，在这个时候，我们仅仅是做了一个初始化的操作，你的项目里的文件还没有被跟踪。&lt;/p&gt;
&lt;p&gt;如果在一个已存在文件的文件夹（而非空文件夹）中进行版本控制，你应该开始追踪这些文件并进行初始提交。 可以通过 &lt;code&gt;git add&lt;/code&gt; 命令来指定所需的文件来进行追踪，然后执行 &lt;code&gt;git commit&lt;/code&gt; ：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-console&#34;&gt;$ git add *.c
$ git add LICENSE
$ git commit -m &#39;initial project version&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;克隆现有的仓库&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;克隆仓库的命令是 &lt;code&gt;git clone &amp;lt;url&amp;gt;&lt;/code&gt; 。 比如，要克隆 Git 的链接库 &lt;code&gt;libgit2&lt;/code&gt;，可以用下面的命令：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-console&#34;&gt;$ git clone https://github.com/libgit2/libgit2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你想在克隆远程仓库的时候，自定义本地仓库的名字，你可以通过额外的参数指定新的目录名：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-console&#34;&gt;$ git clone https://github.com/libgit2/libgit2 mylibgit
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;21&#34;&gt;2.1 记录每次更新到仓库&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;检查当前文件状态&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以用 &lt;code&gt;git status&lt;/code&gt; 命令查看哪些文件处于什么状态。 如果在克隆仓库后立即使用此命令，会看到类似这样的输出：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-console&#34;&gt;$ git status
On branch master
Your branch is up-to-date with &#39;origin/master&#39;.
nothing to commit, working directory clean
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在，让我们在项目下创建一个新的 &lt;code&gt;README&lt;/code&gt; 文件。 如果之前并不存在这个文件，使用 &lt;code&gt;git status&lt;/code&gt; 命令，你将看到一个新的未跟踪文件：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-console&#34;&gt;$ echo &#39;My Project&#39; &amp;gt; README
$ git status
On branch master
Your branch is up-to-date with &#39;origin/master&#39;.
Untracked files:
  (use &amp;quot;git add &amp;lt;file&amp;gt;...&amp;quot; to include in what will be committed)

    README

nothing added to commit but untracked files present (use &amp;quot;git add&amp;quot; to track)
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;跟踪新文件&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;使用命令 &lt;code&gt;git add&lt;/code&gt; 开始跟踪一个文件。 所以，要跟踪 &lt;code&gt;README&lt;/code&gt; 文件，运行：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-console&#34;&gt;$ git add README
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此时再运行 &lt;code&gt;git status&lt;/code&gt; 命令，会看到 &lt;code&gt;README&lt;/code&gt; 文件已被跟踪，并处于暂存状态：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-console&#34;&gt;$ git status
On branch master
Your branch is up-to-date with &#39;origin/master&#39;.
Changes to be committed:
  (use &amp;quot;git restore --staged &amp;lt;file&amp;gt;...&amp;quot; to unstage)

    new file:   README
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;暂存已修改的文件&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;现在我们来修改一个已被跟踪的文件。 如果你修改了一个名为 &lt;code&gt;CONTRIBUTING.md&lt;/code&gt; 的已被跟踪的文件，然后运行 &lt;code&gt;git status&lt;/code&gt; 命令，会看到下面内容：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-console&#34;&gt;$ git status
On branch master
Your branch is up-to-date with &#39;origin/master&#39;.
Changes to be committed:
  (use &amp;quot;git reset HEAD &amp;lt;file&amp;gt;...&amp;quot; to unstage)

    new file:   README

Changes not staged for commit:
  (use &amp;quot;git add &amp;lt;file&amp;gt;...&amp;quot; to update what will be committed)
  (use &amp;quot;git checkout -- &amp;lt;file&amp;gt;...&amp;quot; to discard changes in working directory)

    modified:   CONTRIBUTING.md
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;暂存这次更新&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-console&#34;&gt;$ git add CONTRIBUTING.md
$ git status
On branch master
Your branch is up-to-date with &#39;origin/master&#39;.
Changes to be committed:
  (use &amp;quot;git reset HEAD &amp;lt;file&amp;gt;...&amp;quot; to unstage)

    new file:   README
    modified:   CONTRIBUTING.md
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;状态简览&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;git status&lt;/code&gt; 命令的输出十分详细，但其用语有些繁琐。 Git 有一个选项可以帮你缩短状态命令的输出，这样可以以简洁的方式查看更改。 如果你使用 &lt;code&gt;git status -s&lt;/code&gt; 命令或 &lt;code&gt;git status --short&lt;/code&gt; 命令，你将得到一种格式更为紧凑的输出。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;忽略文件&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。 通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。 在这种情况下，我们可以创建一个名为 &lt;code&gt;.gitignore&lt;/code&gt; 的文件，列出要忽略的文件的模式。 来看一个实际的 &lt;code&gt;.gitignore&lt;/code&gt; 例子：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-console&#34;&gt;$ cat .gitignore
*.[oa]
*~
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第一行告诉 Git 忽略所有以 &lt;code&gt;.o&lt;/code&gt; 或 &lt;code&gt;.a&lt;/code&gt; 结尾的文件。一般这类对象文件和存档文件都是编译过程中出现的。 第二行告诉 Git 忽略所有名字以波浪符（~）结尾的文件，许多文本编辑软件（比如 Emacs）都用这样的文件名保存副本。&lt;/p&gt;
&lt;p&gt;文件 &lt;code&gt;.gitignore&lt;/code&gt; 的格式规范如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所有空行或者以 &lt;code&gt;#&lt;/code&gt; 开头的行都会被 Git 忽略。&lt;/li&gt;
&lt;li&gt;可以使用标准的 glob 模式匹配，它会递归地应用在整个工作区中。&lt;/li&gt;
&lt;li&gt;匹配模式可以以（&lt;code&gt;/&lt;/code&gt;）开头防止递归。&lt;/li&gt;
&lt;li&gt;匹配模式可以以（&lt;code&gt;/&lt;/code&gt;）结尾指定目录。&lt;/li&gt;
&lt;li&gt;要忽略指定模式以外的文件或目录，可以在模式前加上叹号（&lt;code&gt;!&lt;/code&gt;）取反。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;查看已暂存和未暂存的修改&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;查看尚未暂存的文件更新了哪些部分，不加参数直接输入 &lt;code&gt;git diff&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-console&#34;&gt;$ git diff
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 8ebb991..643e24f 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -65,7 +65,8 @@ branch directly, things can get messy.
 Please include a nice description of your changes when you submit your PR;
 if we have to read the whole diff to figure out why you&#39;re contributing
 in the first place, you&#39;re less likely to get feedback and have your change
-merged in.
+merged in. Also, split your changes into comprehensive chunks if your patch is
+longer than a dozen lines.

 If you are starting to work on a particular area, feel free to submit a PR
 that highlights your work in progress (and note in the PR title that it&#39;s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看已暂存的将要添加到下次提交里的内容，可以用 &lt;code&gt;git diff --staged&lt;/code&gt; 命令。 这条命令将比对已暂存文件与最后一次提交的文件差异：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-console&#34;&gt;$ git diff --staged
diff --git a/README b/README
new file mode 100644
index 0000000..03902a1
--- /dev/null
+++ b/README
@@ -0,0 +1 @@
+My Project
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;请注意，git diff 本身只显示尚未暂存的改动，而不是自上次提交以来所做的所有改动。 &lt;/p&gt;
&lt;p&gt;&lt;code&gt;git diff --cached&lt;/code&gt; 查看已经暂存起来的变化：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-console&#34;&gt;$ git diff --cached
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 8ebb991..643e24f 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -65,7 +65,8 @@ branch directly, things can get messy.
 Please include a nice description of your changes when you submit your PR;
 if we have to read the whole diff to figure out why you&#39;re contributing
 in the first place, you&#39;re less likely to get feedback and have your change
-merged in.
+merged in. Also, split your changes into comprehensive chunks if your patch is
+longer than a dozen lines.

 If you are starting to work on a particular area, feel free to submit a PR
 that highlights your work in progress (and note in the PR title that it&#39;s
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;提交更新&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;运行提交命令 &lt;code&gt;git commit&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-console&#34;&gt;$ git commit
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另外，你也可以在 &lt;code&gt;commit&lt;/code&gt; 命令后添加 &lt;code&gt;-m&lt;/code&gt; 选项，将提交信息与命令放在同一行，如下所示：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-console&#34;&gt;$ git commit -m &amp;quot;Story 182: Fix benchmarks for speed&amp;quot;
[master 463dc4f] Story 182: Fix benchmarks for speed
 2 files changed, 2 insertions(+)
 create mode 100644 README
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;每次准备提交前，先用 &lt;code&gt;git status&lt;/code&gt; 看下，你所需要的文件是不是都已暂存起来了， 然后再运行提交命令 &lt;code&gt;git commit&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;跳过使用暂存区域&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;尽管使用暂存区域的方式可以精心准备要提交的细节，但有时候这么做略显繁琐。 Git 提供了一个跳过使用暂存区域的方式， 只要在提交的时候，给 &lt;code&gt;git commit&lt;/code&gt; 加上 &lt;code&gt;-a&lt;/code&gt; 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 &lt;code&gt;git add&lt;/code&gt; 步骤：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;$ git commit -a -m &#39;added new benchmarks&#39;
[master 83e38c7] added new benchmarks
 1 file changed, 5 insertions(+), 0 deletions(-)
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;移除文件&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除（确切地说，是从暂存区域移除），然后提交。 可以用 &lt;code&gt;git rm&lt;/code&gt; 命令完成此项工作，并连带从工作目录中删除指定的文件，这样以后就不会出现在未跟踪文件清单中了。&lt;/p&gt;
&lt;p&gt;如果只是简单地从工作目录中手工删除文件，运行 &lt;code&gt;git status&lt;/code&gt; 时就会在 “Changes not staged for commit” 部分（也就是 &lt;em&gt;未暂存清单&lt;/em&gt;）看到：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-console&#34;&gt;$ rm PROJECTS.md
$ git status
On branch master
Your branch is up-to-date with &#39;origin/master&#39;.
Changes not staged for commit:
  (use &amp;quot;git add/rm &amp;lt;file&amp;gt;...&amp;quot; to update what will be committed)
  (use &amp;quot;git checkout -- &amp;lt;file&amp;gt;...&amp;quot; to discard changes in working directory)

        deleted:    PROJECTS.md

no changes added to commit (use &amp;quot;git add&amp;quot; and/or &amp;quot;git commit -a&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后再运行 &lt;code&gt;git rm&lt;/code&gt; 记录此次移除文件的操作：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-console&#34;&gt;$ git rm PROJECTS.md
rm &#39;PROJECTS.md&#39;
$ git status
On branch master
Your branch is up-to-date with &#39;origin/master&#39;.
Changes to be committed:
  (use &amp;quot;git reset HEAD &amp;lt;file&amp;gt;...&amp;quot; to unstage)

    deleted:    PROJECTS.md
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下一次提交时，该文件就不再纳入版本管理了。 如果要删除之前修改过或已经放到暂存区的文件，则必须使用强制删除选项 &lt;code&gt;-f&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;另外一种情况是，我们想把文件从 Git 仓库中删除（亦即从暂存区域移除），但仍然希望保留在当前工作目录中。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-console&#34;&gt;$ git rm --cached README
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;git rm&lt;/code&gt; 命令后面可以列出文件或者目录的名字，也可以使用 &lt;code&gt;glob&lt;/code&gt; 模式。比如：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-console&#34;&gt;$ git rm log/\*.log
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意到星号 &lt;code&gt;*&lt;/code&gt; 之前的反斜杠 &lt;code&gt;\&lt;/code&gt;， 因为 Git 有它自己的文件模式扩展匹配方式，所以我们不用 shell 来帮忙展开。 此命令删除 &lt;code&gt;log/&lt;/code&gt; 目录下扩展名为 &lt;code&gt;.log&lt;/code&gt; 的所有文件。 类似的比如：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-console&#34;&gt;$ git rm \*~
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该命令会删除所有名字以 &lt;code&gt;~&lt;/code&gt; 结尾的文件。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;移动文件&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;要在 Git 中对文件改名，可以这么做：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-console&#34;&gt;$ git mv file_from file_to
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看状态信息，会明白无误地看到关于重命名操作的说明：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-console&#34;&gt;$ git mv README.md README
$ git status
On branch master
Your branch is up-to-date with &#39;origin/master&#39;.
Changes to be committed:
  (use &amp;quot;git reset HEAD &amp;lt;file&amp;gt;...&amp;quot; to unstage)

    renamed:    README.md -&amp;gt; README
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其实，运行 &lt;code&gt;git mv&lt;/code&gt; 就相当于运行了下面三条命令：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-console&#34;&gt;$ mv README.md README
$ git rm README.md
$ git add README
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;22&#34;&gt;2.2 查看提交历史&lt;/h3&gt;
&lt;p&gt;在提交了若干更新，又或者克隆了某个项目之后，你也许想回顾下提交历史。 完成这个任务最简单而又有效的工具是 &lt;code&gt;git log&lt;/code&gt; 命令。&lt;/p&gt;
&lt;p&gt;当你在此项目中运行 &lt;code&gt;git log&lt;/code&gt; 命令时，可以看到下面的输出：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-console&#34;&gt;$ git log
commit ca82a6dff817ec66f44342007202690a93763949
Author: Scott Chacon &amp;lt;schacon@gee-mail.com&amp;gt;
Date:   Mon Mar 17 21:52:11 2008 -0700

    changed the version number

commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
Author: Scott Chacon &amp;lt;schacon@gee-mail.com&amp;gt;
Date:   Sat Mar 15 16:40:33 2008 -0700

    removed unnecessary test

commit a11bef06a3f659402fe7563abf99ad00de2209e6
Author: Scott Chacon &amp;lt;schacon@gee-mail.com&amp;gt;
Date:   Sat Mar 15 10:31:28 2008 -0700

    first commit
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不传入任何参数的默认情况下，&lt;code&gt;git log&lt;/code&gt; 会按时间先后顺序列出所有的提交，最近的更新排在最上面。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git log&lt;/code&gt; 有许多选项可以帮助你搜寻你所要找的提交， 下面我们会介绍几个最常用的选项。&lt;/p&gt;
&lt;p&gt;其中一个比较有用的选项是 &lt;code&gt;-p&lt;/code&gt; 或 &lt;code&gt;--patch&lt;/code&gt; ，它会显示每次提交所引入的差异（按 &lt;strong&gt;补丁&lt;/strong&gt; 的格式输出）。 你也可以限制显示的日志条目数量，例如使用 &lt;code&gt;-2&lt;/code&gt; 选项来只显示最近的两次提交：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-console&#34;&gt;$ git log -p -2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以为 &lt;code&gt;git log&lt;/code&gt; 附带一系列的总结性选项。 比如你想看到每次提交的简略统计信息，可以使用 &lt;code&gt;--stat&lt;/code&gt; 选项：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-console&#34;&gt;$ git log --stat
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;23&#34;&gt;2.3 撤消操作&lt;/h3&gt;
&lt;p&gt;有时候我们提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了。 此时，可以运行带有 &lt;code&gt;--amend&lt;/code&gt; 选项的提交命令来重新提交：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-console&#34;&gt;$ git commit --amend
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个命令会将暂存区中的文件提交。 &lt;/p&gt;
&lt;p&gt;例如，你提交后发现忘记了暂存某些需要的修改，可以像下面这样操作：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-console&#34;&gt;$ git commit -m &#39;initial commit&#39;
$ git add forgotten_file
$ git commit --amend
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最终你只会有一个提交——第二次提交将代替第一次提交的结果。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;取消暂存的文件&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;使用 &lt;code&gt;git reset HEAD &amp;lt;file&amp;gt;...&lt;/code&gt; 来取消暂存。 所以，我们可以这样来取消暂存 &lt;code&gt;CONTRIBUTING.md&lt;/code&gt; 文件：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-console&#34;&gt;$ git reset HEAD CONTRIBUTING.md
Unstaged changes after reset:
M    CONTRIBUTING.md
$ git status
On branch master
Changes to be committed:
  (use &amp;quot;git reset HEAD &amp;lt;file&amp;gt;...&amp;quot; to unstage)

    renamed:    README.md -&amp;gt; README

Changes not staged for commit:
  (use &amp;quot;git add &amp;lt;file&amp;gt;...&amp;quot; to update what will be committed)
  (use &amp;quot;git checkout -- &amp;lt;file&amp;gt;...&amp;quot; to discard changes in working directory)

    modified:   CONTRIBUTING.md
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个命令有点儿奇怪，但是起作用了。 &lt;code&gt;CONTRIBUTING.md&lt;/code&gt; 文件已经是修改未暂存的状态了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;撤消对文件的修改&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果你并不想保留对 &lt;code&gt;CONTRIBUTING.md&lt;/code&gt; 文件的修改怎么办？ 你该如何方便地撤消修改——将它还原成上次提交时的样子.&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-console&#34;&gt;$ git checkout -- CONTRIBUTING.md
$ git status
On branch master
Changes to be committed:
  (use &amp;quot;git reset HEAD &amp;lt;file&amp;gt;...&amp;quot; to unstage)

    renamed:    README.md -&amp;gt; README
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;24&#34;&gt;2.4 远程仓库的使用&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;查看远程仓库&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果想查看你已经配置的远程仓库服务器，可以运行 &lt;code&gt;git remote&lt;/code&gt; 命令。 它会列出你指定的每一个远程服务器的简写。 如果你已经克隆了自己的仓库，那么至少应该能看到 origin ——这是 Git 给你克隆的仓库服务器的默认名字：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-console&#34;&gt;$ git clone https://github.com/schacon/ticgit
Cloning into &#39;ticgit&#39;...
remote: Reusing existing pack: 1857, done.
remote: Total 1857 (delta 0), reused 0 (delta 0)
Receiving objects: 100% (1857/1857), 374.35 KiB | 268.00 KiB/s, done.
Resolving deltas: 100% (772/772), done.
Checking connectivity... done.
$ cd ticgit
$ git remote
origin
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你也可以指定选项 &lt;code&gt;-v&lt;/code&gt;，会显示需要读写远程仓库使用的 Git 保存的简写与其对应的 URL。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-console&#34;&gt;$ git remote -v
origin    https://github.com/schacon/ticgit (fetch)
origin    https://github.com/schacon/ticgit (push)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你的远程仓库不止一个，该命令会将它们全部列出。 例如，与几个协作者合作的，拥有多个远程仓库的仓库看起来像下面这样：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-console&#34;&gt;$ cd grit
$ git remote -v
bakkdoor  https://github.com/bakkdoor/grit (fetch)
bakkdoor  https://github.com/bakkdoor/grit (push)
cho45     https://github.com/cho45/grit (fetch)
cho45     https://github.com/cho45/grit (push)
defunkt   https://github.com/defunkt/grit (fetch)
defunkt   https://github.com/defunkt/grit (push)
koke      git://github.com/koke/grit.git (fetch)
koke      git://github.com/koke/grit.git (push)
origin    git@github.com:mojombo/grit.git (fetch)
origin    git@github.com:mojombo/grit.git (push)
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;添加远程仓库&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;运行 &lt;code&gt;git remote add &amp;lt;shortname&amp;gt; &amp;lt;url&amp;gt;&lt;/code&gt; 添加一个新的远程 Git 仓库，同时指定一个方便使用的简写：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-console&#34;&gt;$ git remote
origin
$ git remote add pb https://github.com/paulboone/ticgit
$ git remote -v
origin    https://github.com/schacon/ticgit (fetch)
origin    https://github.com/schacon/ticgit (push)
pb    https://github.com/paulboone/ticgit (fetch)
pb    https://github.com/paulboone/ticgit (push)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在你可以在命令行中使用字符串 &lt;code&gt;pb&lt;/code&gt; 来代替整个 URL。 例如，如果你想拉取 Paul 的仓库中有但你没有的信息，可以运行 &lt;code&gt;git fetch pb&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-console&#34;&gt;$ git fetch pb
remote: Counting objects: 43, done.
remote: Compressing objects: 100% (36/36), done.
remote: Total 43 (delta 10), reused 31 (delta 5)
Unpacking objects: 100% (43/43), done.
From https://github.com/paulboone/ticgit
 * [new branch]      master     -&amp;gt; pb/master
 * [new branch]      ticgit     -&amp;gt; pb/ticgit
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;从远程仓库中抓取与拉取&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;从远程仓库中获得数据，可以执行：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-console&#34;&gt;$ git fetch &amp;lt;remote&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;推送到远程仓库&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-console&#34;&gt;$ git push origin master
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;查看某个远程仓库&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果想要查看某一个远程仓库的更多信息，可以使用 &lt;code&gt;git remote show &amp;lt;remote&amp;gt;&lt;/code&gt; 命令。 如果想以一个特定的缩写名运行这个命令，例如 &lt;code&gt;origin&lt;/code&gt;，会得到像下面类似的信息：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-console&#34;&gt;$ git remote show origin
* remote origin
  Fetch URL: https://github.com/schacon/ticgit
  Push  URL: https://github.com/schacon/ticgit
  HEAD branch: master
  Remote branches:
    master                               tracked
    dev-branch                           tracked
  Local branch configured for &#39;git pull&#39;:
    master merges with remote master
  Local ref configured for &#39;git push&#39;:
    master pushes to master (up to date)
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;远程仓库的重命名与移除&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;运行 &lt;code&gt;git remote rename&lt;/code&gt; 来修改一个远程仓库的简写名。 例如，想要将 &lt;code&gt;pb&lt;/code&gt; 重命名为 &lt;code&gt;paul&lt;/code&gt;，可以用 &lt;code&gt;git remote rename&lt;/code&gt; 这样做：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-console&#34;&gt;$ git remote rename pb paul
$ git remote
origin
paul
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用 &lt;code&gt;git remote remove&lt;/code&gt; 或 &lt;code&gt;git remote rm&lt;/code&gt; 来移除一个远程仓库：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-console&#34;&gt;$ git remote remove paul
$ git remote
origin
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;25&#34;&gt;2.5 打标签&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;列出标签&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在 Git 中列出已有的标签非常简单，只需要输入 &lt;code&gt;git tag&lt;/code&gt; （可带上可选的 &lt;code&gt;-l&lt;/code&gt; 选项 &lt;code&gt;--list&lt;/code&gt;）：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-console&#34;&gt;$ git tag
v1.0
v2.0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你也可以按照特定的模式查找标签。 例如，Git 自身的源代码仓库包含标签的数量超过 500 个。 如果只对 1.8.5 系列感兴趣，可以运行：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-console&#34;&gt;$ git tag -l &amp;quot;v1.8.5*&amp;quot;
v1.8.5
v1.8.5-rc0
v1.8.5-rc1
v1.8.5-rc2
v1.8.5-rc3
v1.8.5.1
v1.8.5.2
v1.8.5.3
v1.8.5.4
v1.8.5.5
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;创建标签&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Git 支持两种标签：轻量标签（lightweight）与附注标签（annotated）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;附注标签&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在 Git 中创建附注标签十分简单。 最简单的方式是当你在运行 &lt;code&gt;tag&lt;/code&gt; 命令时指定 &lt;code&gt;-a&lt;/code&gt; 选项：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-console&#34;&gt;$ git tag -a v1.4 -m &amp;quot;my version 1.4&amp;quot;
$ git tag
v0.1
v1.3
v1.4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;-m&lt;/code&gt; 选项指定了一条将会存储在标签中的信息。&lt;/p&gt;
&lt;p&gt;通过使用 &lt;code&gt;git show&lt;/code&gt; 命令可以看到标签信息和与之对应的提交信息：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-console&#34;&gt;$ git show v1.4
tag v1.4
Tagger: Ben Straub &amp;lt;ben@straub.cc&amp;gt;
Date:   Sat May 3 20:19:12 2014 -0700

my version 1.4

commit ca82a6dff817ec66f44342007202690a93763949
Author: Scott Chacon &amp;lt;schacon@gee-mail.com&amp;gt;
Date:   Mon Mar 17 21:52:11 2008 -0700

    changed the version number
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出显示了打标签者的信息、打标签的日期时间、附注信息，然后显示具体的提交信息。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;轻量标签&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另一种给提交打标签的方式是使用轻量标签。 轻量标签本质上是将提交校验和存储到一个文件中——没有保存任何其他信息。 创建轻量标签，不需要使用 &lt;code&gt;-a&lt;/code&gt;、&lt;code&gt;-s&lt;/code&gt; 或 &lt;code&gt;-m&lt;/code&gt; 选项，只需要提供标签名字：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-console&#34;&gt;$ git tag v1.4-lw
$ git tag
v0.1
v1.3
v1.4
v1.4-lw
v1.5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这时，如果在标签上运行 &lt;code&gt;git show&lt;/code&gt;，你不会看到额外的标签信息。 命令只会显示出提交信息：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-console&#34;&gt;$ git show v1.4-lw
commit ca82a6dff817ec66f44342007202690a93763949
Author: Scott Chacon &amp;lt;schacon@gee-mail.com&amp;gt;
Date:   Mon Mar 17 21:52:11 2008 -0700

    changed the version number
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;删除标签&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;要删除掉你本地仓库上的标签，可以使用命令 &lt;code&gt;git tag -d &amp;lt;tagname&amp;gt;&lt;/code&gt;。 例如，可以使用以下命令删除一个轻量标签：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-console&#34;&gt;$ git tag -d v1.4-lw
Deleted tag &#39;v1.4-lw&#39; (was e7d5add)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意上述命令并不会从任何远程仓库中移除这个标签，你必须用 &lt;code&gt;git push &amp;lt;remote&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;检出标签&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;查看某个标签所指向的文件版本，可以使用 &lt;code&gt;git checkout&lt;/code&gt; 命令：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-console&#34;&gt;$ git checkout 2.0.0
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;26-git&#34;&gt;2.6 Git 别名&lt;/h3&gt;
&lt;p&gt;如果不想每次都输入完整的 Git 命令，可以通过 &lt;code&gt;git config&lt;/code&gt; 文件来轻松地为每一个命令设置一个别名。 这里有一些例子你可以试试：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-console&#34;&gt;$ git config --global alias.co checkout
$ git config --global alias.br branch
$ git config --global alias.ci commit
$ git config --global alias.st status
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这意味着，当要输入 &lt;code&gt;git commit&lt;/code&gt; 时，只需要输入 &lt;code&gt;git ci&lt;/code&gt;。 &lt;/p&gt;
&lt;h2 id=&#34;3&#34;&gt;3. 分支简介&lt;/h2&gt;
&lt;h3 id=&#34;31&#34;&gt;3.1 分支简介&lt;/h3&gt;
&lt;p&gt;Git 保存的不是文件的变化或者差异，而是一系列不同时刻的快照 。在进行提交操作时，Git 会保存一个提交对象（commit object）。 知道了 Git 保存数据的方式，我们可以很自然的想到——该提交对象会包含一个指向暂存内容快照的指针。 但不仅仅是这样，该提交对象还包含了作者的姓名和邮箱、提交时输入的信息以及指向它的父对象的指针。 首次提交产生的提交对象没有父对象，普通提交操作产生的提交对象有一个父对象， 而由多个分支合并产生的提交对象有多个父对象&lt;/p&gt;
&lt;h3 id=&#34;32&#34;&gt;3.2 分支的新建与合并&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;新建分支&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;首先，我们假设你正在你的项目上工作，并且在 &lt;code&gt;master&lt;/code&gt; 分支上已经有了一些提交。现在，你已经决定要解决你的公司使用的问题追踪系统中的 #53 问题。 想要新建一个分支并同时切换到那个分支上，你可以运行一个带有 &lt;code&gt;-b&lt;/code&gt; 参数的 &lt;code&gt;git checkout&lt;/code&gt; 命令：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-console&#34;&gt;$ git checkout -b iss53
Switched to a new branch &amp;quot;iss53&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;它是下面两条命令的简写：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-console&#34;&gt;$ git branch iss53
$ git checkout iss53
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;分支的合并&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;假设你已经修正了 #53 问题，并且打算将你的工作合并入 &lt;code&gt;master&lt;/code&gt; 分支。 为此，你需要合并 &lt;code&gt;iss53&lt;/code&gt; 分支到 &lt;code&gt;master&lt;/code&gt; 分支，然后运行 &lt;code&gt;git merge&lt;/code&gt; 命令：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-console&#34;&gt;$ git checkout master
Switched to branch &#39;master&#39;
$ git merge iss53
Merge made by the &#39;recursive&#39; strategy.
index.html |    1 +
1 file changed, 1 insertion(+)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;既然你的修改已经合并进来了，就不再需要 &lt;code&gt;iss53&lt;/code&gt; 分支了。 现在你可以在任务追踪系统中关闭此项任务，并删除这个分支。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-console&#34;&gt;$ git branch -d iss53
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;33&#34;&gt;3.3 分支管理&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;git branch&lt;/code&gt; 命令不只是可以创建与删除分支。 如果不加任何参数运行它，会得到当前所有分支的一个列表：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-console&#34;&gt;$ git branch
  iss53
* master
  testing
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意 &lt;code&gt;master&lt;/code&gt; 分支前的 &lt;code&gt;*&lt;/code&gt; 字符：它代表现在检出的那一个分支.&lt;/p&gt;
&lt;p&gt;查看每一个分支的最后一次提交，可以运行 &lt;code&gt;git branch -v&lt;/code&gt; 命令：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-console&#34;&gt;$ git branch -v
  iss53   93b412c fix javascript issue
* master  7a98805 Merge branch &#39;iss53&#39;
  testing 782fd34 add scott to the author list in the readmes
&lt;/code&gt;&lt;/pre&gt;</description>  
      <pubDate>2025-10-09 17:54:40</pubDate>  
      <link>https://testpoo.github.io/Git简介.html</link>  
      <guid isPermaLink="true">https://testpoo.github.io/Git简介.html</guid>
       
      <category>技术</category> 
      
    </item>
    
    <item> 
      <title>Python正则表达式</title>  
      <description>&lt;div class=&#34;toc&#34;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#_1&#34;&gt;一、正则表达式语法&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1&#34;&gt;1.表达式全集&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2&#34;&gt;2.常用正则表达式&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#re&#34;&gt;二、re模块简介&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#re_1&#34;&gt;三、re模块常量&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-ignorecase&#34;&gt;1. IGNORECASE&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-ascii&#34;&gt;2. ASCII&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3-dotall&#34;&gt;3. DOTALL&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4-multiline&#34;&gt;4. MULTILINE&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5-verbose&#34;&gt;5. VERBOSE&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#6-locale&#34;&gt;6. LOCALE&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#7-unicode&#34;&gt;7. UNICODE&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#8-debug&#34;&gt;8. DEBUG&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#9-template&#34;&gt;9. TEMPLATE&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#10&#34;&gt;10. 常量总结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#re_2&#34;&gt;四、re模块函数&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1_1&#34;&gt;1. 查找一个匹配项&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2_1&#34;&gt;2.查找多个匹配项&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3&#34;&gt;3. 分割&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4&#34;&gt;4. 替换&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5&#34;&gt;5. 编译正则对象&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#6&#34;&gt;6. 其他&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#re_3&#34;&gt;五、re模块异常&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_2&#34;&gt;六、注意事项&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1_2&#34;&gt;1. 字节串与字符串&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2r&#34;&gt;2.r 的作用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3_1&#34;&gt;3.正则查找函数 返回匹配对象&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4_1&#34;&gt;4.重复使用某个正则&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Python正则表达式&lt;/strong&gt;
今天我们主要来讲解一下正则表达式在Python语言中的应用！
大多数编程语言的正则表达式设计都师从Perl，所以语法基本相似，不同的是每种语言都有自己的函数去支持正则，今天我们就来学习 Python中关于正则表达式的函数。&lt;/p&gt;
&lt;h3 id=&#34;_1&#34;&gt;一、正则表达式语法&lt;/h3&gt;
&lt;p&gt;一个正则表达式指定了一集与之匹配的字符串；模块内的函数可以让你检查某个字符串是否跟给定的正则表达式匹配。&lt;/p&gt;
&lt;h4 id=&#34;1&#34;&gt;1.表达式全集&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;字符&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;.&lt;/td&gt;
&lt;td&gt;匹配除“\n”之外的任何单个字符。如果指定了标签 DOTALL ，它将匹配包括换行符的任意字符。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;^&lt;/td&gt;
&lt;td&gt;匹配输入字符串的开始位置，并且在 MULTILINE 模式也匹配换行后的首个符号。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$&lt;/td&gt;
&lt;td&gt;匹配输入字符串的结束位置。在 MULTILINE 模式下也会匹配换行符之前的文本。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;匹配前面的子表达式零次或多次。例如，ab* 会匹配 &#39;a&#39;，&#39;ab&#39;，或者 &#39;a&#39; 后面跟随任意个 &#39;b&#39;。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;+&lt;/td&gt;
&lt;td&gt;匹配前面的子表达式一次或多次。例如， ab+ 会匹配 &#39;a&#39; 后面跟随1个以上到任意个 &#39;b&#39;，它不会匹配 &#39;a&#39;。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;?&lt;/td&gt;
&lt;td&gt;匹配前面的子表达式零次或一次。例如，ab? 会匹配 &#39;a&#39; 或者 &#39;ab&#39;。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;*?, +?, ??&lt;/td&gt;
&lt;td&gt;&#39;&lt;em&gt;&#39;, &#39;+&#39;，和 &#39;?&#39; 修饰符都是贪婪的；它们在字符串进行尽可能多的匹配。有时候并不需要这种行为。如果正则式 &amp;lt;.&lt;/em&gt;&amp;gt; 希望找到 &#39;&lt;a&gt; b &lt;c&gt;&#39;，它将会匹配整个字符串，而不仅是 &#39;&lt;a&gt;&#39;。在修饰符之后添加 ? 将使样式以非贪婪方式或者最小方式进行匹配；尽量少的字符将会被匹配。使用正则式 &amp;lt;.*?&amp;gt; 将会仅仅匹配 &#39;&lt;a&gt;&#39;。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;{m}&lt;/td&gt;
&lt;td&gt;m是一个非负整数。匹配确定m次。例如， a{6} 将匹配6个 &#39;a&#39; , 但是不能是5个。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;{m,n}&lt;/td&gt;
&lt;td&gt;对正则式进行 m 到 n 次匹配，在 m 和 n 之间取尽量多。例如，a{3,5} 将匹配 3 到 5个 &#39;a&#39;。忽略 m 意为指定下界为0，忽略 n 指定上界为无限次。 比如 a{4,}b 将匹配 &#39;aaaab&#39; 或者1000个 &#39;a&#39; 尾随一个 &#39;b&#39;，但不能匹配 &#39;aaab&#39;。逗号不能省略，否则无法辨别修饰符应该忽略哪个边界。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;{n,m}?&lt;/td&gt;
&lt;td&gt;前一个修饰符的非贪婪模式，只匹配尽量少的字符次数。比如，对于 &#39;aaaaaa&#39;， a{3,5} 匹配 5个 &#39;a&#39; ，而 a{3,5}? 只匹配3个 &#39;a&#39;。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\&lt;/td&gt;
&lt;td&gt;将下一个字符标记为一个特殊字符、或一个原义字符、或一个向后引用、或一个八进制转义符。例如，“n”匹配字符“n”。“\n”匹配一个换行符。串行“\”匹配“\”而“(”则匹配“(”。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;[]&lt;/td&gt;
&lt;td&gt;字符可以单独列出，比如 [amk] 匹配 &#39;a&#39;， &#39;m&#39;， 或者 &#39;k&#39;。&lt;br/&gt;可以表示字符范围，通过用 &#39;-&#39; 将两个字符连起来。比如 [a-z] 将匹配任何小写ASCII字符， [0-5][0-9] 将匹配从 00 到 59 的两位数字， [0-9A-Fa-f] 将匹配任何十六进制数位。 如果 - 进行了转义 （比如 [a-z]）或者它的位置在首位或者末尾（如 [-a] 或 [a-]），它就只表示普通字符 &#39;-&#39;。&lt;br/&gt;特殊字符在集合中，失去它的特殊含义。比如 [(+&lt;em&gt;)] 只会匹配这几个文法字符 &#39;(&#39;, &#39;+&#39;, &#39;&lt;/em&gt;&#39;, or &#39;)&#39;。&lt;br/&gt;字符类如 \w 或者 \S (如下定义) 在集合内可以接受，它们可以匹配的字符由 ASCII 或者 LOCALE 模式决定。&lt;br/&gt;不在集合范围内的字符可以通过取反来进行匹配。如果集合首字符是 &#39;^&#39; ，所有不在集合内的字符将会被匹配，比如 [^5] 将匹配所有字符，除了&#39;5&#39;，[^^] 将匹配所有字符，除了&#39;^&#39;。^ 如果不在集合首位，就没有特殊含义。&lt;br/&gt;在集合内要匹配一个字符 &#39;]&#39;，有两种方法，要么就在它之前加上反斜杠，要么就把它放到集合首位。比如， [()[]{}] 和 &lt;a href=&#34;&#34;&gt;&lt;/a&gt;[{}] 都可以匹配括号。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;|&lt;/td&gt;
&lt;td&gt;A|B， A 和 B 可以是任意正则表达式，创建一个正则表达式，匹配 A 或者 B. 任意个正则表达式可以用 &#39;|&#39; 连接。它也可以在组合（见下列）内使用。扫描目标字符串时， &#39;|&#39; 分隔开的正则样式从左到右进行匹配。当一个样式完全匹配时，这个分支就被接受。意思就是，一旦 A 匹配成功， B 就不再进行匹配，即便它能产生一个更好的匹配。或者说，&#39;|&#39; 操作符绝不贪婪。 如果要匹配 &#39;|&#39; 字符，使用 \|， 或者把它包含在字符集里，比如 [|].&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;(pattern)&lt;/td&gt;
&lt;td&gt;匹配pattern并获取这一匹配。要匹配圆括号字符，请使用“(”或“)”。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;(?:pattern)&lt;/td&gt;
&lt;td&gt;匹配pattern但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用或字符“(|)”来组合一个模式的各个部分是很有用。例如“industr(?:y|ies)”就是一个比“industry|industries”更简略的表达式。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;(?=pattern)&lt;/td&gt;
&lt;td&gt;正向肯定预查，在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，“Windows(?=95|98|NT|2000)”能匹配“Windows2000”中的“Windows”，但不能匹配“Windows3.1”中的“Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;(?!pattern)&lt;/td&gt;
&lt;td&gt;正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如“Windows(?!95|98|NT|2000)”能匹配“Windows3.1”中的“Windows”，但不能匹配“Windows2000”中的“Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;(?&amp;lt;=pattern)&lt;/td&gt;
&lt;td&gt;反向肯定预查，与正向肯定预查类拟，只是方向相反。例如，“(?&amp;lt;=95|98|NT|2000)Windows”能匹配“2000Windows”中的“Windows”，但不能匹配“3.1Windows”中的“Windows”。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;(?&amp;lt;!pattern)&lt;/td&gt;
&lt;td&gt;反向否定预查，与正向否定预查类拟，只是方向相反。例如“(?&amp;lt;!95|98|NT|2000)Windows”能匹配“3.1Windows”中的“Windows”，但不能匹配“2000Windows”中的“Windows”。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\number&lt;/td&gt;
&lt;td&gt;匹配数字代表的组合。每个括号是一个组合，组合从1开始编号。比如 (.+) \1 匹配 &#39;the the&#39; 或者 &#39;55 55&#39;, 但不会匹配 &#39;thethe&#39; (注意组合后面的空格)。这个特殊序列只能用于匹配前面99个组合。如果 number 的第一个数位是0， 或者 number 是三个八进制数，它将不会被看作是一个组合，而是八进制的数字值。在 &#39;[&#39; 和 &#39;]&#39; 字符集合内，任何数字转义都被看作是字符。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\A&lt;/td&gt;
&lt;td&gt;只匹配字符串开始&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\b&lt;/td&gt;
&lt;td&gt;匹配一个单词边界，也就是指单词和空格间的位置。例如，“er\b”可以匹配“never”中的“er”，但不能匹配“verb”中的“er”。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\B&lt;/td&gt;
&lt;td&gt;匹配非单词边界。“er\B”能匹配“verb”中的“er”，但不能匹配“never”中的“er”。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\d&lt;/td&gt;
&lt;td&gt;匹配一个数字字符。等价于[0-9]。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\D&lt;/td&gt;
&lt;td&gt;匹配一个非数字字符。等价于[^0-9]。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\s&lt;/td&gt;
&lt;td&gt;匹配任何空白字符，包括空格、制表符、换页符等等。等价于[ \f\n\r\t\v]。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\S&lt;/td&gt;
&lt;td&gt;匹配任何非空白字符。等价于[^ \f\n\r\t\v]。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\w&lt;/td&gt;
&lt;td&gt;匹配包括下划线的任何单词字符。等价于“[A-Za-z0-9_]”。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\W&lt;/td&gt;
&lt;td&gt;匹配任何非单词字符。等价于“[^A-Za-z0-9_]”。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\Z&lt;/td&gt;
&lt;td&gt;只匹配字符串尾。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;绝大部分Python的标准转义字符也被正则表达式分析器支持:&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;\a，\b，\f，\n，\N，\r，\t，\u，\U，\v，\x，\\
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;2&#34;&gt;2.常用正则表达式&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名称&lt;/th&gt;
&lt;th&gt;内容&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;用户名&lt;/td&gt;
&lt;td&gt;&lt;code&gt;/^[a-z0-9_-]{3,16}$/&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;密码&lt;/td&gt;
&lt;td&gt;&lt;code&gt;/^[a-z0-9_-]{6,18}$/&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;十六进制值&lt;/td&gt;
&lt;td&gt;&lt;code&gt;/^#?([a-f0-9]{6}&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;电子邮箱&lt;/td&gt;
&lt;td&gt;&lt;code&gt;/^([a-z0-9_\.-]+)@([\da-z\.-]+)\.([a-z\.]{2,6})$/&amp;lt;br /&amp;gt;/^[a-z\d]+(\.[a-z\d]+)*@([\da-z](-[\da-z])?)+(\.{1,2}[a-z]+)+$/&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;URL&lt;/td&gt;
&lt;td&gt;&lt;code&gt;/^(https?:\/\/)?([\da-z\.-]+)\.([a-z\.]{2,6})([\/\w \.-]*)*\/?$/&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;IP 地址&lt;/td&gt;
&lt;td&gt;&lt;code&gt;/((2[0-4]\d|25[0-5]|[01]?\d\d?)\.){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)/&lt;/code&gt; &lt;br /&gt; &lt;code&gt;/^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;re&#34;&gt;二、re模块简介&lt;/h3&gt;
&lt;p&gt;re模块主要定义了9个常量、12个函数、1个异常！&lt;/p&gt;
&lt;p&gt;关于Python正则表达式的支持，首先肯定会想到re库，这是一个Python处理文本的标准库。&lt;/p&gt;
&lt;p&gt;标准库的意思表示这是一个Python内置模块，不需要额外下载，目前Python内置模块大概有300个。可以在这里查看Python所有的内置模块：https://docs.python.org/3/py-modindex.html&lt;/p&gt;
&lt;p&gt;因为re是内置模块，所以不需要再下载，使用时直接引入即可：&lt;code&gt;import re&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;re模块官方文档：&lt;a href=&#34;https://docs.python.org/zh-cn/3.8/library/re.html&#34;&gt;https://docs.python.org/zh-cn/3.8/library/re.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;re模块库源码：&lt;a href=&#34;https://github.com/python/cpython/blob/3.8/Lib/re.py&#34;&gt;https://github.com/python/cpython/blob/3.8/Lib/re.py&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;re_1&#34;&gt;三、re模块常量&lt;/h3&gt;
&lt;p&gt;常量即表示不可更改的变量，一般用于做标记。&lt;/p&gt;
&lt;p&gt;re模块中有9个常量，如下。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;ASCII = A = sre_compile.SRE_FLAG_ASCII # assume sacii &amp;quot;locale&amp;quot;
IGNORECASE = I = sre_compile.SRE_FLAG_IGNORECASE # ignore case
LOCALE = L = sre_compile.SRE_FLAG_LOCALE # assume current 8-bit locale
UNICODE = U = sre_compile.SRE_FLAG_UNICODE # assume unicode &amp;quot;locale&amp;quot;
MUJLTILINE = M = sre_compile.SRE_FLAG_MULTILINE # make anchors look for newline
DOTALL = S = sre_compile.SRE_FLAG_DOTALL # make dot match newline
VERBOSE = X = sre_compile.SRE_FLAG_VERBOSE # ignore whitespace and comments
# sre extensions (experimental, don&#39;t rely on these)
TEMPLATE = T = sre_compile.SRE_FLAG_TEMPLATE # disable backtracking
DEBUG = sre_compile.SRE_FLAG_DEBUG # dump pattern after compilation
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;int(re.I) == 2 == 2&lt;sup&gt;1&lt;/sup&gt;&lt;br /&gt;
int(re.A) == 256 == 2&lt;sup&gt;8&lt;/sup&gt;&lt;br /&gt;
int(re.L) == 4 == 2&lt;sup&gt;2&lt;/sup&gt;&lt;br /&gt;
int(re.U) == 32 == 2&lt;sup&gt;5&lt;/sup&gt;&lt;br /&gt;
int(re.M) == 8 == 2&lt;sup&gt;3&lt;/sup&gt;&lt;br /&gt;
int(re.S) == 16 == 2&lt;sup&gt;4&lt;/sup&gt;&lt;br /&gt;
int(re.X) == 64 == 2&lt;sup&gt;6&lt;/sup&gt;&lt;br /&gt;
int(re.T) == 1 == 2&lt;sup&gt;0&lt;/sup&gt;&lt;br /&gt;
int(re.DEBUG) == 128  = 2&lt;sup&gt;7&lt;/sup&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;下面我们来快速学习这些常量的作用及如何使用他们，按常用度排序！&lt;/p&gt;
&lt;h4 id=&#34;1-ignorecase&#34;&gt;1. IGNORECASE&lt;/h4&gt;
&lt;p&gt;语法： re.IGNORECASE 或简写为 re.I&lt;/p&gt;
&lt;p&gt;作用： 进行忽略大小写匹配。&lt;/p&gt;
&lt;p&gt;代码案例：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;def regexFlag():
    &amp;quot;&amp;quot;&amp;quot;
    演示re模块常量的使用
    re.IGNORECASE
    &amp;quot;&amp;quot;&amp;quot;
    text = &#39;测试test&#39;
    pattern = &#39;测试TEST&#39;
    print(&#39;默认模式：&#39;, re.findall(pattern, text))
    print(&#39;忽略大小写模式&#39;, re.findall(pattern, text, re.IGNORECASE))
    print(&#39;忽略大小写模式&#39;, re.findall(pattern, text, re.I))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;默认模式： []
忽略大小写模式 [&#39;测试test&#39;]
忽略大小写模式 [&#39;测试test&#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在默认匹配模式下大写字母B无法匹配小写字母b，而在忽略大小写模式下是可以的。&lt;/p&gt;
&lt;h4 id=&#34;2-ascii&#34;&gt;2. ASCII&lt;/h4&gt;
&lt;p&gt;语法： re.ASCII 或简写为 re.A&lt;/p&gt;
&lt;p&gt;作用： 顾名思义，ASCII表示ASCII码的意思，让\w, \W, \b, \B, \d, \D, \s 和 \S只匹配ASCII，而不是Unicode。&lt;/p&gt;
&lt;p&gt;代码案例：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;def regexFlag():
    &amp;quot;&amp;quot;&amp;quot;
    演示re模块常量的使用
    re.ASCII
    &amp;quot;&amp;quot;&amp;quot;
    text = &#39;a测b试c&#39;
    pattern = r&#39;\w+&#39;
    print(&#39;Unicode:&#39;, re.findall(pattern, text))
    print(&#39;ASCII:&#39;, re.findall(pattern, text, re.ASCII))
    print(&#39;ASCII:&#39;, re.findall(pattern, text, re.A))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;Unicode： [&#39;a测b试c&#39;] 
ASCII: [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]
ASCII: [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在默认匹配模式下\w+匹配到了所有字符串，而在ASCII模式下，只匹配到了a、b、c（ASCII编码支持的字符）。&lt;/p&gt;
&lt;p&gt;注意：这只对字符串匹配模式有效，对字节匹配模式无效。&lt;/p&gt;
&lt;h4 id=&#34;3-dotall&#34;&gt;3. DOTALL&lt;/h4&gt;
&lt;p&gt;语法： re.DOTALL 或简写为 re.S&lt;/p&gt;
&lt;p&gt;作用： DOT表示.，ALL表示所有，连起来就是.匹配所有，包括换行符\n。默认模式下.是不能匹配行符\n的。&lt;/p&gt;
&lt;p&gt;代码案例：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;def regexFlag():
    &amp;quot;&amp;quot;&amp;quot;
    演示re模块常量的使用
    re.DOTALL
    &amp;quot;&amp;quot;&amp;quot;
    text = &#39;测\n试&#39;
    pattern = r&#39;.*&#39;
    print(&#39;默认模式：&#39;, re.findall(pattern, text))
    print(&#39;.匹配所有模式：&#39;, re.findall(pattern, text, re.DOTALL))
    print(&#39;.匹配所有模式：&#39;, re.findall(pattern, text, re.S))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;默认模式： [&#39;测&#39;, &#39;&#39;, &#39;试&#39;, &#39;&#39;]
.匹配所有模式： [&#39;测\n试&#39;, &#39;&#39;]
.匹配所有模式： [&#39;测\n试&#39;, &#39;&#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在默认匹配模式下.并没有匹配换行符\n，而是将字符串分开匹配；而在re.DOTALL模式下，换行符\n与字符串一起被匹配到。&lt;/p&gt;
&lt;p&gt;注意：默认匹配模式下.并不会匹配换行符\n。&lt;/p&gt;
&lt;h4 id=&#34;4-multiline&#34;&gt;4. MULTILINE&lt;/h4&gt;
&lt;p&gt;语法： re.MULTILINE 或简写为 re.M&lt;/p&gt;
&lt;p&gt;作用： 多行模式，当某字符串中有换行符\n，默认模式下是不支持换行符特性的，比如：行开头和行结尾，而多行模式下是支持匹配行开头的。&lt;/p&gt;
&lt;p&gt;代码案例：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;def regexFlag():
    &amp;quot;&amp;quot;&amp;quot;
    演示re模块常量的使用
    re.MULTILINE
    &amp;quot;&amp;quot;&amp;quot;
    text = &#39;测\n试&#39;
    pattern = r&#39;^试&#39;
    print(&#39;默认模式：&#39;, re.findall(pattern, text))
    print(&#39;多行模式：&#39;, re.findall(pattern, text, re.MULTILINE))
    print(&#39;多行模式：&#39;, re.findall(pattern, text, re.M))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;默认模式： []
多行模式： [&#39;试&#39;]
多行模式： [&#39;试&#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;正则表达式中^表示匹配行的开头，默认模式下它只能匹配字符串的开头；而在多行模式下，它还可以匹配换行符\n后面的字符。&lt;/p&gt;
&lt;p&gt;注意：正则语法中^匹配行开头、\A匹配字符串开头，单行模式下它两效果一致，多行模式下\A不能识别\n。&lt;/p&gt;
&lt;h4 id=&#34;5-verbose&#34;&gt;5. VERBOSE&lt;/h4&gt;
&lt;p&gt;语法： re.VERBOSE 或简写为 re.X&lt;/p&gt;
&lt;p&gt;作用： 详细模式，可以在正则表达式中加注解！&lt;/p&gt;
&lt;p&gt;代码案例：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;def regexFlag():
    &amp;quot;&amp;quot;&amp;quot;
    演示re模块常量的使用
    re.VERBOSE
    &amp;quot;&amp;quot;&amp;quot;
    text = &#39;测试&#39;
    pattern = r&#39;&#39;&#39;^测    # 第一个字
                   试    # 第二个字
                &#39;&#39;&#39;
    print(&#39;默认模式：&#39;, re.findall(pattern, text))
    print(&#39;详细模式：&#39;, re.findall(pattern, text, re.VERBOSE))
    print(&#39;详细模式：&#39;, re.findall(pattern, text, re.X))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;默认模式： []
详细模式： [&#39;测试&#39;]
详细模式： [&#39;测试&#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;默认模式下并不能识别正则表达式中的注释，而详细模式是可以识别的。当一个正则表达式十分复杂的时候，详细模式或许能为你提供另一种注释方式，但它不应该成为炫技的手段，建议谨慎考虑后使用！&lt;/p&gt;
&lt;h4 id=&#34;6-locale&#34;&gt;6. LOCALE&lt;/h4&gt;
&lt;p&gt;语法： re.LOCALE 或简写为 re.L&lt;/p&gt;
&lt;p&gt;作用： 由当前语言区域决定 \w, \W, \b, \B 和大小写敏感匹配，这个标记只能对byte样式有效。这个标记官方已经不推荐使用，因为语言区域机制很不可靠，它一次只能处理一个 &#34;习惯”，而且只对8位字节有效。&lt;/p&gt;
&lt;p&gt;注意： 由于这个标记官方已经不推荐使用！&lt;/p&gt;
&lt;h4 id=&#34;7-unicode&#34;&gt;7. UNICODE&lt;/h4&gt;
&lt;p&gt;语法： re.UNICODE 或简写为 re.U&lt;/p&gt;
&lt;p&gt;作用： 与 ASCII 模式类似，匹配unicode编码支持的字符，但是 Python 3 默认字符串已经是Unicode，所以有点冗余。&lt;/p&gt;
&lt;h4 id=&#34;8-debug&#34;&gt;8. DEBUG&lt;/h4&gt;
&lt;p&gt;语法： re.DEBUG&lt;/p&gt;
&lt;p&gt;作用： 显示编译时的debug信息。&lt;/p&gt;
&lt;p&gt;代码案例：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;def regexFlag():
    &amp;quot;&amp;quot;&amp;quot;
    演示re模块常量的使用
    re.DEBUG
    &amp;quot;&amp;quot;&amp;quot;
    text = &#39;测试&#39;
    pattern = r&#39;试&#39;
    print(&#39;debug模式：&#39;, re.findall(pattern, text, re.DEBUG))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;LITERAL 35797

 0. INFO 8 0b11 1 1 (to 9)  
      prefix_skip 1
      prefix [0x8bd5] (&#39;试&#39;)
      overlap [0]
       9: LITERAL 0x8bd5 (&#39;试&#39;)   
11. SUCCESS
debug模式： [&#39;试&#39;]

虽然debug模式下确实会打印编译信息，但我并不理解表达的含义。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;9-template&#34;&gt;9. TEMPLATE&lt;/h4&gt;
&lt;p&gt;语法： re.TEMPLATE 或简写为 re.T&lt;/p&gt;
&lt;p&gt;作用： 暂时没搞懂TEMPLATE的具体用处，源码注释中写着：disable backtracking(禁用回溯)！&lt;/p&gt;
&lt;h4 id=&#34;10&#34;&gt;10. 常量总结&lt;/h4&gt;
&lt;p&gt;① 9个常量中，前5个（IGNORECASE、ASCII、DOTALL、MULTILINE、VERBOSE）有用处，两个（LOCALE、UNICODE）官方不建议使用、两个（TEMPLATE、DEBUG）试验性功能，不能依赖。&lt;/p&gt;
&lt;p&gt;② 常量在re常用函数中都可以使用，查看源码可得知。&lt;/p&gt;
&lt;p&gt;③ 常量可叠加使用，因为常量值都是2的幂次方值，所以是可以叠加使用的，叠加时请使用 | 符号，请勿使用+ 符号！&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;def regexFlag():
    &amp;quot;&amp;quot;&amp;quot;
    演示re模块常量的使用
    re.ASCII
    &amp;quot;&amp;quot;&amp;quot;
    text = &#39;测\n试b&#39;
    pattern = r&#39;^试B&#39;
    print(&#39;默认模式：&#39;, re.findall(pattern, text))
    print(&#39;忽略大小写+多行模式：&#39;, re.findall(pattern, text, re.IGNORECASE|re.MULTILINE))
    print(&#39;忽略大小写+多行模式：&#39;, re.findall(pattern, text, re.I|re.M))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;默认模式： []
忽略大小写+多行模式： [&#39;试b&#39;]
忽略大小写+多行模式： [&#39;试b&#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;re_2&#34;&gt;四、re模块函数&lt;/h3&gt;
&lt;p&gt;re模块有12个函数，我们以功能分类来讲解；这样更具有比较性，同时也方便记忆。&lt;/p&gt;
&lt;h4 id=&#34;1_1&#34;&gt;1. 查找一个匹配项&lt;/h4&gt;
&lt;p&gt;查找并返回一个匹配项的函数有3个：search、match、fullmatch，他们的区别分别是：&lt;/p&gt;
&lt;p&gt;① search： 查找任意位置的匹配项&lt;/p&gt;
&lt;p&gt;② match： 必须从字符串开头匹配&lt;/p&gt;
&lt;p&gt;③ fullmatch： 整个字符串与正则完全匹配&lt;/p&gt;
&lt;p&gt;我们再来根据实际的代码案例比较：&lt;/p&gt;
&lt;p&gt;案例1:&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;import re

# 1.查找一个匹配项
text = &#39;a功能测试b，功能测试b&#39;
pattern = r&#39;功能测试b&#39;
# 查找任意位置
print(&#39;search:&#39;, re.search(pattern, text).group())
# 从字符串开头匹配
print(&#39;match:&#39;,  re.match(pattern, text))
# 整个字符串完全匹配
print(&#39;fullmatch:&#39;, re.fullmatch(pattern, text))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;search: 功能测试b
match: None
fullmatch: None
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;案例1中search函数是在字符串中任意位置匹配，只要有符合正则表达式的字符串就匹配成功，其实有两个匹配项，但search函数值返回一个。&lt;/p&gt;
&lt;p&gt;而match函数是要从头开始匹配，而字符串开头多了个字母a，所以无法匹配，fullmatch函数需要完全相同，故也不匹配！&lt;/p&gt;
&lt;p&gt;案例2:&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;import re

# 1.查找一个匹配项
text = &#39;功能测试b，功能测试b&#39;
pattern = r&#39;功能测试b&#39;
# 查找任意位置
print(&#39;search:&#39;, re.search(pattern, text).group())
# 从字符串开头匹配
print(&#39;match:&#39;,  re.match(pattern, text).group())
# 整个字符串完全匹配
print(&#39;fullmatch:&#39;, re.fullmatch(pattern, text))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;search: 功能测试b
match: 功能测试b
fullmatch: None
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;案例2删除了text最开头的字母a，这样match函数就可以匹配啦，而fullmatch函数依然不能完全匹配！&lt;/p&gt;
&lt;p&gt;案例3:&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;import re

# 1.查找一个匹配项
text = &#39;功能测试b&#39;
pattern = r&#39;功能测试b&#39;
# 查找任意位置
print(&#39;search:&#39;, re.search(pattern, text).group())
# 从字符串开头匹配
print(&#39;match:&#39;,  re.match(pattern, text).group())
# 整个字符串完全匹配
print(&#39;fullmatch:&#39;, re.fullmatch(pattern, text).group())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;search: 功能测试b
match: 功能测试b
fullmatch: 功能测试b
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;案例3中，我们只留下一段文字，并且与正则表达式一致；这时fullmatch函数终于可以匹配了。&lt;/p&gt;
&lt;p&gt;注意：查找一个匹配项返回的都是一个匹配对象（Match）。&lt;/p&gt;
&lt;h4 id=&#34;2_1&#34;&gt;2.查找多个匹配项&lt;/h4&gt;
&lt;p&gt;讲完查找一项，现在来看看查找多项吧，查找多项函数主要有：findall函数 与 finditer函数：&lt;/p&gt;
&lt;p&gt;① findall： 从字符串任意位置查找，返回一个列表&lt;/p&gt;
&lt;p&gt;② finditer：从字符串任意位置查找，返回一个迭代器&lt;/p&gt;
&lt;p&gt;两个方法基本类似，只不过一个是返回列表，一个是返回迭代器。我们知道列表是一次性生成在内存中，而迭代器是需要使用时一点一点生成出来的，内存使用更优。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;import re

text = &#39;a功能测试b，功能测试b&#39;
pattern = r&#39;功能测试b&#39;
# 查找所有匹配项，返回一个list
print(&#39;findall:&#39;, re.findall(pattern, text))
# 查找所有匹配项，返回一个迭代器
print(&#39;finditer:&#39;,  list(re.finditer(pattern, text)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;findall: [&#39;功能测试b&#39;, &#39;功能测试b&#39;]
finditer: [&amp;lt;re.Match object; span=(1, 6), match=&#39;功能测试b&#39;&amp;gt;, &amp;lt;re.Match object; span=(7, 12), match=&#39;功能测试b&#39;&amp;gt;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果可能存在大量的匹配项的话，建议使用finditer函数，一般情况使用findall函数基本没啥影响。&lt;/p&gt;
&lt;h4 id=&#34;3&#34;&gt;3. 分割&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;re.split(pattern, string, maxsplit=0, flags=0)&lt;/code&gt; 函数：用 pattern 分开string ， maxsplit表示最多进行分割次数， flags表示模式，就是上面我们讲解的常量！&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;import re

text = &#39;a功能测试b，b功能测试b，c功能测试b&#39;
pattern = r&#39;，&#39;
# 正则切割
print(&#39;split:&#39;, re.split(pattern, text, maxsplit=1, flags=re.IGNORECASE))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;split: [&#39;a功能测试b&#39;, &#39;b功能测试b，c功能测试b&#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意：str模块也有一个 split函数 ，str.split函数功能简单，不支持正则分割，而re.split支持正则。大数据量下re.split花费的时间比str.split少。所以在不需要正则支持且数据量和数次不多的情况下使用str.split函数更合适，反之则使用re.split函数。&lt;/p&gt;
&lt;h4 id=&#34;4&#34;&gt;4. 替换&lt;/h4&gt;
&lt;p&gt;替换主要有sub函数 与 subn函数，他们功能类似！&lt;/p&gt;
&lt;p&gt;先来看看sub函数的用法：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;re.sub(pattern, repl, string, count=0, flags=0)&lt;/code&gt; 函数参数讲解：repl替换掉string中被pattern匹配的字符，count表示最大替换次数，flags表示正则表达式的常量。&lt;/p&gt;
&lt;p&gt;值得注意的是：sub函数中的入参：repl替换内容既可以是字符串，也可以是一个函数！ 如果repl为函数时，只能有一个入参：Match匹配对象。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;import re

text = &#39;1功能测试b，2功能测试b，3功能测试b&#39;
pattern = r&#39;, &#39;
# repl为字符串
repl = r&#39;、&#39;
# 替换
print(&#39;sub-repl为字符串:&#39;, re.sub(pattern, repl, text, count=2, flags=re.IGNORECASE))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;sub-repl为字符串: 1功能测试b、2功能测试b、3功能测试b
&lt;/code&gt;&lt;/pre&gt;

&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;import re

text = &#39;1功能测试b，2功能测试b。3功能测试b&#39;
pattern = r&#39;，|。&#39;
# repl为函数
repl = lambda matchobj: &#39; &#39; if matchobj.group(0) != &#39;，&#39; else &#39;、&#39;
# 替换
print(&#39;sub-repl为字符串:&#39;, re.sub(pattern, repl, text, count=2, flags=re.IGNORECASE))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;sub-repl为字符串: 1功能测试b、2功能测试b 3功能测试b
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;re.subn(pattern, repl, string, count=0, flags=0)&lt;/code&gt; 函数与 re.sub函数 功能一致，只不过返回一个元组 (字符串, 替换次数)。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;import re

text = &#39;1功能测试b，2功能测试b，3功能测试b&#39;
pattern = r&#39;，&#39;
# repl为字符串
repl = r&#39;、&#39;
# 替换
print(&#39;sub-repl为字符串:&#39;, re.subn(pattern, repl, text, count=2, flags=re.IGNORECASE))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;sub-repl为字符串: (&#39;1功能测试b、2功能测试b、3功能测试b&#39;, 2)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;5&#34;&gt;5. 编译正则对象&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;compile&lt;/code&gt;函数 与 &lt;code&gt;template&lt;/code&gt;函数 将正则表达式的样式编译为一个正则表达式对象（正则对象Pattern），这个对象与re模块有同样的正则函数。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;import re

text = &#39;a功能测试b，功能测试b&#39;
pattern = r&#39;功能测试b&#39;
pattern_obj = re.compile(pattern)
# 查找任意位置
print(&#39;pattern_obj.search:&#39;, pattern_obj.search(text).group())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;pattern_obj.search: 功能测试b
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而template函数 与 compile函数 类似，只不过是增加了我们之前说的re.TEMPLATE 模式，我们可以看看源码。&lt;/p&gt;
&lt;h4 id=&#34;6&#34;&gt;6. 其他&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;re.escape(pattern)&lt;/code&gt; 可以转义正则表达式中具有特殊含义的字符，比如：. 或者 * ，举个实际的案例：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;import re

text = &#39;功.能测*试&#39;
pattern = r&#39;功\.能测\*试&#39;
# 查找任意位置
print(&#39;search:&#39;, re.search(pattern, text))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;search: &amp;lt;re.Match object; span=(0, 6), match=&#39;功.能测*试&#39;&amp;gt;

import re

text = &#39;功.能测*试&#39;
pattern = re.escape(&#39;功.能测*试&#39;)
# 查找任意位置
print(&#39;转义后的正则：&#39;, pattern)
print(&#39;search:&#39;, re.search(pattern, text))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;转义后的正则： 功\.能测\*试
search: &amp;lt;re.Match object; span=(0, 6), match=&#39;功.能测*试&#39;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;re.escape(pattern)&lt;/code&gt; 看似非常好用省去了我们自己加转义，但是使用它很容易出现转义错误的问题，所以并不建议使用它转义，而建议大家自己手动转义！&lt;/p&gt;
&lt;p&gt;&lt;code&gt;re.purge()&lt;/code&gt; 函数作用就是清除 正则表达式缓存，具体有什么缓存呢？我们来看看源码就知道它背地里干了什么：&lt;/p&gt;
&lt;p&gt;看方法大概是清除缓存吧，我们再来看看具体的案例：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;import re

text = &#39;功.能测*试&#39;
pattern = r&#39;功\.能测\*试&#39;
# 查找任意位置
print(&#39;search:&#39;, re.search(pattern, text))
print(&#39;_cache:&#39;, re._cache)
re.purge()
print(&#39;_cache:&#39;, re._cache)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;search: &amp;lt;re.Match object; span=(0, 6), match=&#39;功.能测*试&#39;&amp;gt;
_cache: {(&amp;lt;class &#39;str&#39;&amp;gt;, &#39;功\\.能测\\*试&#39;, 0): re.compile(&#39;功\\.能测\\*试&#39;)}
_cache: {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在函数re.purge()前后打印_cache的结果，第二个_cache很明显被清理了！&lt;/p&gt;
&lt;h3 id=&#34;re_3&#34;&gt;五、re模块异常&lt;/h3&gt;
&lt;p&gt;re模块还包含了一个正则表达式的编译错误，当我们给出的正则表达式是一个无效的表达式（就是表达式本身有问题）时，就会raise一个异常！&lt;/p&gt;
&lt;p&gt;我们来看看具体的案例吧：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;import re

text = &#39;功.能测*试&#39;
pattern = r&#39;(测试))&#39;
# 查找任意位置
print(&#39;search:&#39;, re.search(pattern, text))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;Traceback (most recent call last):
  File &amp;quot;c:/Users/dell/Desktop/test/re/3/11.py&amp;quot;, line 8, in &amp;lt;module&amp;gt;
    print(&#39;search:&#39;, re.search(pattern, text))
  File &amp;quot;C:\Program Files\Python38\lib\re.py&amp;quot;, line 201, in search
    return _compile(pattern, flags).search(string)
  File &amp;quot;C:\Program Files\Python38\lib\re.py&amp;quot;, line 304, in _compile
    p = sre_compile.compile(pattern, flags)
  File &amp;quot;C:\Program Files\Python38\lib\sre_compile.py&amp;quot;, line 764, in compile
    p = sre_parse.parse(p, flags)
  File &amp;quot;C:\Program Files\Python38\lib\sre_parse.py&amp;quot;, line 962, in parse
    raise source.error(&amp;quot;unbalanced parenthesis&amp;quot;)
re.error: unbalanced parenthesis at position 4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面案例中我们可以看到，在编写正则表达式中我们多写了一个括号，这导致执行结果报错。&lt;/p&gt;
&lt;p&gt;注意：这个异常一定是正则表达式本身是无效的，与要匹配的字符串无关！&lt;/p&gt;
&lt;h3 id=&#34;_2&#34;&gt;六、注意事项&lt;/h3&gt;
&lt;p&gt;Python 正则表达式知识基本讲解完毕，最后稍微给大家提一提需要注意的点。&lt;/p&gt;
&lt;h4 id=&#34;1_2&#34;&gt;1. 字节串与字符串&lt;/h4&gt;
&lt;p&gt;模式和被搜索的字符串既可以是Unicode字符串(str)，也可以是8位字节串(bytes)。但是，Unicode字符串与8位字节串不能混用！&lt;/p&gt;
&lt;h4 id=&#34;2r&#34;&gt;2.r 的作用&lt;/h4&gt;
&lt;p&gt;正则表达式使用反斜杠（\）来表示特殊形式，或者把特殊字符转义成普通字符。&lt;/p&gt;
&lt;p&gt;而反斜杠在普通的 Python 字符串里也有相同的作用，所以就产生了冲突。&lt;/p&gt;
&lt;p&gt;解决办法是对于正则表达式样式使用 Python 的原始字符串表示法；在带有‘r’前缀的字符串字面值中，反斜杠不必做任何特殊处理。&lt;/p&gt;
&lt;h4 id=&#34;3_1&#34;&gt;3.正则查找函数 返回匹配对象&lt;/h4&gt;
&lt;p&gt;查找一个匹配项&lt;code&gt;（search、match、fullmatch）&lt;/code&gt;的函数返回值都是一个匹配对象Match ，需要通过match.group()获取匹配值，这个很容易忘记。&lt;/p&gt;
&lt;p&gt;另外还需要注意：&lt;code&gt;match.group()&lt;/code&gt; 与&lt;code&gt;match.groups()&lt;/code&gt; 函数的差别！&lt;/p&gt;
&lt;h4 id=&#34;4_1&#34;&gt;4.重复使用某个正则&lt;/h4&gt;
&lt;p&gt;如果要重复使用某个正则表达式，推荐先使用 &lt;code&gt;re.compile(pattern)&lt;/code&gt;函数 返回一个正则对象，然后复用这个正则对象，这样会更快！&lt;/p&gt;</description>  
      <pubDate>2025-10-09 17:54:40</pubDate>  
      <link>https://testpoo.github.io/Python正则表达式.html</link>  
      <guid isPermaLink="true">https://testpoo.github.io/Python正则表达式.html</guid>
       
      <category>技术</category> 
      
    </item>
    
    <item> 
      <title>nose简介</title>  
      <description>&lt;div class=&#34;toc&#34;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1&#34;&gt;1. 简介&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#11&#34;&gt;1.1 编写用例更简单&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#12&#34;&gt;1.2 运行用例更简单&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#13&#34;&gt;1.3 初始化测试环境更简单&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#14&#34;&gt;1.4 做所想的事更简单&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2&#34;&gt;2 安装&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#21-setuptools&#34;&gt;2.1 通过setuptools安装&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#22-pip&#34;&gt;2.2 通过pip安装&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#23&#34;&gt;2.3 源码安装&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#24&#34;&gt;2.4. 快速使用&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3-nose&#34;&gt;3. nose命令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4&#34;&gt;4. 基本用法&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#41-nose&#34;&gt;4.1 nose测试实践&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#42-nose&#34;&gt;4.2 nose运行方式&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5&#34;&gt;5. 子测试/测试生成器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#6-nose&#34;&gt;6. nose的测试工具集&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#61-nosetoolsok_expr-msgnone&#34;&gt;6.1 nose.tools.ok_(expr, msg=None)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#62-nosetoolseq_a-b-msgnone&#34;&gt;6.2 nose.tools.eq_(a, b, msg=None)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#63-nosetoolsassert_inmember-container-msgnone&#34;&gt;6.3 nose.tools.assert_in(member, container, msg=None)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#64-nosetoolsset_trace&#34;&gt;6.4 nose.tools.set_trace()&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#65-nosetoolstimedlimit&#34;&gt;6.5 nose.tools.timed(limit)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#66-nosetools&#34;&gt;6.6 nose.tools.*&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#7&#34;&gt;7. 插件&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h3 id=&#34;1&#34;&gt;1. 简介&lt;/h3&gt;
&lt;p&gt;nose是python开发的测试框架。nose扩展了unittest，他让测试更加容易。&lt;/p&gt;
&lt;h4 id=&#34;11&#34;&gt;1.1 编写用例更简单&lt;/h4&gt;
&lt;p&gt;nose可以收集继承于unittest.TestCase类中的测试例，当然，你也可以编写简单的测试函数，编写并不是继承于unittest.TestCase的测试类。nose也提供了许多帮助函数，用于编写定时测试例，用于异常的测试，和其他一些公共的使用情况。&lt;/p&gt;
&lt;h4 id=&#34;12&#34;&gt;1.2 运行用例更简单&lt;/h4&gt;
&lt;p&gt;只要你按照一些简单的要求组织你的测试库和代码，nose就可以自动收集测试用例。并没有必要手动收集测试case到测试suites中。运行测试响应迅速，因为nose在加载第一个测试模块后立即开始运行测试&lt;/p&gt;
&lt;h4 id=&#34;13&#34;&gt;1.3 初始化测试环境更简单&lt;/h4&gt;
&lt;p&gt;nose组件支持package，module，class和case级别，因此初始化操作很容易完成。&lt;/p&gt;
&lt;h4 id=&#34;14&#34;&gt;1.4 做所想的事更简单&lt;/h4&gt;
&lt;p&gt;nose配备了一些&lt;a href=&#34;https://nose.readthedocs.io/en/latest/plugins/builtin.html&#34;&gt;内置插件&lt;/a&gt;，以帮助你捕获输出，反思错误，覆盖代码，文档测试，等等。它还配备了用于加载、运行测试，在测试例运行时，查看和报告测试。如果您不喜欢默认收集方案，或者它不适合你的项目，或者你需要不同于unittest标准的格式报告，或者需要收集有关测试的额外信息（如代码覆盖或数据分析），您可以编写插件来让nose做这些事。&lt;/p&gt;
&lt;h3 id=&#34;2&#34;&gt;2 安装&lt;/h3&gt;
&lt;h4 id=&#34;21-setuptools&#34;&gt;2.1 通过setuptools安装&lt;/h4&gt;
&lt;p&gt;安装命令&lt;code&gt;easy_install nose&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;WARNING: The easy_install command is deprecated and will be removed in a future version.
Searching for nose
Reading https://pypi.org/simple/nose/
Downloading https://files.pythonhosted.org/packages/15/d8/dd071918c040f50fa1cf80da16423af51ff8ce4a0f2399b7bf8de45ac3d9/nose-1.3.7-py3-none-any.whl#sha256=9ff7c6cc443f8c51994b34a667bbcf45afd6d945be7477b52e97516fd17c53ac
Best match: nose 1.3.7
Processing nose-1.3.7-py3-none-any.whl
Installing nose-1.3.7-py3-none-any.whl to c:\program files\python38\lib\site-packages
Adding nose 1.3.7 to easy-install.pth file
Installing nosetests-script.py script to c:\program files\python38\Scripts
Installing nosetests.exe script to c:\program files\python38\Scripts
Installing nosetests-3.4-script.py script to c:\program files\python38\Scripts
Installing nosetests-3.4.exe script to c:\program files\python38\Scripts

Installed c:\program files\python38\lib\site-packages\nose-1.3.7-py3.8.egg
Processing dependencies for nose
Finished processing dependencies for nose
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;22-pip&#34;&gt;2.2 通过pip安装&lt;/h4&gt;
&lt;p&gt;安装命令&lt;code&gt;pip install nose&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;PS C:\Users\dell&amp;gt; pip install nose

Looking in indexes: https://pypi.tuna.tsinghua.edu.cn/simple

Collecting nose

 Downloading https://pypi.tuna.tsinghua.edu.cn/packages/15/d8/dd071918c040f50fa1cf80da16423af51ff8ce4a0f2399b7bf8de45ac3d9/nose-1.3.7-py3-none-any.whl (154 kB)

   |████████████████████████████████| 154 kB 1.7 MB/s

Installing collected packages: nose

Successfully installed nose-1.3.7
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者下载后通过&lt;code&gt;pip&lt;/code&gt;安装&lt;/p&gt;
&lt;p&gt;https://files.pythonhosted.org/packages/15/d8/dd071918c040f50fa1cf80da16423af51ff8ce4a0f2399b7bf8de45ac3d9/nose-1.3.7-py3-none-any.whl&lt;/p&gt;
&lt;p&gt;安装命令&lt;code&gt;pip install nose-1.3.7-py3-none-any.whl&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;Looking in indexes: https://pypi.tuna.tsinghua.edu.cn/simple
Processing e:\公司文档\分享内容\software\nose-1.3.7-py3-none-any.whl
Installing collected packages: nose
Successfully installed nose-1.3.7
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;23&#34;&gt;2.3 源码安装&lt;/h4&gt;
&lt;p&gt;下载源码 &lt;code&gt;https://files.pythonhosted.org/packages/58/a5/0dc93c3ec33f4e281849523a5a913fa1eea9a3068acfa754d44d88107a44/nose-1.3.7.tar.gz&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;解压源码，进入目录 &lt;code&gt;cd nose-1.3.7&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;安装命令&lt;code&gt;python setup.py install&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;running install
running bdist_egg
running egg_info
writing nose.egg-info\PKG-INFO
writing dependency_links to nose.egg-info\dependency_links.txt
writing entry points to nose.egg-info\entry_points.txt
writing top-level names to nose.egg-info\top_level.txt
reading manifest file &#39;nose.egg-info\SOURCES.txt&#39;
reading manifest template &#39;MANIFEST.in&#39;
no previously-included directories found matching &#39;doc\.build&#39;
writing manifest file &#39;nose.egg-info\SOURCES.txt&#39;
installing library code to build\bdist.win-amd64\egg
running install_lib
running build_py
creating build
creating build\lib
creating build\lib\nose
copying nose\case.py -&amp;gt; build\lib\nose
copying nose\commands.py -&amp;gt; build\lib\nose
copying nose\config.py -&amp;gt; build\lib\nose
copying nose\core.py -&amp;gt; build\lib\nose
copying nose\exc.py -&amp;gt; build\lib\nose
copying nose\failure.py -&amp;gt; build\lib\nose
copying nose\importer.py -&amp;gt; build\lib\nose
copying nose\inspector.py -&amp;gt; build\lib\nose
copying nose\loader.py -&amp;gt; build\lib\nose
copying nose\proxy.py -&amp;gt; build\lib\nose
copying nose\pyversion.py -&amp;gt; build\lib\nose
copying nose\result.py -&amp;gt; build\lib\nose
copying nose\selector.py -&amp;gt; build\lib\nose
copying nose\suite.py -&amp;gt; build\lib\nose
copying nose\twistedtools.py -&amp;gt; build\lib\nose
copying nose\util.py -&amp;gt; build\lib\nose
copying nose\__init__.py -&amp;gt; build\lib\nose
copying nose\__main__.py -&amp;gt; build\lib\nose
creating build\lib\nose\ext
copying nose\ext\dtcompat.py -&amp;gt; build\lib\nose\ext
copying nose\ext\__init__.py -&amp;gt; build\lib\nose\ext
creating build\lib\nose\plugins
copying nose\plugins\allmodules.py -&amp;gt; build\lib\nose\plugins
copying nose\plugins\attrib.py -&amp;gt; build\lib\nose\plugins
copying nose\plugins\base.py -&amp;gt; build\lib\nose\plugins
copying nose\plugins\builtin.py -&amp;gt; build\lib\nose\plugins
copying nose\plugins\capture.py -&amp;gt; build\lib\nose\plugins
copying nose\plugins\collect.py -&amp;gt; build\lib\nose\plugins
copying nose\plugins\cover.py -&amp;gt; build\lib\nose\plugins
copying nose\plugins\debug.py -&amp;gt; build\lib\nose\plugins
copying nose\plugins\deprecated.py -&amp;gt; build\lib\nose\plugins
copying nose\plugins\doctests.py -&amp;gt; build\lib\nose\plugins
copying nose\plugins\errorclass.py -&amp;gt; build\lib\nose\plugins
copying nose\plugins\failuredetail.py -&amp;gt; build\lib\nose\plugins
copying nose\plugins\isolate.py -&amp;gt; build\lib\nose\plugins
copying nose\plugins\logcapture.py -&amp;gt; build\lib\nose\plugins
copying nose\plugins\manager.py -&amp;gt; build\lib\nose\plugins
copying nose\plugins\multiprocess.py -&amp;gt; build\lib\nose\plugins
copying nose\plugins\plugintest.py -&amp;gt; build\lib\nose\plugins
copying nose\plugins\prof.py -&amp;gt; build\lib\nose\plugins
copying nose\plugins\skip.py -&amp;gt; build\lib\nose\plugins
copying nose\plugins\testid.py -&amp;gt; build\lib\nose\plugins
copying nose\plugins\xunit.py -&amp;gt; build\lib\nose\plugins
copying nose\plugins\__init__.py -&amp;gt; build\lib\nose\plugins
creating build\lib\nose\sphinx
copying nose\sphinx\pluginopts.py -&amp;gt; build\lib\nose\sphinx
copying nose\sphinx\__init__.py -&amp;gt; build\lib\nose\sphinx
creating build\lib\nose\tools
copying nose\tools\nontrivial.py -&amp;gt; build\lib\nose\tools
copying nose\tools\trivial.py -&amp;gt; build\lib\nose\tools
copying nose\tools\__init__.py -&amp;gt; build\lib\nose\tools
copying nose\usage.txt -&amp;gt; build\lib\nose
C:\Program Files\Python38\lib\site-packages\setuptools\lib2to3_ex.py:39: SetuptoolsDeprecationWarning: 2to3 support is deprecated. If the project still requires Python 2 support, please migrate to a single-codebase solution or employ an independent conversion process.
  warnings.warn(
Fixing build\lib\nose\case.py build\lib\nose\commands.py build\lib\nose\config.py build\lib\nose\core.py build\lib\nose\exc.py build\lib\nose\failure.py build\lib\nose\importer.py build\lib\nose\inspector.py build\lib\nose\loader.py build\lib\nose\proxy.py build\lib\nose\pyversion.py build\lib\nose\result.py build\lib\nose\selector.py build\lib\nose\suite.py build\lib\nose\twistedtools.py build\lib\nose\util.py build\lib\nose\__init__.py build\lib\nose\__main__.py build\lib\nose\ext\dtcompat.py build\lib\nose\ext\__init__.py build\lib\nose\plugins\allmodules.py build\lib\nose\plugins\attrib.py build\lib\nose\plugins\base.py build\lib\nose\plugins\builtin.py build\lib\nose\plugins\capture.py build\lib\nose\plugins\collect.py build\lib\nose\plugins\cover.py build\lib\nose\plugins\debug.py build\lib\nose\plugins\deprecated.py build\lib\nose\plugins\doctests.py build\lib\nose\plugins\errorclass.py build\lib\nose\plugins\failuredetail.py build\lib\nose\plugins\isolate.py build\lib\nose\plugins\logcapture.py build\lib\nose\plugins\manager.py build\lib\nose\plugins\multiprocess.py build\lib\nose\plugins\plugintest.py build\lib\nose\plugins\prof.py build\lib\nose\plugins\skip.py build\lib\nose\plugins\testid.py build\lib\nose\plugins\xunit.py build\lib\nose\plugins\__init__.py build\lib\nose\sphinx\pluginopts.py build\lib\nose\sphinx\__init__.py build\lib\nose\tools\nontrivial.py build\lib\nose\tools\trivial.py build\lib\nose\tools\__init__.py
Skipping optional fixer: buffer
Skipping optional fixer: idioms
Skipping optional fixer: set_literal
Skipping optional fixer: ws_comma
Fixing build\lib\nose\case.py build\lib\nose\commands.py build\lib\nose\config.py build\lib\nose\core.py build\lib\nose\exc.py build\lib\nose\failure.py build\lib\nose\importer.py build\lib\nose\inspector.py build\lib\nose\loader.py build\lib\nose\proxy.py build\lib\nose\pyversion.py build\lib\nose\result.py build\lib\nose\selector.py build\lib\nose\suite.py build\lib\nose\twistedtools.py build\lib\nose\util.py build\lib\nose\__init__.py build\lib\nose\__main__.py build\lib\nose\ext\dtcompat.py build\lib\nose\ext\__init__.py build\lib\nose\plugins\allmodules.py build\lib\nose\plugins\attrib.py build\lib\nose\plugins\base.py build\lib\nose\plugins\builtin.py build\lib\nose\plugins\capture.py build\lib\nose\plugins\collect.py build\lib\nose\plugins\cover.py build\lib\nose\plugins\debug.py build\lib\nose\plugins\deprecated.py build\lib\nose\plugins\doctests.py build\lib\nose\plugins\errorclass.py build\lib\nose\plugins\failuredetail.py build\lib\nose\plugins\isolate.py build\lib\nose\plugins\logcapture.py build\lib\nose\plugins\manager.py build\lib\nose\plugins\multiprocess.py build\lib\nose\plugins\plugintest.py build\lib\nose\plugins\prof.py build\lib\nose\plugins\skip.py build\lib\nose\plugins\testid.py build\lib\nose\plugins\xunit.py build\lib\nose\plugins\__init__.py build\lib\nose\sphinx\pluginopts.py build\lib\nose\sphinx\__init__.py build\lib\nose\tools\nontrivial.py build\lib\nose\tools\trivial.py build\lib\nose\tools\__init__.py
Skipping optional fixer: buffer
Skipping optional fixer: idioms
Skipping optional fixer: set_literal
Skipping optional fixer: ws_comma
creating build\bdist.win-amd64
creating build\bdist.win-amd64\egg
creating build\bdist.win-amd64\egg\nose
copying build\lib\nose\case.py -&amp;gt; build\bdist.win-amd64\egg\nose
copying build\lib\nose\commands.py -&amp;gt; build\bdist.win-amd64\egg\nose
copying build\lib\nose\config.py -&amp;gt; build\bdist.win-amd64\egg\nose
copying build\lib\nose\core.py -&amp;gt; build\bdist.win-amd64\egg\nose
copying build\lib\nose\exc.py -&amp;gt; build\bdist.win-amd64\egg\nose
creating build\bdist.win-amd64\egg\nose\ext
copying build\lib\nose\ext\dtcompat.py -&amp;gt; build\bdist.win-amd64\egg\nose\ext
copying build\lib\nose\ext\__init__.py -&amp;gt; build\bdist.win-amd64\egg\nose\ext
copying build\lib\nose\failure.py -&amp;gt; build\bdist.win-amd64\egg\nose
copying build\lib\nose\importer.py -&amp;gt; build\bdist.win-amd64\egg\nose
copying build\lib\nose\inspector.py -&amp;gt; build\bdist.win-amd64\egg\nose
copying build\lib\nose\loader.py -&amp;gt; build\bdist.win-amd64\egg\nose
creating build\bdist.win-amd64\egg\nose\plugins
copying build\lib\nose\plugins\allmodules.py -&amp;gt; build\bdist.win-amd64\egg\nose\plugins
copying build\lib\nose\plugins\attrib.py -&amp;gt; build\bdist.win-amd64\egg\nose\plugins
copying build\lib\nose\plugins\base.py -&amp;gt; build\bdist.win-amd64\egg\nose\plugins
copying build\lib\nose\plugins\builtin.py -&amp;gt; build\bdist.win-amd64\egg\nose\plugins
copying build\lib\nose\plugins\capture.py -&amp;gt; build\bdist.win-amd64\egg\nose\plugins
copying build\lib\nose\plugins\collect.py -&amp;gt; build\bdist.win-amd64\egg\nose\plugins
copying build\lib\nose\plugins\cover.py -&amp;gt; build\bdist.win-amd64\egg\nose\plugins
copying build\lib\nose\plugins\debug.py -&amp;gt; build\bdist.win-amd64\egg\nose\plugins
copying build\lib\nose\plugins\deprecated.py -&amp;gt; build\bdist.win-amd64\egg\nose\plugins
copying build\lib\nose\plugins\doctests.py -&amp;gt; build\bdist.win-amd64\egg\nose\plugins
copying build\lib\nose\plugins\errorclass.py -&amp;gt; build\bdist.win-amd64\egg\nose\plugins
copying build\lib\nose\plugins\failuredetail.py -&amp;gt; build\bdist.win-amd64\egg\nose\plugins
copying build\lib\nose\plugins\isolate.py -&amp;gt; build\bdist.win-amd64\egg\nose\plugins
copying build\lib\nose\plugins\logcapture.py -&amp;gt; build\bdist.win-amd64\egg\nose\plugins
copying build\lib\nose\plugins\manager.py -&amp;gt; build\bdist.win-amd64\egg\nose\plugins
copying build\lib\nose\plugins\multiprocess.py -&amp;gt; build\bdist.win-amd64\egg\nose\plugins
copying build\lib\nose\plugins\plugintest.py -&amp;gt; build\bdist.win-amd64\egg\nose\plugins
copying build\lib\nose\plugins\prof.py -&amp;gt; build\bdist.win-amd64\egg\nose\plugins
copying build\lib\nose\plugins\skip.py -&amp;gt; build\bdist.win-amd64\egg\nose\plugins
copying build\lib\nose\plugins\testid.py -&amp;gt; build\bdist.win-amd64\egg\nose\plugins
copying build\lib\nose\plugins\xunit.py -&amp;gt; build\bdist.win-amd64\egg\nose\plugins
copying build\lib\nose\plugins\__init__.py -&amp;gt; build\bdist.win-amd64\egg\nose\plugins
copying build\lib\nose\proxy.py -&amp;gt; build\bdist.win-amd64\egg\nose
copying build\lib\nose\pyversion.py -&amp;gt; build\bdist.win-amd64\egg\nose
copying build\lib\nose\result.py -&amp;gt; build\bdist.win-amd64\egg\nose
copying build\lib\nose\selector.py -&amp;gt; build\bdist.win-amd64\egg\nose
creating build\bdist.win-amd64\egg\nose\sphinx
copying build\lib\nose\sphinx\pluginopts.py -&amp;gt; build\bdist.win-amd64\egg\nose\sphinx
copying build\lib\nose\sphinx\__init__.py -&amp;gt; build\bdist.win-amd64\egg\nose\sphinx
copying build\lib\nose\suite.py -&amp;gt; build\bdist.win-amd64\egg\nose
creating build\bdist.win-amd64\egg\nose\tools
copying build\lib\nose\tools\nontrivial.py -&amp;gt; build\bdist.win-amd64\egg\nose\tools
copying build\lib\nose\tools\trivial.py -&amp;gt; build\bdist.win-amd64\egg\nose\tools
copying build\lib\nose\tools\__init__.py -&amp;gt; build\bdist.win-amd64\egg\nose\tools
copying build\lib\nose\twistedtools.py -&amp;gt; build\bdist.win-amd64\egg\nose
copying build\lib\nose\usage.txt -&amp;gt; build\bdist.win-amd64\egg\nose
copying build\lib\nose\util.py -&amp;gt; build\bdist.win-amd64\egg\nose
copying build\lib\nose\__init__.py -&amp;gt; build\bdist.win-amd64\egg\nose
copying build\lib\nose\__main__.py -&amp;gt; build\bdist.win-amd64\egg\nose
byte-compiling build\bdist.win-amd64\egg\nose\case.py to case.cpython-38.pyc
byte-compiling build\bdist.win-amd64\egg\nose\commands.py to commands.cpython-38.pyc
byte-compiling build\bdist.win-amd64\egg\nose\config.py to config.cpython-38.pyc
byte-compiling build\bdist.win-amd64\egg\nose\core.py to core.cpython-38.pyc
byte-compiling build\bdist.win-amd64\egg\nose\exc.py to exc.cpython-38.pyc
byte-compiling build\bdist.win-amd64\egg\nose\ext\dtcompat.py to dtcompat.cpython-38.pyc
byte-compiling build\bdist.win-amd64\egg\nose\ext\__init__.py to __init__.cpython-38.pyc
byte-compiling build\bdist.win-amd64\egg\nose\failure.py to failure.cpython-38.pyc
byte-compiling build\bdist.win-amd64\egg\nose\importer.py to importer.cpython-38.pyc
byte-compiling build\bdist.win-amd64\egg\nose\inspector.py to inspector.cpython-38.pyc
byte-compiling build\bdist.win-amd64\egg\nose\loader.py to loader.cpython-38.pyc
byte-compiling build\bdist.win-amd64\egg\nose\plugins\allmodules.py to allmodules.cpython-38.pyc
byte-compiling build\bdist.win-amd64\egg\nose\plugins\attrib.py to attrib.cpython-38.pyc
byte-compiling build\bdist.win-amd64\egg\nose\plugins\base.py to base.cpython-38.pyc
byte-compiling build\bdist.win-amd64\egg\nose\plugins\builtin.py to builtin.cpython-38.pyc
byte-compiling build\bdist.win-amd64\egg\nose\plugins\capture.py to capture.cpython-38.pyc
byte-compiling build\bdist.win-amd64\egg\nose\plugins\collect.py to collect.cpython-38.pyc
byte-compiling build\bdist.win-amd64\egg\nose\plugins\cover.py to cover.cpython-38.pyc
byte-compiling build\bdist.win-amd64\egg\nose\plugins\debug.py to debug.cpython-38.pyc
byte-compiling build\bdist.win-amd64\egg\nose\plugins\deprecated.py to deprecated.cpython-38.pyc
byte-compiling build\bdist.win-amd64\egg\nose\plugins\doctests.py to doctests.cpython-38.pyc
byte-compiling build\bdist.win-amd64\egg\nose\plugins\errorclass.py to errorclass.cpython-38.pyc
byte-compiling build\bdist.win-amd64\egg\nose\plugins\failuredetail.py to failuredetail.cpython-38.pyc
byte-compiling build\bdist.win-amd64\egg\nose\plugins\isolate.py to isolate.cpython-38.pyc
byte-compiling build\bdist.win-amd64\egg\nose\plugins\logcapture.py to logcapture.cpython-38.pyc
byte-compiling build\bdist.win-amd64\egg\nose\plugins\manager.py to manager.cpython-38.pyc
byte-compiling build\bdist.win-amd64\egg\nose\plugins\multiprocess.py to multiprocess.cpython-38.pyc
byte-compiling build\bdist.win-amd64\egg\nose\plugins\plugintest.py to plugintest.cpython-38.pyc
byte-compiling build\bdist.win-amd64\egg\nose\plugins\prof.py to prof.cpython-38.pyc
byte-compiling build\bdist.win-amd64\egg\nose\plugins\skip.py to skip.cpython-38.pyc
byte-compiling build\bdist.win-amd64\egg\nose\plugins\testid.py to testid.cpython-38.pyc
byte-compiling build\bdist.win-amd64\egg\nose\plugins\xunit.py to xunit.cpython-38.pyc
byte-compiling build\bdist.win-amd64\egg\nose\plugins\__init__.py to __init__.cpython-38.pyc
byte-compiling build\bdist.win-amd64\egg\nose\proxy.py to proxy.cpython-38.pyc
byte-compiling build\bdist.win-amd64\egg\nose\pyversion.py to pyversion.cpython-38.pyc
byte-compiling build\bdist.win-amd64\egg\nose\result.py to result.cpython-38.pyc
byte-compiling build\bdist.win-amd64\egg\nose\selector.py to selector.cpython-38.pyc
byte-compiling build\bdist.win-amd64\egg\nose\sphinx\pluginopts.py to pluginopts.cpython-38.pyc
byte-compiling build\bdist.win-amd64\egg\nose\sphinx\__init__.py to __init__.cpython-38.pyc
byte-compiling build\bdist.win-amd64\egg\nose\suite.py to suite.cpython-38.pyc
byte-compiling build\bdist.win-amd64\egg\nose\tools\nontrivial.py to nontrivial.cpython-38.pyc
byte-compiling build\bdist.win-amd64\egg\nose\tools\trivial.py to trivial.cpython-38.pyc
byte-compiling build\bdist.win-amd64\egg\nose\tools\__init__.py to __init__.cpython-38.pyc
byte-compiling build\bdist.win-amd64\egg\nose\twistedtools.py to twistedtools.cpython-38.pyc
byte-compiling build\bdist.win-amd64\egg\nose\util.py to util.cpython-38.pyc
byte-compiling build\bdist.win-amd64\egg\nose\__init__.py to __init__.cpython-38.pyc
byte-compiling build\bdist.win-amd64\egg\nose\__main__.py to __main__.cpython-38.pyc
installing package data to build\bdist.win-amd64\egg
running install_data
creating build\bdist.win-amd64\egg\man
creating build\bdist.win-amd64\egg\man\man1
copying nosetests.1 -&amp;gt; build\bdist.win-amd64\egg\man\man1
creating build\bdist.win-amd64\egg\EGG-INFO
copying nose.egg-info\PKG-INFO -&amp;gt; build\bdist.win-amd64\egg\EGG-INFO
copying nose.egg-info\SOURCES.txt -&amp;gt; build\bdist.win-amd64\egg\EGG-INFO
copying nose.egg-info\dependency_links.txt -&amp;gt; build\bdist.win-amd64\egg\EGG-INFO
copying nose.egg-info\entry_points.txt -&amp;gt; build\bdist.win-amd64\egg\EGG-INFO
copying nose.egg-info\not-zip-safe -&amp;gt; build\bdist.win-amd64\egg\EGG-INFO
copying nose.egg-info\top_level.txt -&amp;gt; build\bdist.win-amd64\egg\EGG-INFO
creating dist
creating &#39;dist\nose-1.3.7-py3.8.egg&#39; and adding &#39;build\bdist.win-amd64\egg&#39; to it
removing &#39;build\bdist.win-amd64\egg&#39; (and everything under it)
Processing nose-1.3.7-py3.8.egg
creating c:\program files\python38\lib\site-packages\nose-1.3.7-py3.8.egg
Extracting nose-1.3.7-py3.8.egg to c:\program files\python38\lib\site-packages
Adding nose 1.3.7 to easy-install.pth file
Installing nosetests-script.py script to C:\Program Files\Python38\Scripts
Installing nosetests.exe script to C:\Program Files\Python38\Scripts
Installing nosetests-3.8-script.py script to C:\Program Files\Python38\Scripts
Installing nosetests-3.8.exe script to C:\Program Files\Python38\Scripts

Installed c:\program files\python38\lib\site-packages\nose-1.3.7-py3.8.egg
Processing dependencies for nose==1.3.7
Finished processing dependencies for nose==1.3.7
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;24&#34;&gt;2.4. 快速使用&lt;/h4&gt;
&lt;p&gt;nose使用相当简单，在windows系统下，只要在终端中进入脚本目录，输入&lt;code&gt;nosetests&lt;/code&gt;即可&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;PS C:\Users\dell\Desktop\test\markdown&amp;gt; nosetests

----------------------------------------------------------------------
Ran 0 tests in 0.001s

OK
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;注意：nose支持python3，但nose下的部分第三方插件本不支持python3，所以使用的时候要注意，本文中提到的均为python3&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;3-nose&#34;&gt;3. nose命令&lt;/h3&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;nosetests -h
Usage: nosetests [options]

Options:
  -h, --help            show this help message and exit
  -V, --version         Output nose version and exit
  -p, --plugins         Output list of available plugins and exit. Combine
                        with higher verbosity for greater detail
  -v, --verbose         Be more verbose. [NOSE_VERBOSE]
  --verbosity=VERBOSITY
                        Set verbosity; --verbosity=2 is the same as -v
  -q, --quiet           Be less verbose
  -c FILES, --config=FILES
                        Load configuration from config file(s). May be
                        specified multiple times; in that case, all config
                        files will be loaded and combined
  -w WHERE, --where=WHERE
                        Look for tests in this directory. May be specified
                        multiple times. The first directory passed will be
                        used as the working directory, in place of the current
                        working directory, which is the default. Others will
                        be added to the list of tests to execute. [NOSE_WHERE]
  --py3where=PY3WHERE   Look for tests in this directory under Python 3.x.
                        Functions the same as &#39;where&#39;, but only applies if
                        running under Python 3.x or above.  Note that, if
                        present under 3.x, this option completely replaces any
                        directories specified with &#39;where&#39;, so the &#39;where&#39;
                        option becomes ineffective. [NOSE_PY3WHERE]
  -m REGEX, --match=REGEX, --testmatch=REGEX
                        Files, directories, function names, and class names
                        that match this regular expression are considered
                        tests.  Default: (?:^|[\b_\.\-])[Tt]est
                        [NOSE_TESTMATCH]
  --tests=NAMES         Run these tests (comma-separated list). This argument
                        is useful mainly from configuration files; on the
                        command line, just pass the tests to run as additional
                        arguments with no switch.
  -l DEBUG, --debug=DEBUG
                        Activate debug logging for one or more systems.
                        Available debug loggers: nose, nose.importer,
                        nose.inspector, nose.plugins, nose.result and
                        nose.selector. Separate multiple names with a comma.
  --debug-log=FILE      Log debug messages to this file (default: sys.stderr)
  --logging-config=FILE, --log-config=FILE
                        Load logging config from this file -- bypasses all
                        other logging config settings.
  -I REGEX, --ignore-files=REGEX
                        Completely ignore any file that matches this regular
                        expression. Takes precedence over any other settings
                        or plugins. Specifying this option will replace the
                        default setting. Specify this option multiple times to
                        add more regular expressions [NOSE_IGNORE_FILES]
  -e REGEX, --exclude=REGEX
                        Don&#39;t run tests that match regular expression
                        [NOSE_EXCLUDE]
  -i REGEX, --include=REGEX
                        This regular expression will be applied to files,
                        directories, function names, and class names for a
                        chance to include additional tests that do not match
                        TESTMATCH.  Specify this option multiple times to add
                        more regular expressions [NOSE_INCLUDE]
  -x, --stop            Stop running tests after the first error or failure
  -P, --no-path-adjustment
                        Don&#39;t make any changes to sys.path when loading tests
                        [NOSE_NOPATH]
  --exe                 Look for tests in python modules that are executable.
                        Normal behavior is to exclude executable modules,
                        since they may not be import-safe [NOSE_INCLUDE_EXE]
  --noexe               DO NOT look for tests in python modules that are
                        executable. (The default on the windows platform is to
                        do so.)
  --traverse-namespace  Traverse through all path entries of a namespace
                        package
  --first-package-wins, --first-pkg-wins, --1st-pkg-wins
                        nose&#39;s importer will normally evict a package from
                        sys.modules if it sees a package with the same name in
                        a different location. Set this option to disable that
                        behavior.
  --no-byte-compile     Prevent nose from byte-compiling the source into .pyc
                        files while nose is scanning for and running tests.
  -a ATTR, --attr=ATTR  Run only tests that have attributes specified by ATTR
                        [NOSE_ATTR]
  -A EXPR, --eval-attr=EXPR
                        Run only tests for whose attributes the Python
                        expression EXPR evaluates to True [NOSE_EVAL_ATTR]
  -s, --nocapture       Don&#39;t capture stdout (any stdout output will be
                        printed immediately) [NOSE_NOCAPTURE]
  --nologcapture        Disable logging capture plugin. Logging configuration
                        will be left intact. [NOSE_NOLOGCAPTURE]
  --logging-format=FORMAT
                        Specify custom format to print statements. Uses the
                        same format as used by standard logging handlers.
                        [NOSE_LOGFORMAT]
  --logging-datefmt=FORMAT
                        Specify custom date/time format to print statements.
                        Uses the same format as used by standard logging
                        handlers. [NOSE_LOGDATEFMT]
  --logging-filter=FILTER
                        Specify which statements to filter in/out. By default,
                        everything is captured. If the output is too verbose,
                        use this option to filter out needless output.
                        Example: filter=foo will capture statements issued
                        ONLY to  foo or foo.what.ever.sub but not foobar or
                        other logger. Specify multiple loggers with comma:
                        filter=foo,bar,baz. If any logger name is prefixed
                        with a minus, eg filter=-foo, it will be excluded
                        rather than included. Default: exclude logging
                        messages from nose itself (-nose). [NOSE_LOGFILTER]
  --logging-clear-handlers
                        Clear all other logging handlers
  --logging-level=LOGCAPTURE_LEVEL
                        Set the log level to capture
  --with-coverage       Enable plugin Coverage:  Activate a coverage report
                        using Ned Batchelder&#39;s coverage module.
                        [NOSE_WITH_COVERAGE]
  --cover-package=PACKAGE
                        Restrict coverage output to selected packages
                        [NOSE_COVER_PACKAGE]
  --cover-erase         Erase previously collected coverage statistics before
                        run
  --cover-tests         Include test modules in coverage report
                        [NOSE_COVER_TESTS]
  --cover-min-percentage=COVER_MIN_PERCENTAGE
                        Minimum percentage of coverage for tests to pass
                        [NOSE_COVER_MIN_PERCENTAGE]
  --cover-inclusive     Include all python files under working directory in
                        coverage report.  Useful for discovering holes in test
                        coverage if not all files are imported by the test
                        suite. [NOSE_COVER_INCLUSIVE]
  --cover-html          Produce HTML coverage information
  --cover-html-dir=DIR  Produce HTML coverage information in dir
  --cover-branches      Include branch coverage in coverage report
                        [NOSE_COVER_BRANCHES]
  --cover-xml           Produce XML coverage information
  --cover-xml-file=FILE
                        Produce XML coverage information in file
  --pdb                 Drop into debugger on failures or errors
  --pdb-failures        Drop into debugger on failures
  --pdb-errors          Drop into debugger on errors
  --no-deprecated       Disable special handling of DeprecatedTest exceptions.
  --with-doctest        Enable plugin Doctest:  Activate doctest plugin to
                        find and run doctests in non-test modules.
                        [NOSE_WITH_DOCTEST]
  --doctest-tests       Also look for doctests in test modules. Note that
                        classes, methods and functions should have either
                        doctests or non-doctest tests, not both.
                        [NOSE_DOCTEST_TESTS]
  --doctest-extension=EXT
                        Also look for doctests in files with this extension
                        [NOSE_DOCTEST_EXTENSION]
  --doctest-result-variable=VAR
                        Change the variable name set to the result of the last
                        interpreter command from the default &#39;_&#39;. Can be used
                        to avoid conflicts with the _() function used for text
                        translation. [NOSE_DOCTEST_RESULT_VAR]
  --doctest-fixtures=SUFFIX
                        Find fixtures for a doctest file in module with this
                        name appended to the base name of the doctest file
  --doctest-options=OPTIONS
                        Specify options to pass to doctest. Eg.
                        &#39;+ELLIPSIS,+NORMALIZE_WHITESPACE&#39;
  --with-isolation      Enable plugin IsolationPlugin:  Activate the isolation
                        plugin to isolate changes to external modules to a
                        single test module or package. The isolation plugin
                        resets the contents of sys.modules after each test
                        module or package runs to its state before the test.
                        PLEASE NOTE that this plugin should not be used with
                        the coverage plugin, or in any other case where module
                        reloading may produce undesirable side-effects.
                        [NOSE_WITH_ISOLATION]
  -d, --detailed-errors, --failure-detail
                        Add detail to error output by attempting to evaluate
                        failed asserts [NOSE_DETAILED_ERRORS]
  --no-skip             Disable special handling of SkipTest exceptions.
  --with-id             Enable plugin TestId:  Activate to add a test id (like
                        #1) to each test name output. Activate with --failed
                        to rerun failing tests only.  [NOSE_WITH_ID]
  --id-file=FILE        Store test ids found in test runs in this file.
                        Default is the file .noseids in the working directory.
  --failed              Run the tests that failed in the last test run.
  --processes=NUM       Spread test run among this many processes. Set a
                        number equal to the number of processors or cores in
                        your machine for best results. Pass a negative number
                        to have the number of processes automatically set to
                        the number of cores. Passing 0 means to disable
                        parallel testing. Default is 0 unless NOSE_PROCESSES
                        is set. [NOSE_PROCESSES]
  --process-timeout=SECONDS
                        Set timeout for return of results from each test
                        runner process. Default is 10. [NOSE_PROCESS_TIMEOUT]
  --process-restartworker
                        If set, will restart each worker process once their
                        tests are done, this helps control memory leaks from
                        killing the system. [NOSE_PROCESS_RESTARTWORKER]
  --with-xunit          Enable plugin Xunit: This plugin provides test results
                        in the standard XUnit XML format. [NOSE_WITH_XUNIT]
  --xunit-file=FILE     Path to xml file to store the xunit report in. Default
                        is nosetests.xml in the working directory
                        [NOSE_XUNIT_FILE]
  --xunit-testsuite-name=PACKAGE
                        Name of the testsuite in the xunit xml, generated by
                        plugin. Default test suite name is nosetests.
  --all-modules         Enable plugin AllModules: Collect tests from all
                        python modules.  [NOSE_ALL_MODULES]
  --collect-only        Enable collect-only:  Collect and output test names
                        only, don&#39;t run any tests.  [COLLECT_ONLY]
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;4&#34;&gt;4. 基本用法&lt;/h3&gt;
&lt;p&gt;使用notetests脚本&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;nosetests [options] [(optional) test files or directories]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;除了使用命令行参数外，你还可以在测试目录下配置.noserc或者nose.cfg文件。该配置文件是标准的.ini配置文件。把你的配置写在[nosetests]部分，如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;[nosetests]
verbosity=3
with-doctest=1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也有不能使用配置文件的情况（如运行nose时你不想让使用nose的全局配置文件）。为了忽略这个配置文件，我们可以设置一个环境变量&lt;code&gt;NOSE_IGNORE_CONFIG_FILES&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;除了使用notetests外，我们还可以使用其他方法运行nose，如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;import nose
nose.main()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你不想使用unittest框架测试结束时这种显示方式，可以在脚本中使用以下方式：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;import nose
result = nose.run()
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;41-nose&#34;&gt;4.1 nose测试实践&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;函数形式的测试用例&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;#coding:utf-8

def setUp():
    print(&amp;quot;test_setUp&amp;quot;)

def test_task_1():
    print(&amp;quot;test_task_1&amp;quot;)

def test_task_2():
    print(&amp;quot;test_task_2&amp;quot;)

def test_task_3():
    print(&amp;quot;test_task_3&amp;quot;)    

def tearDown():
    print(&amp;quot;test_teardown&amp;quot;)

test_task_1.teardown=test_task_3.teardown= tearDown
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行的结果如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;PS C:\Users\dell\Desktop\test\nose&amp;gt; nosetests -v -s test_case.test_case_1
test_setUp
test_case_1.test_task_1 ... test_task_1
test_teardown
ok
test_case_1.test_task_2 ... test_task_2
ok
test_case_1.test_task_3 ... test_task_3
test_teardown
ok
test_teardown

----------------------------------------------------------------------
Ran 3 tests in 0.002s

OK
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后面加了一句&lt;code&gt;test_task_1.teardown=test_task_3.teardown= tearDown&lt;/code&gt;，说明在运行完成后就执行tearDown操作，所以这里的执行顺序是：&lt;code&gt;setUp--&amp;gt;test_task_1--&amp;gt;teardown--&amp;gt;test_task_2--&amp;gt;test_task_3--&amp;gt;teardown--&amp;gt;teardown&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;因次，在函数或者函数式的用例组织中，setUp和tearDown只会执行一次，分别是开始及结束。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;类形式的测试用例&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;# coding=utf-8

class TestClass():

    def setUpClass():
        print(&amp;quot;TestClass.setUpClass&amp;quot;)

    def setUp(self):
        print(&amp;quot;TestClass.setup&amp;quot;)

    def Testfunc1(self):
        print(&amp;quot;TestClass.Testfunc1&amp;quot;)

    def test_func1(self):
        print(&amp;quot;TestClass.test_func1&amp;quot;)

    def Testfunc2(self):
        print(&amp;quot;TestClass.Testfunc2&amp;quot;)

    def test_func2(self):
        print(&amp;quot;TestClass.test_func2&amp;quot;)

    def tearDown(self):
        print(&amp;quot;TestClass_setup_teardown&amp;quot;)

    def tearDownClass():
        print(&amp;quot;TestClass.tearDownClass&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;PS C:\Users\dell\Desktop\test\nose&amp;gt; nosetests -v -s test_case.test_case_2
TestClass.setUpClass
test_case_2.TestClass.Testfunc1 ... TestClass.setup
TestClass.Testfunc1
TestClass_setup_teardown
ok
test_case_2.TestClass.Testfunc2 ... TestClass.setup
TestClass.Testfunc2
TestClass_setup_teardown
ok
test_case_2.TestClass.test_func1 ... TestClass.setup
TestClass.test_func1
TestClass_setup_teardown
ok
test_case_2.TestClass.test_func2 ... TestClass.setup
TestClass.test_func2
TestClass_setup_teardown
ok
TestClass.tearDownClass

----------------------------------------------------------------------
Ran 4 tests in 0.003s

OK
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从运行结果中可以看出，每个用例都会分别执行&lt;code&gt;setUp&lt;/code&gt;及&lt;code&gt;tearDown&lt;/code&gt;，但是与unittest一样，在类中的测试用例顺序变更了，由字母排序了。而&lt;code&gt;setUpClass&lt;/code&gt;和&lt;code&gt;tearDownClass&lt;/code&gt;两个函数功能，只运行一次。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;包形式运行&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们创建包的时候需要同时新建&lt;code&gt;__init__.py&lt;/code&gt;，添加内容如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;def setUp():
    print(&amp;quot;全部开始&amp;quot;)

def tearDown():
    print(&amp;quot;全部结束&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后再次执行包文件，结果如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;PS C:\Users\dell\Desktop\test\nose&amp;gt; nosetests -v -s test_case.test_case_2
全部开始
TestClass.setUpClass
test_case.test_case_2.TestClass.Testfunc1 ... TestClass.setup
TestClass.Testfunc1
TestClass_setup_teardown
ok
test_case.test_case_2.TestClass.Testfunc2 ... TestClass.setup
TestClass.Testfunc2
TestClass_setup_teardown
ok
test_case.test_case_2.TestClass.test_func1 ... TestClass.setup
TestClass.test_func1
TestClass_setup_teardown
ok
test_case.test_case_2.TestClass.test_func2 ... TestClass.setup
TestClass.test_func2
TestClass_setup_teardown
ok
TestClass.tearDownClass
全部结束

----------------------------------------------------------------------
Ran 4 tests in 0.002s

OK
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从结果中可以看出，在执行前执行了&lt;code&gt;__init__.py&lt;/code&gt;中的setUp函数，在执行最后执行了teardown函数。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;with_setup修饰器&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;nose支持在每个用例前使用with_setup来自定义测试用例的setUp及tearDown功能，如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;# coding=utf-8

from nose.tools import with_setup

def setup_func():
    print(&amp;quot;set up test fixtures&amp;quot;)

def teardown_func():
    print(&amp;quot;tear down test fixtures&amp;quot;)

@with_setup(setup_func, teardown_func)
def test_1():
    print(&amp;quot;test_1&amp;quot;)

def test_2():
    print(&amp;quot;test_2&amp;quot;)

test_2.setup = setup_func
test_2.teardown = teardown_func
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;PS C:\Users\dell\Desktop\test\nose&amp;gt; nosetests -v -s test_case.test_case_3
全部开始
test_case.test_case_3.test_1 ... set up test fixtures
test_1
tear down test fixtures
ok
test_case.test_case_3.test_2 ... set up test fixtures
test_2
tear down test fixtures
ok
全部结束

----------------------------------------------------------------------
Ran 2 tests in 0.002s

OK
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;除了&lt;code&gt;with_setup&lt;/code&gt;的方法&lt;code&gt;@with_setup(setup_func, teardown_func)&lt;/code&gt;，还可以这样写&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;test_2.setup = setup_func
test_2.teardown = teardown_func
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;多文件执行nose&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如下，有三个可执行的文件&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;test_case
|--__init__.py
|--test_case_1.py
|--test_case_2.py
|--test_case_3.py
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;PS C:\Users\dell\Desktop\test\nose&amp;gt; nosetests -w test_case test_case_2
....
----------------------------------------------------------------------
Ran 4 tests in 0.001s

OK
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;42-nose&#34;&gt;4.2 &lt;strong&gt;nose运行方式&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;unittest&lt;/code&gt; 所支持的用例发现和执行能力，&lt;code&gt;nose&lt;/code&gt; 均支持。 &lt;code&gt;nose&lt;/code&gt; 支持用例自动（递归）发现：&lt;/p&gt;
&lt;p&gt;默认发现当前目录下所有包含 &lt;code&gt;test&lt;/code&gt; 的测试用例，但不包括以 &lt;code&gt;_&lt;/code&gt; 开头的用例，使用 &lt;code&gt;nosetests&lt;/code&gt; 命令，通过 &lt;code&gt;-w&lt;/code&gt; 参数指定要自动发现的目录， &lt;code&gt;-m&lt;/code&gt; 参数指定用例文件、目录、函数、类的名称模式（正则匹配），&lt;code&gt;nosetests -w project_directory &#34;test_.+&#34;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;nose&lt;/code&gt; 也支持执行指定用例：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;指定测试模块&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;nosetests test_case.test_case_1&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;指定测试类&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;nosetests test_case.test_case_2:TestClass&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;指定测试方法&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;nosetests test_case.test_case_2:TestClass.Testfunc1&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;指定测试文件路径&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;nosetests C:/Users/dell/Desktop/test/nose/test_case/test_case_1.py&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;指定测试文件路径+测试类或测试函数（这是 &lt;code&gt;unittest&lt;/code&gt; 所不支持的）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;nosetests C:/Users/dell/Desktop/test/nose/test_case/test_case_2.py:TestClass&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;nosetests C:/Users/dell/Desktop/test/nose/test_case/test_case_2.py:TestClass.Testfunc1&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;nosetests C:/Users/dell/Desktop/test/nose/test_case/test_case_1.py:test_task_1&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;5&#34;&gt;5. 子测试/测试生成器&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;nose&lt;/code&gt; 除了支持 &lt;code&gt;unittest&lt;/code&gt; 中的 &lt;code&gt;TestCase.subTest&lt;/code&gt;，还支持一种更为强大的子测试编写方式，也就是 &lt;code&gt;测试生成器（Test generators）&lt;/code&gt;，通过 &lt;code&gt;yield&lt;/code&gt; 实现。&lt;/p&gt;
&lt;p&gt;在下面的示例中，定义一个 &lt;code&gt;test_evens&lt;/code&gt; 测试函数，里面生成了 5 个子测试 &lt;code&gt;check_even&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-python&#34;&gt;def test_evens():
    for i in range(0, 5):
        yield check_even, i, i*3

def check_even(n, nn):
    assert n % 2 == 0 or nn % 2 == 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此外，相较于 &lt;code&gt;unittest.TestCase.subTest&lt;/code&gt; 多个子测试只能执行一次测试前置和清理，&lt;code&gt;nose&lt;/code&gt;的 &lt;code&gt;测试生成器&lt;/code&gt; 可以支持每个子测试执行一次测试前置和清理，如：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-python&#34;&gt;def test_generator():
    # ...
    yield func, arg, arg # ...

@with_setup(setup_func, teardown_func)
def func(arg):
    assert something_about(arg)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如下是一个例子：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;# coding=utf-8

def setUp():
    print(&#39;testSetUp&#39;)

def tearDown():
    print(&#39;testTearDown&#39;)

def test_evens():
    for i in range(0, 5):
        yield check_even, i, i*3

def check_even(n, nn):
    assert n % 2 == 0 or nn % 2 == 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;PS C:\Users\dell\Desktop\test\nose&amp;gt; nosetests -v -s test_case.test_case_5
全部开始
testSetUp
test_case.test_case_5.test_evens(0, 0) ... ok
test_case.test_case_5.test_evens(1, 3) ... FAIL
test_case.test_case_5.test_evens(2, 6) ... ok
test_case.test_case_5.test_evens(3, 9) ... FAIL
test_case.test_case_5.test_evens(4, 12) ... ok
testTearDown
全部结束

======================================================================
FAIL: test_case.test_case_5.test_evens(1, 3)
----------------------------------------------------------------------
Traceback (most recent call last):
  File &amp;quot;c:\program files\python38\lib\site-packages\nose-1.3.7-py3.8.egg\nose\case.py&amp;quot;, line 197, in runTest
    self.test(*self.arg)
  File &amp;quot;C:\Users\dell\Desktop\test\nose\test_case\test_case_5.py&amp;quot;, line 14, in check_even
    assert n % 2 == 0 or nn % 2 == 0
AssertionError

======================================================================
FAIL: test_case.test_case_5.test_evens(3, 9)
----------------------------------------------------------------------
Traceback (most recent call last):
  File &amp;quot;c:\program files\python38\lib\site-packages\nose-1.3.7-py3.8.egg\nose\case.py&amp;quot;, line 197, in runTest
    self.test(*self.arg)
  File &amp;quot;C:\Users\dell\Desktop\test\nose\test_case\test_case_5.py&amp;quot;, line 14, in check_even
    assert n % 2 == 0 or nn % 2 == 0
AssertionError

----------------------------------------------------------------------
Ran 5 tests in 0.003s

FAILED (failures=2)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;6-nose&#34;&gt;&lt;strong&gt;6. nose的测试工具集&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;nose.tools模块提供了一系列的小工具，包括测试执行时间、异常输出及unittest框架中所有的assert功能。&lt;/p&gt;
&lt;p&gt;为了使写用例更加容易，nose.tools提供了部分便利的功能函数，下面写几个常用的，如下：&lt;/p&gt;
&lt;h4 id=&#34;61-nosetoolsok_expr-msgnone&#34;&gt;6.1 nose.tools.ok_(expr, msg=None)&lt;/h4&gt;
&lt;p&gt;标准的assert，例子如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;from nose.tools import ok_

def test_lean_2():
    print &amp;quot;test_case_2&amp;quot;
    ok_(4==3,msg=&amp;quot;Error&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行结果如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;PS C:\Users\dell\Desktop\test\nose&amp;gt; nosetests -v test_case.test_case_4:test_task_1
test_case.test_case_4.test_task_1 ... FAIL

======================================================================
FAIL: test_case.test_case_4.test_task_1
----------------------------------------------------------------------
Traceback (most recent call last):
  File &amp;quot;c:\program files\python38\lib\site-packages\nose-1.3.7-py3.8.egg\nose\case.py&amp;quot;, line 197, in runTest
    self.test(*self.arg)
  File &amp;quot;C:\Users\dell\Desktop\test\nose\test_case\test_case_4.py&amp;quot;, line 7, in test_task_1
    ok_(4==3,msg=&amp;quot;Error&amp;quot;)
AssertionError: Error
-------------------- &amp;gt;&amp;gt; begin captured stdout &amp;lt;&amp;lt; ---------------------
test_task_1

--------------------- &amp;gt;&amp;gt; end captured stdout &amp;lt;&amp;lt; ----------------------

----------------------------------------------------------------------
Ran 1 test in 0.001s

FAILED (failures=1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;断言结果&lt;code&gt;AssertionError: Error&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;62-nosetoolseq_a-b-msgnone&#34;&gt;6.2 nose.tools.eq_(a, b, msg=None)&lt;/h4&gt;
&lt;p&gt;将参数a与b快速对比&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;from nose.tools import eq_

def test_task_2():
    eq_(5, 6, msg=&amp;quot;Wrong&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行结果如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;PS C:\Users\dell\Desktop\test\nose&amp;gt; nosetests -v test_case.test_case_4:test_task_2
test_case.test_case_4.test_task_2 ... FAIL

======================================================================
FAIL: test_case.test_case_4.test_task_2
----------------------------------------------------------------------
Traceback (most recent call last):
  File &amp;quot;c:\program files\python38\lib\site-packages\nose-1.3.7-py3.8.egg\nose\case.py&amp;quot;, line 197, in runTest
    self.test(*self.arg)
  File &amp;quot;C:\Users\dell\Desktop\test\nose\test_case\test_case_4.py&amp;quot;, line 10, in test_task_2
    eq_(5, 6, msg=&amp;quot;Wrong&amp;quot;)
AssertionError: Wrong

----------------------------------------------------------------------
Ran 1 test in 0.001s

FAILED (failures=1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;断言结果&lt;code&gt;AssertionError: Wrong&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;63-nosetoolsassert_inmember-container-msgnone&#34;&gt;6.3 nose.tools.assert_in(member, container, msg=None)&lt;/h4&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;from nose.tools import assert_in
def test_task_3():
    assert_in(&amp;quot;aaa&amp;quot;,&#39;bbb&#39;,msg=&amp;quot;test  in failed&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行结果如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;PS C:\Users\dell\Desktop\test\nose&amp;gt; nosetests -v test_case.test_case_4:test_task_3
test_case.test_case_4.test_task_3 ... FAIL

======================================================================
FAIL: test_case.test_case_4.test_task_3
----------------------------------------------------------------------
Traceback (most recent call last):
  File &amp;quot;c:\program files\python38\lib\site-packages\nose-1.3.7-py3.8.egg\nose\case.py&amp;quot;, line 197, in runTest
    self.test(*self.arg)
  File &amp;quot;C:\Users\dell\Desktop\test\nose\test_case\test_case_4.py&amp;quot;, line 13, in test_task_3
    assert_in(&amp;quot;aaa&amp;quot;,&#39;bbb&#39;,msg=&amp;quot;test in failed&amp;quot;)
AssertionError: &#39;aaa&#39; not found in &#39;bbb&#39; : test in failed

----------------------------------------------------------------------
Ran 1 test in 0.001s

FAILED (failures=1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;断言结果&lt;code&gt;AssertionError: &#39;aaa&#39; not found in &#39;bbb&#39; : test in failed&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;64-nosetoolsset_trace&#34;&gt;6.4 nose.tools.set_trace()&lt;/h4&gt;
&lt;p&gt;单步调试工具，在多个模块，大程序时这个功能好用。内部使用的是pdb.set_trace。&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;from nose.tools import assert_in
from nose.tools import set_trace

def test_task_4():
    set_trace()
    assert_in(&amp;quot;aaa&amp;quot;,&#39;bbb&#39;,msg=&amp;quot;test in failed&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;PS C:\Users\dell\Desktop\test\nose&amp;gt; nosetests -v test_case.test_case_4:test_task_4
test_case.test_case_4.test_task_4 ... &amp;gt; c:\users\dell\desktop\test\nose\test_case\test_case_4.py(17)test_task_4()
-&amp;gt; assert_in(&amp;quot;aaa&amp;quot;,&#39;bbb&#39;,msg=&amp;quot;test in failed&amp;quot;)
(Pdb) n
AssertionError: &#39;aaa&#39; not found in &#39;bbb&#39; : test in failed
&amp;gt; c:\users\dell\desktop\test\nose\test_case\test_case_4.py(17)test_task_4()
-&amp;gt; assert_in(&amp;quot;aaa&amp;quot;,&#39;bbb&#39;,msg=&amp;quot;test in failed&amp;quot;)
(Pdb) c
FAIL

======================================================================
FAIL: test_case.test_case_4.test_task_4
----------------------------------------------------------------------
Traceback (most recent call last):
  File &amp;quot;c:\program files\python38\lib\site-packages\nose-1.3.7-py3.8.egg\nose\case.py&amp;quot;, line 197, in runTest
    self.test(*self.arg)
  File &amp;quot;C:\Users\dell\Desktop\test\nose\test_case\test_case_4.py&amp;quot;, line 17, in test_task_4
    assert_in(&amp;quot;aaa&amp;quot;,&#39;bbb&#39;,msg=&amp;quot;test in failed&amp;quot;)
AssertionError: &#39;aaa&#39; not found in &#39;bbb&#39; : test in failed

----------------------------------------------------------------------
Ran 1 test in 4.615s

FAILED (failures=1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;断言结果&lt;code&gt;AssertionError: &#39;aaa&#39; not found in &#39;bbb&#39; : test in failed&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;下面是该工具的命令集&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;Documented commands (type help &amp;lt;topic&amp;gt;):
========================================
EOF    c          d        h         list      q        rv       undisplay
a      cl         debug    help      ll        quit     s        unt
alias  clear      disable  ignore    longlist  r        source   until
args   commands   display  interact  n         restart  step     up
b      condition  down     j         next      return   tbreak   w
break  cont       enable   jump      p         retval   u        whatis
bt     continue   exit     l         pp        run      unalias  where

Miscellaneous help topics:
==========================
exec  pdb
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;65-nosetoolstimedlimit&#34;&gt;6.5 nose.tools.timed(limit)&lt;/h4&gt;
&lt;p&gt;测试必须在设定的时间内（以秒为单位）完成 ，否则测试失败；代码如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;from nose.tools import timed
import time

@timed(1)    
def test_lean_5():
    time.sleep(2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;测试结果如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;PS C:\Users\dell\Desktop\test\nose&amp;gt; nosetests -v test_case.test_case_4:test_task_5
test_case.test_case_4.test_task_5 ... FAIL

======================================================================
FAIL: test_case.test_case_4.test_task_5
----------------------------------------------------------------------
Traceback (most recent call last):
  File &amp;quot;c:\program files\python38\lib\site-packages\nose-1.3.7-py3.8.egg\nose\case.py&amp;quot;, line 197, in runTest
    self.test(*self.arg)
  File &amp;quot;c:\program files\python38\lib\site-packages\nose-1.3.7-py3.8.egg\nose\tools\nontrivial.py&amp;quot;, line 100, in newfunc
    raise TimeExpired(&amp;quot;Time limit (%s) exceeded&amp;quot; % limit)
nose.tools.nontrivial.TimeExpired: Time limit (1) exceeded

----------------------------------------------------------------------
Ran 1 test in 2.008s

FAILED (failures=1)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;66-nosetools&#34;&gt;6.6 nose.tools.*&lt;/h4&gt;
&lt;p&gt;nose.tools中还有很多assert的函数工具，不一一介绍了，列出表如下，需要的时候可以使用。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align: center;&#34;&gt;函数&lt;/th&gt;
&lt;th style=&#34;text-align: center;&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;assert_equal(first,second,msg=None)&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;两个对像对比，使用&#34;==&#34;操作对比&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;assert_not_equal(first,second,msg=None)&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;不相等&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;assert_true(expr,msg=None)&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;判定表达式是否为真&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;assert_false(expr,msg=None)&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;判定表达式是否为假&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;assert_is(expr1,expr2,msg=None)&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;expr1isexpr2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;assert_is_not(expr1,expr2,msg=None)&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;assert_is_none(obj,msg=None)&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;为空&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;assert_is_not_none(obj,msg=None)&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;不为空&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;assert_in(member,container,msg=None)&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;merberincontainer判断&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;assert_not_in(member,container,msg=None)&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;不包含判断&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;assert_is_instance(obj,cls,msg=None)&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;assert_not_is_instance(obj,cls,msg=None)&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;assert_raises_regexp(expected_exception,expected_regexp,callable_obj=None,&lt;em&gt;args,&lt;/em&gt;*kwargs)&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;assert_almost_equal(first,second,places=None,msg=None,delta=None)&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;assert_greater(a,b,msg=None)&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;assert_greater_equal(a,b,msg=None)&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;assert_less(a,b,msg=None)&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;assert_less_equal(a,b,msg=None)&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;assert_regexp_matches(text,expected_regexp,msg=None)&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;assert_not_regexp_matches(text,unexpected_regexp,msg=None)&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;assert_items_equal(expected_seq,actual_seq,msg=None)&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;assert_dict_contains_subset(expected,actual,msg=None)&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;assert_multi_line_equal(first,second,msg=None)&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;assert_sequence_equal(seq1,seq2,msg=None,seq_type=None)&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;assert_list_equal(list1,list2,msg=None)&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;assert_tuple_equal(tuple1,tuple2,msg=None)&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;assert_set_equal(set1,set2,msg=None)&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;assert_dict_equal(d1,d2,msg=None)&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;7&#34;&gt;7. 插件&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;nose&lt;/code&gt; 相较于 &lt;code&gt;unittest&lt;/code&gt; 一个最大的优势就是插件体系，自带了很多有用的插件，也有丰富的第三方插件。这样就能做更多的事情。&lt;/p&gt;
&lt;p&gt;其中，自带插件如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://nose.readthedocs.io/en/latest/plugins/allmodules.html&#34;&gt;AllModules&lt;/a&gt;：在所有模块中收集用例。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://nose.readthedocs.io/en/latest/plugins/attrib.html&#34;&gt;Attrib&lt;/a&gt;：给用例打标签，并可运行含指定标签的用例&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://nose.readthedocs.io/en/latest/plugins/capture.html&#34;&gt;Capture&lt;/a&gt;：捕获用例的标准输出&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://nose.readthedocs.io/en/latest/plugins/collect.html&#34;&gt;Collect&lt;/a&gt;：快速收集用例&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://nose.readthedocs.io/en/latest/plugins/cover.html&#34;&gt;Cover&lt;/a&gt;：统计代码覆盖率&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://nose.readthedocs.io/en/latest/plugins/debug.html&#34;&gt;Debug&lt;/a&gt;：用例失败时进入 pdb 调试&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://nose.readthedocs.io/en/latest/plugins/deprecated.html&#34;&gt;Deprecated&lt;/a&gt;：标记用例为弃用&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://nose.readthedocs.io/en/latest/plugins/deprecated.html&#34;&gt;Doctests&lt;/a&gt;：运行文档用例&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://nose.readthedocs.io/en/latest/plugins/failuredetail.html&#34;&gt;Failure Detail&lt;/a&gt;：断言失败时提供上下文信息&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://nose.readthedocs.io/en/latest/plugins/isolate.html&#34;&gt;Isolate&lt;/a&gt;：保护用例避免受一些副作用的影响&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://nose.readthedocs.io/en/latest/plugins/logcapture.html&#34;&gt;Logcapture&lt;/a&gt;：捕捉 logging 输出&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://nose.readthedocs.io/en/latest/plugins/multiprocess.html&#34;&gt;Multiprocess&lt;/a&gt;：并行执行用例&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://nose.readthedocs.io/en/latest/plugins/prof.html&#34;&gt;Prof&lt;/a&gt;：使用热点分析器进行分析&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://nose.readthedocs.io/en/latest/plugins/skip.html&#34;&gt;Skip&lt;/a&gt;：标记用例为跳过&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://nose.readthedocs.io/en/latest/plugins/testid.html&#34;&gt;Testid&lt;/a&gt;：为输出的每个用例名称添加测试 ID&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://nose.readthedocs.io/en/latest/plugins/xunit.html&#34;&gt;Xunit&lt;/a&gt;：以 xunit 格式输出测试结果&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;还有很多第三方库，如用来生成 HTML 格式测试报告的 &lt;a href=&#34;https://github.com/ionelmc/nose-htmloutput&#34;&gt;nose-htmloutput&lt;/a&gt; 等，这里不再赘述。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;nose&lt;/code&gt; 得益于丰富的插件生态，当 &lt;code&gt;nose&lt;/code&gt; 本身不能够完全满足我们的测试需求时，可以通过安装插件，并在 &lt;code&gt;nosetests&lt;/code&gt; 命令行指定该插件所提供的特定参数即可非常容易的使用插件。 相较于 &lt;code&gt;unittest&lt;/code&gt;，就能省去很多自己开发额外测试逻辑的精力。&lt;/p&gt;</description>  
      <pubDate>2025-10-09 17:54:40</pubDate>  
      <link>https://testpoo.github.io/nose简介.html</link>  
      <guid isPermaLink="true">https://testpoo.github.io/nose简介.html</guid>
       
      <category>测试</category> 
      
    </item>
    
    <item> 
      <title>Python自动化之unittest</title>  
      <description>&lt;div class=&#34;toc&#34;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-unittest&#34;&gt;1. unittest 基本用法&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#_1&#34;&gt;基本应用：&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#11-unittest&#34;&gt;1.1 unittest 初体验&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#12-unittest&#34;&gt;1.2 unittest 自动化实现实战&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-unittest-ddtdata-driver-tests&#34;&gt;2 unittest 结合 DDT(data-driver tests) 自动化&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#21-ddt-data-unpack&#34;&gt;2.1 ddt 中的 data 与 unpack&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#22-ddt&#34;&gt;2.2 ddt 数据驱动&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3-unittest&#34;&gt;3 unittest 断言用法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4-unittestskip&#34;&gt;4 unittest.skip()用法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5-unittestrunner&#34;&gt;5 unittest测试套件及runner应用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#6-unittesthtmltestrunner&#34;&gt;6 unittest+HTMLTestRunner 自动化实现&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#61&#34;&gt;6.1 导入环境&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#62&#34;&gt;6.2 导包&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#7&#34;&gt;7.总结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;p&gt;本次主要给大家介绍关于Python自动化框架unittest。&lt;/p&gt;
&lt;h3 id=&#34;1-unittest&#34;&gt;1. unittest 基本用法&lt;/h3&gt;
&lt;p&gt;unittest 框架是 Python 自带的一个作为单元测试的测试框，相当于 Java中的 JUnit，随着自动化技术的成熟，unittest 成为了测试框架第一选择，可以完整的结合 Selenium、Requests 来实现 Ul 和接口的自动化。&lt;/p&gt;
&lt;h4 id=&#34;_1&#34;&gt;基本应用：&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;环境搭建，Python 中已经自带了 unittest 框架，无须额外安装&lt;/li&gt;
&lt;li&gt;四大组件：&lt;/li&gt;
&lt;li&gt;test fixture：setUp(前置条件）、tearDown（后置条件），用于初始化测试用例及清理和释放资源&lt;/li&gt;
&lt;li&gt;test case：测试用例，通过集成 unttest.TestCase，来实现用例的继承，在 unittest 中，测试用例都是通过test_来识别的，测试用例命名 test_XXX&lt;/li&gt;
&lt;li&gt;test suite：测试套件，也称之为测试用例集&lt;/li&gt;
&lt;li&gt;test runner：运行器，一般通过 runner 来调用 suite 去执行测试
  unittest 运行机制：通过在 main 函数中，调用 unittest.main(verbosity=2) 运行所有内容&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;11-unittest&#34;&gt;1.1 unittest 初体验&lt;/h4&gt;
&lt;p&gt;先通过实例对unittest来个直观了解吧&lt;/p&gt;
&lt;p&gt;1.py&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;# coding=utf-8

import unittest

# 通过继承 unittest.TestCase 来实现用例
class forTest(unittest.TestCase):
    # 类的初始化
    @classmethod
    def setUpClass(cls):
        print(&#39;class&#39;)
    # 类的释放
    @classmethod
    def tearDownClass(cls):
        print(&#39;tclass&#39;)

    # 测试用例初始化
    def setUp(self):
        print(&amp;quot;setUp&amp;quot;)
    # 测试用例释放
    def tearDown(self):
        print(&amp;quot;teadDown&amp;quot;)

    # 测试用例
    def test_a(self):
        print(&amp;quot;a&amp;quot;)
    # 测试用例
    def test_b(self):
        print(&amp;quot;b&amp;quot;)

    # 函数
    def add(self, a, b):
        return a + b
    # 测试用例
    def test_c(self):
        c = self.add(1, 3)
        print(&#39;c =&#39;, c)

if __name__ == &amp;quot;__main__&amp;quot;:
    unittest.main(verbosity=2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对上面的程序进行讲解：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;类的初始化与释放&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;def setUpClass(cls)&lt;/code&gt;表示类的初始化，在执行测试用例之前执行，只执行一次，函数参数为cls 表示这是一个类方法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;def tearDownClass(cls)&lt;/code&gt;表示类的释放，在执行测试用例之后执行，只执行一次&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;测试用例的初始化与释放&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;def setUp(self)&lt;/code&gt;用于测试用例的初始化，在每个测试用例之前都会执行，有多少个测试用例，就会执行多少次&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;def tearDown(self)&lt;/code&gt;用于测试用例释放，在每个测试用例执行之后执行，有多少个测试用例，就会执行多少次&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;注意：方法 setUpClass，tearDownClass，setUp，tearDown 的方法名是固定的，不能改动，不然框架无法识别&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;测试用例的定义&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;测试用例的命名规则为 test_xxx，这样测试用例就会自动执行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;注意：只有测试用例才会被执行，不以test_xxx 命名的函数是方法，方法是不能被执行的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;执行测试用例&lt;/li&gt;
&lt;li&gt;通过在 main 函数中，调用 unitest.main() 运行所有内容&lt;/li&gt;
&lt;li&gt;verbosity：表示测试结果的信息复杂度&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;verbosity默认为1，可以设置为0和2。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;0 (静默模式): 只能获得总的测试用例数和总的结果。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;1 (默认模式): 非常类似静默模式 只是在每个成功的用例前面有个“.” 每个失败的用例前面有个“F”，每个跳过的案例前面有个“S”，每个预期失败真失败的案例前面有个“X”，每个预期失败却成功的案例前面有个“U”&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2 (详细模式):测试结果会显示每个测试用例的所有相关的信息 并且 你在命令行里加入不同的参数可以起到一样的效果&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;运行结果分析：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;类的初始化方法 setUpClass(cls) 在所有的测试用例之前执行，类的释放函数 tearDownClass(cls) 在所有的测试用例之后执行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;测试用例的初始化在每个测试用例之前都会执行，测试用例的释放在每个测试用例之后都会执行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;test_a(self) 和 test_b(self) 是测试用例，运行时被自动执行，add(self, a, b) 是函数，不会被自动执行，test_c(self) 是测试用例，调用了 add 函数，这样就可以执行 add 函数了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;运行结果如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;class
test_a (__main__.forTest) ... setUp
a
teadDown
ok
test_b (__main__.forTest) ... setUp
b
teadDown
ok
test_c (__main__.forTest) ... setUp
c = 4
teadDown
ok
tclass
----------------------------------------------------------------------
Ran 3 tests in 0.002s
OK
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;相信有了上面的例子，已经对unittest 有了一个初步的印象。&lt;/p&gt;
&lt;h4 id=&#34;12-unittest&#34;&gt;1.2 unittest 自动化实现实战&lt;/h4&gt;
&lt;p&gt;有了类的初始化与释放，测试用例的初始化与释放，我们可以将多个测试用例中相同的代码提取出来，减少自动化测试冗余，这样便于维护。
下面看这样一个例子，我们打开谷歌浏览器，输入百度网址并进行搜索，搜索后关闭浏览器&lt;/p&gt;
&lt;p&gt;2.py&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;#coding=utf-8
import unittest
from selenium import webdriver
import time

class forTest(unittest.TestCase):
    # 测试用例初始化
    # 打开谷歌浏览器，并进入百度
    def setUp(self):
        self.driver = webdriver.Chrome()
        self.driver.get(&#39;http://www.baidu.com&#39;)
    # 测试用例释放
    # 等待 3s，关闭浏览器
    def tearDown(self):
        time.sleep(3)
        self.driver.quit()

    # 输入&#39;苹果&#39;，并点击搜索
    def test_1(self):
        self.driver.find_element_by_id(&#39;kw&#39;).send_keys(&#39;苹果&#39;)
        self.driver.find_element_by_id(&#39;su&#39;).click()

    # 输入&#39;香蕉&#39;，并点击搜索
    def test_2(self):
        self.driver.find_element_by_id(&#39;kw&#39;).send_keys(&#39;香蕉&#39;)
        self.driver.find_element_by_id(&#39;su&#39;).click()

if __name__ == &#39;__main__&#39;:
    unittest.main(verbosity=2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的案例中，我们将打开谷歌浏览器，进入百度，放在 setUp 中，完成每个测试用例之前的初始化，浏览器的关闭放在tearDown 中，完成测试用例的释放&lt;/p&gt;
&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;test_1 (__main__.forTest) ... 
ok
test_2 (__main__.forTest) ... 
ok
----------------------------------------------------------------------
Ran 2 tests in 38.884s
OK
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-unittest-ddtdata-driver-tests&#34;&gt;2 unittest 结合 DDT(data-driver tests) 自动化&lt;/h3&gt;
&lt;h4 id=&#34;21-ddt-data-unpack&#34;&gt;2.1 ddt 中的 data 与 unpack&lt;/h4&gt;
&lt;p&gt;在实际测试中，单个测试是需要用多种不同的条件（测试数据）对其进行测试的。&lt;/p&gt;
&lt;p&gt;需要额外安装ddt库&lt;/p&gt;
&lt;p&gt;ddt 中最基本的应用；在 class 前定义 @ddt，用于表示要使用 ddt 了，再基于实际的应用。选择对应的装饰器来使用即可，说白了，就是一个装饰器&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;data 用于设定参数&lt;/li&gt;
&lt;li&gt;unpack 用于解析参数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;直接看例子比较直观&lt;/p&gt;
&lt;p&gt;3.py&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;# coding=utf-8
import unittest
from ddt import ddt
from ddt import data    # 导入data

# 类之前定义装饰器，表示在类中要使用ddt了
@ddt
class MyTestCase(unittest.TestCase):
    def setUp(self):
        print(&#39;\n{:=^20}&#39;.format(&amp;quot;测试开始&amp;quot;))
    def tearDown(self):
        print(&amp;quot;{:=^20}&amp;quot;.format(&#39;测试结束&#39;))
    # data用于设定参数
    @data(&#39;苹果&#39;, &#39;香蕉&#39;, &#39;葡萄&#39;, &#39;石榴&#39;)
    def test_1(self, txt):
        print(txt)
if __name__ == &#39;__main__&#39;:
    unittest.main(verbosity=2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;test_1_1_苹果 (__main__.MyTestCase) ... 
========测试开始========
苹果
========测试结束========
ok
test_1_2_香蕉 (__main__.MyTestCase) ... 
========测试开始========
香蕉
========测试结束========
ok
test_1_3_葡萄 (__main__.MyTestCase) ...
========测试开始========
葡萄
========测试结束========
ok
test_1_4_石榴 (__main__.MyTestCase) ...
========测试开始========
石榴
========测试结束========
ok
----------------------------------------------------------------------
Ran 4 tests in 0.004s
OK
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到测试用例 def test_1(self, txt) 被执行了四次，data 用于设定参数，将参数依次放入测试用例中进行测试。&lt;/p&gt;
&lt;p&gt;我们改变一下设定的参数，将 data 设定的参数改为 ((&#39;苹果&#39;, &#39;香蕉&#39;), (&#39;葡萄&#39;, &#39;石榴&#39;))，再进行测试，如下所示&lt;/p&gt;
&lt;p&gt;4.py&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;#coding=utf-8
import unittest
from ddt import ddt
from ddt import data

# 类之前定义装饰器，表示在类中要使用ddt了
@ddt
class MyTestCase(unittest.TestCase):
    def setUp(self):
        print(&#39;\n{:=^20}&#39;.format(&amp;quot;测试开始&amp;quot;))
    def tearDown(self):
        print(&amp;quot;{:=^20}&amp;quot;.format(&#39;测试结束&#39;))

    # data 用于设定参数，将包 (&#39;苹果&#39;, &#39;香蕉&#39;) 作为一个整体赋值给 txt
    @data((&#39;苹果&#39;, &#39;香蕉&#39;), (&#39;葡萄&#39;, &#39;石榴&#39;))
    def test_1(self, txt):
        print(txt)

if __name__ == &#39;__main__&#39;:
    unittest.main(verbosity=2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行结果如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;test_1_1___苹果____香蕉__ (__main__.MyTestCase) ... 
========测试开始========
(&#39;苹果&#39;, &#39;香蕉&#39;)
========测试结束========
ok
test_1_2___葡萄____石榴__ (__main__.MyTestCase) ... 
========测试开始========
(&#39;葡萄&#39;, &#39;石榴&#39;)
========测试结束========
ok
----------------------------------------------------------------------
Ran 2 tests in 0.001s
OK
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，传入参数 ((&#39;苹果&#39;, &#39;香蕉&#39;), (&#39;葡萄&#39;, &#39;石榴&#39;)) 时，将包 (&#39;苹果&#39;, &#39;香蕉&#39;) 和 (&#39;葡萄&#39;, &#39;石榴&#39;) 作为一个整体，传递给测试用例了，如果我们希望将包里面的数据解开，传递给测试用例不同的参数，就需要用到 unpack 进行解包。&lt;/p&gt;
&lt;p&gt;加入解包后的代码如下所示：&lt;/p&gt;
&lt;p&gt;5.py&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;#coding=utf-8
import unittest
from ddt import ddt
from ddt import data
from ddt import unpack # 导入unpack

# 类之前定义装饰器，表示在类中要使用ddt了
@ddt
class MyTestCase(unittest.TestCase):
    def setUp(self):
        print(&#39;\n{:=^20}&#39;.format(&amp;quot;测试开始&amp;quot;))
    def tearDown(self):
        print(&amp;quot;{:=^20}&amp;quot;.format(&#39;测试结束&#39;))
    @data((&#39;苹果&#39;, &#39;香蕉&#39;), (&#39;葡萄&#39;, &#39;石榴&#39;))
    # 解包，将 (&#39;苹果&#39;, &#39;香蕉&#39;) 解包，&#39;苹果&#39; 赋值给 txt1，&#39;香蕉&#39;赋值给 txt2
    @unpack
    def test_3(self, txt1, txt2):
        print(txt1)
        print(txt2)
if __name__ == &#39;__main__&#39;:
    unittest.main(verbosity=2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行结果如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;test_3_1___苹果____香蕉__ (__main__.MyTestCase) ... 
========测试开始========
苹果
香蕉
========测试结束========
ok
test_3_2___葡萄____石榴__ (__main__.MyTestCase) ... 
========测试开始========
葡萄
石榴
========测试结束========
ok
----------------------------------------------------------------------
Ran 2 tests in 0.002s
OK
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的例子中，我们将输入的参数直接固定了，其实也可以通过文件读取，读取结果决定&lt;/p&gt;
&lt;p&gt;6.py&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;#coding=utf-8
import unittest
from ddt import ddt
from ddt import data
from ddt import unpack

def readFile():
    params = []
    file = open(&#39;6.ddt.txt&#39;, &#39;r&#39;, encoding = &#39;utf-8&#39;)
    for line in file.readlines():
        params.append(line.strip(&#39;\n&#39;).split(&#39;,&#39;))
return params

# 类之前定义装饰器，表示在类中要使用ddt了
@ddt
class MyTestCase(unittest.TestCase):
    def setUp(self) -&amp;gt; None:
        print(&#39;{:=^20}&#39;.format(&amp;quot;测试开始&amp;quot;))
    def tearDown(self) -&amp;gt; None:
        print(&amp;quot;{:=^20}&amp;quot;.format(&#39;测试结束&#39;))

    # 从文件中读取
    @data(*readFile())
    @unpack
    def test_1(self, txt1, txt2):
        print(txt1)
        print(txt2)

if __name__ == &#39;__main__&#39;:
    unittest.main(verbosity=2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;6.ddt.txt 文件中的内如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;苹果,香蕉
葡萄,石榴
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;函数 readFile 从文件中读取数据，unpack 进行解包&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;test_1_1___苹果____香蕉__ (__main__.MyTestCase) ... 
========测试开始========
苹果
香蕉
========测试结束========
ok
test_1_2___葡萄____石榴__ (__main__.MyTestCase) ... 
========测试开始========
葡萄
石榴
========测试结束========
ok
----------------------------------------------------------------------
Ran 2 tests in 0.003s
OK
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;22-ddt&#34;&gt;2.2 ddt 数据驱动&lt;/h4&gt;
&lt;p&gt;打开浏览器进入百度查询的例子中我们发现除了输入的参数不同，test_1(self) 和 test_2(self) 完全相同，这里我们就要通过 data 设定参数实现在一个测试用例中输入不同的参数&lt;/p&gt;
&lt;p&gt;7.py&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;#coding=utf-8
import unittest
from selenium import webdriver
import time
from ddt import ddt
from ddt import data

# 在 class 前定义 @ddt，用于表示要使用 ddt 了
@ddt
class forTestTest(unittest.TestCase):
    def setUp(self):
        self.driver = webdriver.Chrome()
        self.driver.get(&#39;http://www.baidu.com&#39;)
    def tearDown(self):
        time.sleep(3)
        self.driver.quit()

    # data 用于设定参数
    @data(&#39;苹果&#39;, &#39;香蕉&#39;, &#39;石榴&#39;)
    def test_1(self, txt):
        self.driver.find_element_by_id(&#39;kw&#39;).send_keys(txt)
        self.driver.find_element_by_id(&#39;su&#39;).click()

if __name__ == &amp;quot;__main__&amp;quot;:
    unittest.main(verbosity=2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行结果，谷歌浏览器被打开三次，进入百度，分别输入 &#39;苹果&#39;，&#39;香蕉&#39;，&#39;石榴&#39;，每次浏览器关闭之后，才打开下一次，再进行搜索&lt;/p&gt;
&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;test_1_1_苹果 (__main__.forTestTest) ... 
ok
test_1_2_香蕉 (__main__.forTestTest) ... 
ok
test_1_3_石榴 (__main__.forTestTest) ... 
ok
----------------------------------------------------------------------
Ran 3 tests in 33.639s
OK
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的例子中，我们将输入的参数直接固定了，其实也可以通过文件读取，决定进入哪一个url 和输入的参数&lt;/p&gt;
&lt;p&gt;8.py&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;#coding=utf-8
import unittest
from selenium import webdriver
import time
from ddt import ddt
from ddt import data
from ddt import unpack

def readFile():
    params = []
    file = open(&#39;8.ddt.txt&#39;, &#39;r&#39;, encoding = &#39;utf-8&#39;)
    for line in file.readlines():
        params.append(line.strip(&#39;\n&#39;).split(&#39;,&#39;))
    return params

@ddt
class forTestTest(unittest.TestCase):
    def setUp(self):
        self.driver = webdriver.Chrome()
    def tearDown(self):
        time.sleep(3)
        self.driver.quit()

    # data 用于设定参数，表示参数由 readFile() 函数的返回值决定
    # unpack 用于解析参数，例如将[&#39;http://www.baidu.com&#39;, &#39;苹果&#39;] 分别 赋值给 url 和 txt
    @data(*readFile())
    @unpack
    def test_1(self, url, txt):
        self.driver.get(url)
        self.driver.find_element_by_id(&#39;kw&#39;).send_keys(txt)
        self.driver.find_element_by_id(&#39;su&#39;).click()

if __name__ == &amp;quot;__main__&amp;quot;:
    unittest.main(verbosity=2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;8.ddt.txt 文件中的内容如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;http://www.baidu.com,苹果
http://www.baidu.com,香蕉
http://www.baidu.com,石榴
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;分析：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;readFile() 函数打开文件，读取文件的每一行，按逗号 ‘,&#39; 划分关键字，&lt;/li&gt;
&lt;li&gt;unpack 用于解析参数，ddt 对于数据的解析方式为，解析一个，传参一个，所以函数中 url 和 txt 的参数顺序不能调换。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;运行结果，谷歌浏览器被打开两次，进入百度，分别输入 &#39;苹果&#39;, &#39;香蕉&#39;, &#39;石榴&#39;，每次浏览器关闭之后，才打开下一次，再进行搜索&lt;/p&gt;
&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;test_1_1___http___www_baidu_com____苹果__ (__main__.forTestTest) ... 
ok
test_1_2___http___www_baidu_com____香蕉__ (__main__.forTestTest) ... 
ok
test_1_3___http___www_baidu_com____石榴__ (__main__.forTestTest) ... 
ok
----------------------------------------------------------------------
Ran 3 tests in 42.588s
OK
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;3-unittest&#34;&gt;3 unittest 断言用法&lt;/h3&gt;
&lt;p&gt;在 unittest中，TestCase 已经提供有封装好的断言方法进行断言校验。&lt;/p&gt;
&lt;p&gt;断言：用于校验实际结果与预期结果是否匹型，在断言的内容选择上，是有要求的。&lt;/p&gt;
&lt;p&gt;断言强调的是对于整个测试流程的结果进行判断，所以断言的内容是极为核心的。&lt;/p&gt;
&lt;p&gt;上面的代码&lt;/p&gt;
&lt;p&gt;9.py&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;#coding=utf-8
import unittest
from ddt import ddt
from ddt import data
from ddt import unpack

def readFile():
    params = []
    file = open(&#39;9.ddt.txt&#39;, &#39;r&#39;, encoding = &#39;utf-8&#39;)
    for line in file.readlines():
        params.append(line.strip(&#39;\n&#39;).split(&#39;,&#39;))
return params

# 类之前定义装饰器，表示在类中要使用ddt了
@ddt
class MyTestCase(unittest.TestCase):
    def setUp(self) -&amp;gt; None:
        print(&#39;\n{:=^20}&#39;.format(&amp;quot;测试开始&amp;quot;))
    def tearDown(self) -&amp;gt; None:
        print(&amp;quot;{:=^20}&amp;quot;.format(&#39;测试结束&#39;))

    @data(*readFile())
    @unpack
    def test_yam(self, name, age):
        # 获取参数name
        print(name)
        # 这里做断言，当断言不相等的时候返回 msg
        self.assertEqual(name, &#39;张三&#39;, msg = &#39;NotEqual&#39;)
        # 获取为 text 的 value
        print(age)

if __name__ == &#39;__main__&#39;:
    unittest.main(verbosity=2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;文件内容：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;张三,23
李四,25
王五,27
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;test_yam_1___张三____23__ (__main__.MyTestCase) ... 
========测试开始========
张三
23
========测试结束========
ok
test_yam_2___李四____25__ (__main__.MyTestCase) ... 
========测试开始========
李四
========测试结束========
FAIL
test_yam_3___王五____27__ (__main__.MyTestCase) ...
========测试开始========
王五
========测试结束========
FAIL

======================================================================
FAIL: test_yam_2___李四____25__ (__main__.MyTestCase)
----------------------------------------------------------------------
Traceback (most recent call last):
  File &amp;quot;C:\Program Files\Python38\lib\site-packages\ddt.py&amp;quot;, line 182, in wrapper
    return func(self, *args, **kwargs)
  File &amp;quot;c:/Users/dell/Desktop/test/9.py&amp;quot;, line 28, in test_yam
    self.assertEqual(name, &#39;张三&#39;, msg = &#39;NotEqual&#39;)
AssertionError: &#39;李四&#39; != &#39;张三&#39;
- 李四
+ 张三
 : NotEqual

======================================================================
FAIL: test_yam_3___王五____27__ (__main__.MyTestCase)
----------------------------------------------------------------------
Traceback (most recent call last):
  File &amp;quot;C:\Program Files\Python38\lib\site-packages\ddt.py&amp;quot;, line 182, in wrapper
    return func(self, *args, **kwargs)
  File &amp;quot;c:/Users/dell/Desktop/test/9.py&amp;quot;, line 28, in test_yam
    self.assertEqual(name, &#39;张三&#39;, msg = &#39;NotEqual&#39;)
AssertionError: &#39;王五&#39; != &#39;张三&#39;
- 王五
+ 张三
 : NotEqual

----------------------------------------------------------------------
Ran 3 tests in 0.003s

FAILED (failures=2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到第一个例子执行正确，后面的例子，执行结果和预期不一致，返回 NotEqual，从最终结果看，执行了三条用例，失败两条。&lt;/p&gt;
&lt;p&gt;unittest 框架的 TestCase 类提供以下方法用于测试结果的判断&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align: center;&#34;&gt;方法&lt;/th&gt;
&lt;th style=&#34;text-align: center;&#34;&gt;检查&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;assertEqual(a, b)&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;a ==b&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;assertNotEqual(a, b)&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;a !=b&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;assertTrue(x)&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;bool(x) is True&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;assertFalse(x)&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;Bool(x) is False&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;assertIs(a, b)&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;a is b&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;assertIsNot(a, b)&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;a is not b&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;assertIsNone(x)&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;x is None&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;assertIsNotNone(x)&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;x is not None&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;assertIn(a, b)&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;a in b&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;assertNotIn(a, b)&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;a not in b&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;assertIsInstance(a, b)&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;isinstance(a,b)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;assertNotIsInstance(a, b)&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;not isinstance(a,b)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;4-unittestskip&#34;&gt;4 unittest.skip()用法&lt;/h3&gt;
&lt;p&gt;假设我们有很多测试用例，有些我们需要执行，有些我们不想执行，不想执行的测试用例如何才能不执行呢，这就需要用到 skip。&lt;/p&gt;
&lt;p&gt;Skip用法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在 Case 中，对于不需要运行的用例或者特定条件下不执行的用例，可以应用 skip() 来实现有条件执行，或者绝对性跳过，用于对指定用例进行不执行操作&lt;/li&gt;
&lt;li&gt;skip通过装饰器进行使用&lt;/li&gt;
&lt;li&gt;还是通过案例进行讲解，下面有 6 个测试用例，2-5测试用例被屏蔽了，使用的方法不同，&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@unittest.skip(“xxx”)&lt;/code&gt;是无条件跳过，xxx为跳过的理由&lt;/li&gt;
&lt;li&gt;&lt;code&gt;unittest.skipIf(1 &amp;lt; 2, ‘xxx&#39;)&lt;/code&gt;，条件为 True 时跳过&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@unittest.skipUnless(1 &amp;gt; 2, ‘xxx&#39;)&lt;/code&gt;，条件为 False 时跳过，和 skipIf 更好相反&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@unittest.expectedFailure&lt;/code&gt;，如果用例执行失败，则不计入失败的case数中&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;直接看例子更加直观&lt;/p&gt;
&lt;p&gt;10.py&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;#coding=utf-8
import unittest

class MyTestCase(unittest.TestCase):
    def setUp(self):
        pass

    def tearDown(self):
        pass

    def test_1(self):
        print(&#39;1&#39;)

    # 无条件跳过该条用例
    @unittest.skip(&amp;quot;不想运行&amp;quot;)
    def test_2(self):
        print(&#39;2&#39;)

    # 有条件跳过操作，条件为True跳过
    @unittest.skipIf(1 &amp;lt; 2, &#39;1 &amp;lt; 2 为True，条件成立，跳过执行&#39;)
    def test_3(self):
        print(&#39;3&#39;)

    # 有条件执行跳过，条件为False跳过
    @unittest.skipUnless(1 &amp;gt; 2, &#39;Unless的理由，条件为False，跳过执行&#39;)
    def test_4(self):
        print(&#39;4&#39;)

    # 标记该测试预期为失败 ，如果该测试方法运行失败，则该测试不算做失败
    @unittest.expectedFailure
    def test_5(self):
        print(&#39;5&#39;)
        self.assertEqual(4, 3, msg = &#39;Equal&#39;)

    @unittest.expectedFailure
    def test_6(self):
        print(&#39;6&#39;)
        self.assertNotEqual(4, 3, msg = &#39;NotEqual&#39;)

if __name__ == &amp;quot;__main__&amp;quot;:
    unittest.main(verbosity=2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行结果如下，可以看到，test_2，test_3，test_4 跳过，test_5执行失败，但不算做失败&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;test_1 (__main__.MyTestCase) ... 1
ok
test_2 (__main__.MyTestCase) ... skipped &#39;不想运行&#39;
test_3 (__main__.MyTestCase) ... skipped &#39;1 &amp;lt; 2 为True，条件成立，跳过执行&#39;   
test_4 (__main__.MyTestCase) ... skipped &#39;Unless的理由，条件为False，跳过执行&#39;
test_5 (__main__.MyTestCase) ... 5
expected failure
test_6 (__main__.MyTestCase) ... 6
unexpected success
----------------------------------------------------------------------
Ran 6 tests in 0.005s
FAILED (skipped=3, expected failures=1, unexpected successes=1)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;5-unittestrunner&#34;&gt;5 unittest测试套件及runner应用&lt;/h3&gt;
&lt;p&gt;测试套件 suite 作用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用于给测试用例进行排序&lt;/li&gt;
&lt;li&gt;管理测试用例&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过例子讲解最容易理解，看一个最简单的例子，下面的代码中有五个测试用例，程序运行的结果和测试用例在代码中位置是没有关系的，结果永远打印 1 2 3 4 5，这是因为测试用例的执行顺序默认是按照字典顺序执行的，如何才能控制测试用例的执行顺序呢，这就需要使用测试套件了。&lt;/p&gt;
&lt;p&gt;testCase.py&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;import unittest
class MyTestCase(unittest.TestCase):
    def setUp(self):
        pass

    def tearDown(self):
        pass

    def test_2(self):
        print(&amp;quot;2&amp;quot;)

    def test_1(self):
        print(&amp;quot;1&amp;quot;)

    def test_4(self):
        print(&amp;quot;4&amp;quot;)

    def test_3(self):
        print(&amp;quot;3&amp;quot;) 

    def test_5(self):
        print(&amp;quot;5&amp;quot;)

if __name__ == &amp;quot;__main__&amp;quot;:
    unittest.main(verbosity=2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;test_1 (__main__.MyTestCase) ... 1
ok
test_2 (__main__.MyTestCase) ... 2
ok
test_3 (__main__.MyTestCase) ... 3
ok
test_4 (__main__.MyTestCase) ... 4
ok
test_5 (__main__.MyTestCase) ... 5
ok
----------------------------------------------------------------------
Ran 5 tests in 0.002s
OK
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再建一个py 文件11.py&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;#coding=utf-8
import unittest
from testCase import *

# 创建一个测试套件 list
suite = unittest.TestSuite()
# 方法一，添加测试用例（子元素）到测试套件（集合）
suite.addTest(MyTestCase(&#39;test_3&#39;))
suite.addTest(MyTestCase(&amp;quot;test_1&amp;quot;))
suite.addTest(MyTestCase(&amp;quot;test_5&amp;quot;))

runner = unittest.TextTestRunner(verbosity=2)
runner.run(suite)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们首先创建一个测试套件，然后向测试套件中添加测试用例，最后创建 TextTestRunner 对象，调用 run 函数运行测试用例。这样我们不仅可以控制测试用例的执行顺序，还可以控制运行哪个测试用例。&lt;/p&gt;
&lt;p&gt;结果如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;test_3 (testCase.MyTestCase) ... 3
ok
test_1 (testCase.MyTestCase) ... 1
ok
test_5 (testCase.MyTestCase) ... 5
ok
----------------------------------------------------------------------
Ran 3 tests in 0.001s
OK
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的方法每次添加测试用例都需要调用 addTest 函数，能不能一次添加多个测试用例&lt;/p&gt;
&lt;p&gt;12.py&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;#coding=utf-8
import unittest
from testCase import *

# 创建一个测试套件 list
suite = unittest.TestSuite()

# 方法二，批量添加测试用例
cases = [MyTestCase(&#39;test_3&#39;), MyTestCase(&#39;test_1&#39;), MyTestCase(&#39;test_5&#39;)]
suite.addTests(cases)

# 套件通过TextTestRunner对象运行，功能相当于unittest.main(verbosity=2)
runner = unittest.TextTestRunner(verbosity=2)
runner.run(suite)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果测试用例非常多，或者有多个文件中的测试用例都需要测试，这样添加也不是很方便，我们好可以按照文件路径，将该路径下需要测试的文件添加进测试套件中&lt;/p&gt;
&lt;p&gt;13.py&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;#coding=utf-8
import unittest
from testCase import *

# 创建一个测试套件 list
suite = unittest.TestSuite()

# 方法三，批量运行多个unittest类
test_dir = &#39;./&#39;
# start_dir 参数指定文件路径，pattern 执行规则，&#39;s*.py&#39; 表示以 &amp;quot;s&amp;quot; 开头，&amp;quot;.py&amp;quot; 的都加入测试套件中
discover = unittest.defaultTestLoader.discover(start_dir = test_dir, pattern = &#39;t*.py&#39;)

runner = unittest.TextTestRunner(verbosity=2)
runner.run(discover) # 通过 run 函数运行测试用例
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还可以执行类的名字，执行该类下面所有的测试用例，使用 loadTestsFromName 函数或者 loadTestsFromTestCase 都可以，案例如下：&lt;/p&gt;
&lt;p&gt;14.py&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;#coding=utf-8
import unittest
from testCase import *

# 创建一个测试套件 list
suite = unittest.TestSuite()

# 方法四，给出文件名和类名，就能测试所有的测试用例
suite.addTests(unittest.TestLoader().loadTestsFromName(&#39;testCase.MyTestCase&#39;))

# 套件通过TextTestRunner对象运行，功能相当于unittest.main(verbosity=2)
runner = unittest.TextTestRunner(verbosity=2)
runner.run(suite)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;15.py&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;#coding=utf-8
import unittest
from testCase import *

# 创建一个测试套件 list
suite = unittest.TestSuite()

# 方法五，给出类名，就能测试所有的测试用例
suite.addTests(unittest.TestLoader().loadTestsFromTestCase(MyTestCase))
# 套件通过TextTestRunner对象运行，功能相当于unittest.main(verbosity=2)
runner = unittest.TextTestRunner(verbosity=2)
runner.run(suite)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;6-unittesthtmltestrunner&#34;&gt;6 unittest+HTMLTestRunner 自动化实现&lt;/h3&gt;
&lt;p&gt;通过 HTMLTestRunner 我们可以将测试结果生成 html 文件，通过网页端进行查看。步骤如下：&lt;/p&gt;
&lt;h4 id=&#34;61&#34;&gt;6.1 导入环境&lt;/h4&gt;
&lt;p&gt;下载 &lt;code&gt;HTMLTestRunner.py&lt;/code&gt; 文件，下载地址：&lt;a href=&#34;http://tungwaiyip.info/software/HTMLTestRunner_0_8_2/HTMLTestRunner.py&#34;&gt;http://tungwaiyip.info/software/HTMLTestRunner_0_8_2/HTMLTestRunner.py&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下载后，把&lt;code&gt;HTMLTestRunner.py&lt;/code&gt; 文件复制到 Python 安装路径下的 lib 文件夹中。在python3中用&lt;code&gt;HTMLTestRunner.py&lt;/code&gt;会报错，原因是&lt;code&gt;HTMLTestRunner&lt;/code&gt;仅支持python2，不支持python3，需要做小小的改动。&lt;/p&gt;
&lt;p&gt;修改内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第94行，将&lt;code&gt;import StringIO&lt;/code&gt;修改成&lt;code&gt;import io&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;第539行，将&lt;code&gt;self.outputBuffer = StringIO.StringIO()&lt;/code&gt;修改成&lt;code&gt;self.outputBuffer = io.StringIO()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;第642行，将&lt;code&gt;if not rmap.has_key(cls)&lt;/code&gt;:修改成&lt;code&gt;if not cls in rmap:&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;注释掉763行、766行、767行，768行前提4格；注释掉769行、772行、773行，774行前提4格；&lt;/li&gt;
&lt;li&gt;第631行，将&lt;code&gt;print &amp;gt;&amp;gt; sys.stderr, ‘\nTime Elapsed: %s&#39; % (self.stopTime-self.startTime)&lt;/code&gt;修改成&lt;code&gt;print(sys.stderr, &#39;\nTime Elapsed: %s&#39; % (self.stopTime-self.startTime))&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;62&#34;&gt;6.2 导包&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;from HTMLTestRunner import HTMLTestRunner&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;下面就通过案例进行演示&lt;/p&gt;
&lt;p&gt;testCase.py 文件&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;import unittest
class MyTestCase(unittest.TestCase):
    def setUp(self) -&amp;gt; None:
        pass

    def tearDown(self) -&amp;gt; None:
        pass

    def test_2(self):
        print(&amp;quot;2&amp;quot;)

    def test_1(self):
        print(&amp;quot;1&amp;quot;)

    def test_4(self):
        print(&amp;quot;4&amp;quot;)

    def test_3(self):
        print(&amp;quot;3&amp;quot;)

    def test_5(self):
        print(&amp;quot;5&amp;quot;)

if __name__ == &amp;quot;__main__&amp;quot;:
    unittest.main(verbosity=2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;16.py&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;#coding=utf-8
import unittest
from suite_case import MyTestCase
from HTMLTestRunner import HTMLTestRunner
import os

suite = unittest.TestSuite()

report_path = &#39;./report/&#39;
report_file = report_path + &#39;report.html&#39;
# 路径不存在就创建一个文件夹
if not os.path.exists(report_path):
    os.mkdir(report_path)
else:
pass

report_name = &#39;测试报告名称&#39;
report_title = &#39;测试报告标题&#39;
report_desc = &#39;测试报告描述&#39;

with open(report_file, &#39;wb&#39;) as report:
    suite.addTests(unittest.TestLoader().loadTestsFromTestCase(MyTestCase))
    # 套件结合 TextTestRunner 对象进行运行，相当于 unittest.mian()
    # 如果结合 HTMLTestRunner 使用，则需要调用 HTMLTestRunner 中的运行器
    runner = HTMLTestRunner(stream = report, title = report_title, description = report_desc)
    runner.run(suite)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行 就会成成 report.html 文件，浏览器打开该文件，如下所示：&lt;/p&gt;
&lt;p&gt;测试报告标题&lt;/p&gt;
&lt;p&gt;start Time: 2020-11-15 20:35:50&lt;/p&gt;
&lt;p&gt;Duration: 0:00:01&lt;/p&gt;
&lt;p&gt;Status: Pass 5&lt;/p&gt;
&lt;p&gt;测试报告描述&lt;/p&gt;
&lt;p&gt;Show &lt;a href=&#34;&#34;&gt;Summary&lt;/a&gt; &lt;a href=&#34;&#34;&gt;Failed&lt;/a&gt; &lt;a href=&#34;&#34;&gt;All&lt;/a&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align: center;&#34;&gt;Test Group/Test Case&lt;/th&gt;
&lt;th style=&#34;text-align: center;&#34;&gt;Count&lt;/th&gt;
&lt;th style=&#34;text-align: center;&#34;&gt;Pass&lt;/th&gt;
&lt;th style=&#34;text-align: center;&#34;&gt;Fail&lt;/th&gt;
&lt;th style=&#34;text-align: center;&#34;&gt;Error&lt;/th&gt;
&lt;th style=&#34;text-align: center;&#34;&gt;View&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;testCase.MyTestCase&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;5&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;5&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;0&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;0&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;&lt;a href=&#34;&#34;&gt;Detail&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;Total&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;5&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;5&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;0&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;0&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;这样就生成一个比较直观的测试报告&lt;/p&gt;
&lt;h3 id=&#34;7&#34;&gt;7.总结&lt;/h3&gt;
&lt;p&gt;到此关于Python自动化之unittest框架的介绍就完了。&lt;/p&gt;</description>  
      <pubDate>2025-10-09 17:54:40</pubDate>  
      <link>https://testpoo.github.io/Python自动化之unittest.html</link>  
      <guid isPermaLink="true">https://testpoo.github.io/Python自动化之unittest.html</guid>
       
      <category>测试</category> 
      
    </item>
    
    <item> 
      <title>mysql的安装</title>  
      <description>&lt;div class=&#34;toc&#34;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#mysql&#34;&gt;Mysql的安装&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#mysql_1&#34;&gt;下载mysql安装包&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#mariadb&#34;&gt;删除mariadb&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_1&#34;&gt;安装离线包&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#mysql_2&#34;&gt;创建mysql用户和组&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#mysql_3&#34;&gt;Mysql配置&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_2&#34;&gt;服务启停&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_3&#34;&gt;数据库操作&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h3 id=&#34;mysql&#34;&gt;Mysql的安装&lt;/h3&gt;
&lt;p&gt;以centos离线安装为例&lt;/p&gt;
&lt;h3 id=&#34;mysql_1&#34;&gt;下载mysql安装包&lt;/h3&gt;
&lt;p&gt;从Mysql官方网站内下载 &lt;a href=&#34;https://dev.mysql.com/downloads/mysql/&#34;&gt;https://dev.mysql.com/downloads/mysql/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;选择以下版本进行安装&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;Red Hat Enterprice Linux / Oracle Linux
Red Hat Enterprice Linux 8 / Oracle Linux 8 (x86,64-bit)

下载包信息：mysql-8.0.20-1.el8.x86_64.rpm-bundle.tar|8.0.20|650.2M    
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;mariadb&#34;&gt;删除mariadb&lt;/h3&gt;
&lt;p&gt;查看系统中是否存的mariadb，如果存在，将其删除，即可以如下操作：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;rpm -qa | grep mariadb
# 如果有返回信息，说明存在mariadb，如下：
mariadb-libs-5.5.56-2.el7.x86_64
# 删除命令为：
rpm -e --nodeps mariadb-libs-5.5.56-2.el7.x86_64
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;_1&#34;&gt;安装离线包&lt;/h3&gt;
&lt;p&gt;解压缩mysql离线安装包&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;cd /home/test
tar -xvf mysql-8.0.20-1.el8.x86_64.rpm-bundle.tar
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;解压缩之后，包含以下rpm包&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;mysql-community-libs-8.0.20-1.el8.x86_64.rpm
mysql-community-embedded-compat-8.0.20-1.el8.x86_64.rpm
mysql-community-devel-8.0.20-1.el8.x86_64.rpm
mysql-community-server-8.0.20-1.el8.x86_64.rpm
mysql-community-libs-compat-8.0.20-1.el8.x86_64.rpm
mysql-community-client-8.0.20-1.el8.x86_64.rpm
mysql-community-common-8.0.20-1.el8.x86_64.rpm
mysql-community-test-8.0.20-1.el8.x86_64.rpm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装rmp包，逐个安装，命令如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;# 必须安装
rpm -ivh mysql-community-common-8.0.20-1.el8.x86_64.rpm
rpm -ivh mysql-community-libs-8.0.20-1.el8.x86_64.rpm
rpm -ivh mysql-community-client-8.0.20-1.el8.x86_64.rpm
rpm -ivh mysql-community-server-8.0.20-1.el8.x86_64.rpm
# 非必须安装
rpm -ivh mysql-community-libs-compat-8.0.20-1.el8.x86_64.rpm
rpm -ivh mysql-community-embedded-compat-8.0.20-1.el8.x86_64.rpm
rpm -ivh mysql-community-devel-8.0.20-1.el8.x86_64.rpm
rpm -ivh mysql-community-test-8.0.20-1.el8.x86_64.rpm

注意：如果有依赖缺失的问题，请按照错误提示，自行安装缺失的依赖
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;mysql_2&#34;&gt;创建mysql用户和组&lt;/h3&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;groupadd mysql
useradd -g mysql mysql

# 设置用户的密码
passwd mysql
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;mysql_3&#34;&gt;Mysql配置&lt;/h3&gt;
&lt;p&gt;新建my.cnf文件&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;touch /etc/my.cnf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;配置文件内容&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;[mysqld]
########basic settings########
federated
user=mysql
datadir = /data/mysql
transaction_isolation = READ-COMMITTED
explicit_defaults_for_timestamp = 1
#bind-address = 0.0.0.0  # 表示允许任何主机登陆MySQL
port = 3306
socket = /tmp/mysql.sock
federated
########log settings##########
log-bin=mysql-bin
expire_logs_days = 5
log-error = /data/mysql_log/error.log
long_query_time = 10
slow_query_log = 1
slow_query_log_file = /data/mysql_log/slowquery.log
log_throttle_queries_not_using_indexes = 10
binlog_format=ROW
########innodb settings########
#索引和数据缓冲区大小，一般设置物理内存的60%-70%
innodb_buffer_pool_size=6G
innodb_buffer_pool_instances = 8
innodb_buffer_pool_load_at_startup = 1
innodb_buffer_pool_dump_at_shutdown = 1
#innodb_page_size = 8192
innodb_lock_wait_timeout = 50
innodb_file_format = Barracuda
innodb_file_format_max = Barracuda
innodb_purge_threads = 4
innodb_large_prefix = 1
innodb_print_all_deadlocks = 1
innodb_strict_mode = 1
innodb_sort_buffer_size = 32M
#默认值为 48M. 有很高写入吞吐量
innodb_log_file_size=1G
#InnoDB 存储引擎的事务日志所使用的缓冲区
innodb_log_buffer_size = 16M
innodb_flush_log_at_trx_commit=2
#修改InnoDB为独立表空间模式,每个数据库的每个表都会生成一个数据空间
innodb_file_per_table=1
#限制Innodb能打开的表的数据
#innodb_file_io_threads=4
#5.6以后分为读和写，根据事务特性进行修改，原则为总数加起来&amp;lt;=cpu个数*每个cpu核数
innodb_read_io_threads=4
innodb_write_io_threads=4
#如果使用硬件RAID磁盘控制器, 需要设置为 O_DIRECT
#innodb_flush_method=O_DIRECT
#设置会影响InnoDB每秒在后台执行多少操作
innodb_io_capacity=800
[mysqld]
########basic settings########
federated
user=mysql
datadir = /data/mysql
transaction_isolation = READ-COMMITTED
explicit_defaults_for_timestamp = 1
#bind-address = 0.0.0.0  # 表示允许任何主机登陆MySQL
port = 3306
socket = /tmp/mysql.sock
federated
########log settings##########
log-bin=mysql-bin
expire_logs_days = 5
log-error = /data/mysql_log/error.log
long_query_time = 10
slow_query_log = 1
slow_query_log_file = /data/mysql_log/slowquery.log
log_throttle_queries_not_using_indexes = 10
binlog_format=ROW
########innodb settings########
#索引和数据缓冲区大小，一般设置物理内存的60%-70%
innodb_buffer_pool_size=6G
innodb_buffer_pool_instances = 8
innodb_buffer_pool_load_at_startup = 1
innodb_buffer_pool_dump_at_shutdown = 1
#innodb_page_size = 8192
innodb_lock_wait_timeout = 50
innodb_file_format = Barracuda
innodb_file_format_max = Barracuda
innodb_purge_threads = 4
innodb_large_prefix = 1
innodb_print_all_deadlocks = 1
innodb_strict_mode = 1
innodb_sort_buffer_size = 32M
#默认值为 48M. 有很高写入吞吐量
innodb_log_file_size=1G
#InnoDB 存储引擎的事务日志所使用的缓冲区
innodb_log_buffer_size = 16M
#关键参数，0代表大约每秒写入到日志并同步到磁盘，数据库故障会丢失1秒左右事务数据。1为每执行一条SQL后写入到日志并同步到磁盘，I/O开销大，执行完SQL要等待日志读写，效率低。2代表只把日志写入到系统缓存区，再每秒同步到磁盘，效率很高，如果服&amp;gt;务器故障，才会丢失事务数据。对数据安全性要求不是很高的推荐设置2，性能高，修改后效果明显。
innodb_flush_log_at_trx_commit=2
#修改InnoDB为独立表空间模式,每个数据库的每个表都会生成一个数据空间
innodb_file_per_table=1
#限制Innodb能打开的表的数据
#innodb_file_io_threads=4
#5.6以后分为读和写，根据事务特性进行修改，原则为总数加起来&amp;lt;=cpu个数*每个cpu核数
innodb_read_io_threads=4
innodb_write_io_threads=4
#如果使用硬件RAID磁盘控制器, 需要设置为 O_DIRECT
#innodb_flush_method=O_DIRECT
#设置会影响InnoDB每秒在后台执行多少操作
innodb_io_capacity=800
innodb_io_capacity_max=1000
#这个参数必须要和innodb_io_capacity设置一样
innodb_lru_scan_depth=800
#限制了一次有多少线程能进入内核,0表示不限制进入内核的数量
innodb_thread_concurrency = 32
#除了缓存表数据和索引外,可以为操作所需的其他内部项分配缓存来提升InnoDB的性能,这些内存就可以通过此参数来分配
innodb_additional_mem_pool_size=8M
#修改为基于行的复制
innodb_autoinc_lock_mode = 2

secure_file_priv=&amp;quot;&amp;quot;
##############cache#############
max_allowed_packet = 2048M
#内部内存临时表的最大值
tmp_table_size=128M
tmpdir = /data/mysql/mysql_tmp
collation_server=utf8_general_ci
character_set_server=utf8
#即跳过外部锁定
skip-external-locking
skip-name-resolve
#MySQL能暂存的连接数量(根据实际设置)
back_log=1024
#指定索引缓冲区的大小,只对MyISAM表起作用,这里写上也没有关系
key_buffer_size=128M
#这条指令限定用于每个数据库线程的栈大小
thread_stack=256k
#当一个查询不断地扫描某一个表,MySQL会为它分配一段内存缓冲区
read_buffer_size=128M
#线程缓存
thread_cache_size=16
#查询缓存大小
query_cache_size=128M
#内部内存临时表的最大值,每个线程都要分配
max_heap_table_size=128M
#将查询结果放入查询缓存中
query_cache_limit = 3M
query_cache_min_res_unit = 2k
bulk_insert_buffer_size = 64M
query_cache_type=1
#代表在事务过程中容纳二进制日志SQL语句的缓存大小
binlog_cache_size = 2M
#同样是缓存表大小
table_open_cache=128
#缓存线程
#thread_cache=16000
#推荐设置为服务器 CPU核数的2倍
thread_concurrency=16
interactive_timeout=28800
wait_timeout=28800
#表和表联接的缓冲区的大小
join_buffer_size = 32M
#是一个connection级参数,在每个connection第一次需要使用这个buffer的时候,一次性分配设置的内存
sort_buffer_size = 32M
#随机读取数据缓冲区使用内存
read_rnd_buffer_size = 32M
group_concat_max_len = 102400 #你要的最大长度
##################################################
#connect 是一个MySQL中与安全有关的计数器值,它负责阻止过多尝试失败的客户端以防止暴力破解密码
max-connect-errors=1000
#连接数
max-connections=1000
##################################################
#开启查询缓存
explicit_defaults_for_timestamp=true
###################################################
[client]
socket=/tmp/mysql.sock
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;_2&#34;&gt;服务启停&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;查看服务状态&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;systemctl status mysqld
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;停止服务&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;service mysqld stop
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;初始化数据库&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;mysqld --initialize --console
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;目录授权&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;chown -R mysql:mysql /var/lib/mysql/
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;启动mysql服务&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;systemctl start mysqld
systemctl status mysqld
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;_3&#34;&gt;数据库操作&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;查看临时密码：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;grep &#39;password&#39; /var/log/mysqld.log |head -n 1
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;用临时密码登录数据库&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;mysql -u root -p 回车键
然后输入临时密码（输入时不会显示出来，输入完直接回车）
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;修改mysql密码&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;alter USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;123456&#39;;
&lt;/code&gt;&lt;/pre&gt;</description>  
      <pubDate>2025-10-09 17:54:40</pubDate>  
      <link>https://testpoo.github.io/mysql的安装.html</link>  
      <guid isPermaLink="true">https://testpoo.github.io/mysql的安装.html</guid>
       
      <category>技术</category> 
      
    </item>
    
    <item> 
      <title>紫薇斗数解析</title>  
      <description>&lt;div class=&#34;toc&#34;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1&#34;&gt;1. 概述&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#11&#34;&gt;1.1 基础解析&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2&#34;&gt;2. 命宫&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#21&#34;&gt;2.1 基本解析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#22&#34;&gt;2.2 星系解析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#23&#34;&gt;2.3 星曜解析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#24&#34;&gt;2.4 身宫解析&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3&#34;&gt;3. 兄弟&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#31&#34;&gt;3.1 星曜解析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#32&#34;&gt;3.2 四化解析&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4&#34;&gt;4. 夫妻&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#41&#34;&gt;4.1 基本解析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#42&#34;&gt;4.2 星曜解析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#43&#34;&gt;4.3 四化解析&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5&#34;&gt;5. 子女&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#51&#34;&gt;5.1 星曜解析&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#6&#34;&gt;6. 财帛&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#61&#34;&gt;6.1 星曜解析&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#7&#34;&gt;7. 疾厄&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#71&#34;&gt;7.1 基本解析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#72&#34;&gt;7.2 星曜解析&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#8&#34;&gt;8. 迁移&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#81&#34;&gt;8.1 星曜解析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#82&#34;&gt;8.2 四化解析&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#9&#34;&gt;9. 奴仆&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#91&#34;&gt;9.1 星曜解析&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#10&#34;&gt;10. 官禄&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#101&#34;&gt;10.1 基本解析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#102&#34;&gt;10.2 星曜解析&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#11_1&#34;&gt;11. 田宅&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#111&#34;&gt;11.1 星曜解析&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#12&#34;&gt;12. 福德&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#121&#34;&gt;12.1 基本解析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#122&#34;&gt;12.2 星曜解析&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#13&#34;&gt;13. 父母&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#131&#34;&gt;13.1 星曜解析&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h3 id=&#34;1&#34;&gt;1. 概述&lt;/h3&gt;
&lt;h4 id=&#34;11&#34;&gt;1.1 基础解析&lt;/h4&gt;
&lt;p&gt;你的命宫是空宫，借迁移宫的天同、太阴安星。你的人缘较好，而且你在外地发展不错，能适应外地的生活，在外地过的比较开心。&lt;/p&gt;
&lt;p&gt;你内心敏感，比较聪明，能够察觉到对方心里的所思所想，也比较重感情，容易动感情，容易早恋，但在感情上会有失败。&lt;/p&gt;
&lt;p&gt;女命的婚姻不太好，至少也是过程不顺，会受一些波折。配偶需找年龄较大的男人为好。&lt;/p&gt;
&lt;p&gt;男命的异性缘很好，也比较重感情，有些好色风流，但个人能力也不错。&lt;/p&gt;
&lt;h3 id=&#34;2&#34;&gt;2. 命宫&lt;/h3&gt;
&lt;h4 id=&#34;21&#34;&gt;2.1 基本解析&lt;/h4&gt;
&lt;p&gt;你的命宫没有正曜，需要借迁移宫【天同星、太阴星】来安星。受到天同、太阴的影响，你的个性有以下特质：温柔、沉静、谦虚、善良、浪漫、好奇心强、喜欢玩乐、感情丰富、有同情心、有赤子之心、喜欢交朋友、具有服务的热忱、爱好悠闲的生活。&lt;/p&gt;
&lt;p&gt;这类命局，大都长的比较好看，至少也是五官端正。&lt;/p&gt;
&lt;p&gt;你整体的格局是属于文多于武的格局，这会让你对文学和艺术感兴趣，并且有自己独特的眼光。不过，你容易听信他人随波逐流，这部分需要透过后天的加强，去弥补不足。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;建议&lt;/strong&gt;：从命盘的整体格局来看，你兴趣广泛，卻缺乏专精，自信心和承担大任的能力也比较不足，常空有计划及理想，而没有确切的执行力，因而错过好时机。你需要培养积极主动的态度，建立自己的专业，才能在竞争激烈的时代里掌握先机。&lt;/p&gt;
&lt;p&gt;另外，你的个性善良，不懂得拒绝别人，会容易上当受骗、吃闷亏，这方面也多注意才行。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;优点：感情丰富、心地善良、有亲和力。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;缺点：情绪化，抗压力不足，缺乏冲力，容易在感情上患得患失。也有点清高，不太在意实际利益，会在金钱方面吃亏。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;你是个外表稳重、动作慢，内心却蛮急躁、沉不住气的人，相当感性、多才多艺，心地善良仁慈，比较没有主见，很容易在感情上拿不定主意，依赖心很重，异性缘也蛮好的，是能够跟异性愉快而自在的相处。&lt;/p&gt;
&lt;p&gt;你的个性温和善良，长相也温文儒雅，很具有亲和力，所以在外面的人缘很不错，你看起来还蛮爱干净的，不过多半只是独善其身，基本上，你是不太爱劳动筋骨的，所以也不算是很勤劳，会积极打拼的人。你喜欢闲适的生活，缺乏冲力，定力也不足，常有机会成为骑墙派，因为你既拿不定主意，又不愿得罪人，虽然你通常都给人脾气很好的印象，其实你还蛮情绪化，而且还有些“斤斤计较、不够爽快”呢！&lt;/p&gt;
&lt;p&gt;具有追求安逸，免于劳累，量力而为，居安思危，储存财物，购置房产与世无争的企图心。你也有辅佐他人的才能，会给别人出主意，是一个很好的人，愿意为朋友付出。你的意志容易受环境影响，感情丰富，有较好的相貌，也通情达理，幽默风趣，有才艺懂得上进，男女之间人缘都非常好，而且心思细腻，温柔多情，也乐于服务。一生中要在性格上注意：积极与消极之间的平衡关系。&lt;/p&gt;
&lt;p&gt;喜欢安定的过日子，激进冒险的行为是只能想想不可当真的，很能墨守成规，可接受单调且变化少的事务性工性，与人相处时多能表现出和善的态度，会是别人眼中的好好先生或好好小姐，在家庭生活中、或小的生活团体里，则会有着为别人撑起一把保护伞的奉献心，只要是能力所及，会对亲友伸出援手。规划能力相当强，能掌握大原则，也能看到小细节，工作能力强懂得向下发展人脉组织，向上管理顶头上司，尤其是遇到没什么能力的上司时，很容易出头。&lt;/p&gt;
&lt;p&gt;具有有利人利己，和平共存，群策群力共图大业之企图心。减少孤性，降低劳心费力程度，减少孤军奋战的情况，有亲和性与接纳性，处世人际关系较为圆融，能够体现因助人而得到别人帮助的现象，也具有好帮好，坏帮坏的性质。&lt;/p&gt;
&lt;p&gt;具有坚持己见，不畏艰辛，奋斗到底，有始有终坚持到底的企图心。有韧性，钻牛角尖，一旦被盯上的事情，能够与其周旋到底，中途决不放弃。犹如一把刀在手，善恶全凭使用者的心态。不屈不挠的精神，适合从事具有耐心毅力、技术科技性的事物。容易与人摩擦冲突，如何适度的约束为成功之道。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果太阴落陷，无论男女，婚姻感情都不顺利。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果太阴入庙，婚姻感情上的挫折会少一些，但仍然有波折。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果太阴入庙，男命通常适合到外地打拼。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;22&#34;&gt;2.2 星系解析&lt;/h4&gt;
&lt;p&gt;你的命宫是空宫，借迁移宫的天同、太阴安星。你的人缘较好，而且你在外地发展不错，能适应外地的生活，在外地过的比较开心。&lt;/p&gt;
&lt;p&gt;你内心敏感，比较聪明，能够察觉到对方心里的所思所想，也比较重感情，容易动感情，容易早恋，但在感情上会有失败。建议晚一些结婚。&lt;/p&gt;
&lt;p&gt;女命大都相貌美丽，很有女人味，举手投足之间很容易吸引异性，但女命的婚姻不好。配偶需找年龄较大的男人为好。&lt;/p&gt;
&lt;p&gt;稍有一些克父母，建议拜干爹干妈、聚少离多等方式以趋避。&lt;/p&gt;
&lt;p&gt;男命的异性缘很好，也比较重感情，有些好色风流，但个人能力也不错。就是喜欢享乐，上进心不够强，必须时刻敦促自己，在工作上多花时间，这样才有更大的成就。&lt;/p&gt;
&lt;h4 id=&#34;23&#34;&gt;2.3 星曜解析&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;地空(煞)(庙)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;地空在命宫，表示爱好与别人不同，人际关系一般，或者表面跟其他人关系融洽，但实际上还是保持距离的，并不算合群。总体来说有点孤独，与长辈的缘分也比较浅。&lt;/p&gt;
&lt;p&gt;地空在命宫，比较有头脑、有想法，思维模式比较特殊，考虑问题的角度与别人不同。&lt;/p&gt;
&lt;p&gt;地空主要影响精神方面，有时候会因为想法怪、思维特别而乱花钱。也可以因为思想有独创性而发财。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;天厨&lt;/p&gt;
&lt;p&gt;天月&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在命宫，先天身体素质不好，小时候多病，需要注意养生。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;天刑&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;天刑在命宫，本人有一定的自律能力，较为严肃、刻板，应变能力不强，但执行力很不错。&lt;/p&gt;
&lt;p&gt;不宜与煞星、化忌同宫，否则主孤独、心狠手辣、个性凶悍。如果与煞星同宫，一般适合技术、武职性质工作。&lt;/p&gt;
&lt;p&gt;天刑与法律有关系，可以从事执法类工作。&lt;/p&gt;
&lt;p&gt;如果遇到吉星、吉化较多，表示很自律，工作努力，事业成就大，而且理性重于感性。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;大耗&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;24&#34;&gt;2.4 身宫解析&lt;/h4&gt;
&lt;p&gt;你的身宫是天机、天梁，而且是夫妻宫，表示你喜欢聪明、外向、乐观、漂亮、口才好的异性，你希望对方与你有共同话题，能够聊的来，能够帮助你、照顾你、指导你就更好了。你是一个比较重感情的人，对待金钱看的不是很重。&lt;/p&gt;
&lt;p&gt;容易有异地恋，或者一方常出差。&lt;/p&gt;
&lt;p&gt;如果你是女命，建议你找年纪较大的男人；如果你是男命，也可以找个比自己稍大的对象。如果想找更好的女人，那就建议你在事业有成以后再找对象，或者有稳定的经济基础之后再找对象。&lt;/p&gt;
&lt;p&gt;你对外面的世界很感兴趣，适合做动脑筋的职业。此外，从事奔走多、常出差的工作也可以，以及发挥口才的工作大都合适。你较不喜欢千篇一律、枯燥的工作。&lt;/p&gt;
&lt;p&gt;如果身宫的三方四正会照煞星，一般适合搞技术型工作。&lt;/p&gt;
&lt;p&gt;在赚钱这方面，如果你的身宫遇到吉星、吉化，表示你个人能力很强，很会赚钱，生财有道，但通常先难后易，要在结婚以后才有很大进步。&lt;/p&gt;
&lt;p&gt;你很有慧根，也有悟性，还很有灵气，善于动脑、表达能力不错是你的优势。缺点是工作的变动比较多，以及收入、待遇不是很高，而且常常在外地工作，有比较强的奔波、劳碌色彩，在工作上的外出、远行比别人多。跑业务的工作也挺适合你。&lt;/p&gt;
&lt;p&gt;你是一个比较善良的人，而且在年长以后，大都有宗教信仰，以及对神秘事物感兴趣。&lt;/p&gt;
&lt;p&gt;你的缺点是有一些好色，机灵、油滑，意志力不够坚持，做事缺乏韧劲。&lt;/p&gt;
&lt;p&gt;天机是为人出谋划策的星曜，所以天机星在身宫的人，大都适合上班，即使要创业，也最好与人合作，不宜自己单干，也不要自称老大。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;身宫、夫妻宫的天机星，判断方法与命宫稍有差异。除了喜见文昌、文曲、龙池、凤阁、化科、天才这六善曜以外，也喜其他吉星吉化、禄存、化禄、化权等等。如果星曜搭配的好，也是富贵双全的命，而且思想正派，为人厚道，善于分析问题，能给人出谋划策，配偶也对自己有帮助。还可以做公务员。但通常难以大富，只是中富或者小富水平。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;身宫的天机，较不宜与擎羊同宫，或者会照天梁、擎羊、孤辰、寡宿等孤独的星曜，会导致本人婚姻不好，很难结婚，结婚了也易离婚，晚运孤独。但搭配煞星不一定会贫困，这类盘仍然可以有小富或者中富级别的生活，只是孤独、人缘较不好。与亲人的缘分也浅，对父母、对配偶有刑克、矛盾大。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;3&#34;&gt;3. 兄弟&lt;/h3&gt;
&lt;h4 id=&#34;31&#34;&gt;3.1 星曜解析&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;紫微(旺)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;兄弟富贵或近贵，吉星同，可依靠。见左右昌曲魁钺诸吉，兄弟有财富和地位，对自己有助力。见羊陀火铃劫空天刑七杀，有克，感情欠和不同心，兄弟内心孤单，事业有破败。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;有长兄但兄弟各分立，吉星聚，兄弟有显贵，凶星照宫，兄弟防损刑。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;紫微天府，兄弟三、四人。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;紫微破运，兄弟有三人，并有同父异母现象。如父母宫见天府主父母情深。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;七杀(平)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;主孤克，骨肉参商，一般兄弟少，缘薄，背面不相亲，且各散西东，不常在一起，助力小。兄弟胆大，体弱多病、急躁孤僻。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;文昌(吉)(庙)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在兄弟宫，表示朋友的个性耿直，一般是个好人，重视学历、教育，懂得尊重知识。&lt;/p&gt;
&lt;p&gt;但文昌不代表就有助力，只是增进感情而已。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;天寿(平)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;有年龄差距很大的朋友或者兄弟姐妹。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;龙池(陷)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;交往的朋友比较骄傲，有一些才艺特长，有贵气。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;天哭(地)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;你有时候对兄弟姐妹、朋友不客气，让他们伤心。&lt;/p&gt;
&lt;p&gt;朋友有善良、悲天悯人的特点。&lt;/p&gt;
&lt;h4 id=&#34;32&#34;&gt;3.2 四化解析&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;紫微化科&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;你喜欢与聪明人结交，也喜欢跟比自己强的人在一起玩耍。你很欣赏能力强的人，并且能够与他们做朋友。&lt;/p&gt;
&lt;p&gt;你适合与年龄大、能力强、目光长远的人结交，他们能对你产生帮助。通常也适合在一起合作。&lt;/p&gt;
&lt;p&gt;兄弟姐妹聪明，互相团结，互相照顾。&lt;/p&gt;
&lt;h3 id=&#34;4&#34;&gt;4. 夫妻&lt;/h3&gt;
&lt;h4 id=&#34;41&#34;&gt;4.1 基本解析&lt;/h4&gt;
&lt;p&gt;男生，你喜欢的女生属于：机灵、反应快、善分析、善恶分明、喜欢学习、有服务的热忱、沟通协调的能力不错。&lt;/p&gt;
&lt;p&gt;女生，你喜欢的男生属于：冷静、清高、幽默、点子多、有条理、有正义感、奉公守法、知识丰富、能接受新鲜的事物。&lt;/p&gt;
&lt;p&gt;小结：你的感情有浮动的特质，会增加感情中的波折，不适应早婚，婚前应多考量与观察。如果对方心智或年轻较长，能包容和体谅你，会更能增进婚姻的稳定与美满。&lt;/p&gt;
&lt;p&gt;你另一半有以下缺点：不浪漫、缺乏安全感、不容易信任别人。所以你在经营婚姻的时候，要多尊重与赞美，给予安全感，才可以拉近两人之间的距离。&lt;/p&gt;
&lt;h4 id=&#34;42&#34;&gt;4.2 星曜解析&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;天机(庙)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;天机星因性质浮动，坐夫妻宫，主配偶在人生中，只要大限流年吉利，就能早婚；但也容易见异思迁，所以往往恋爱中途失败，导致迟婚，但早婚和迟婚因人而异，只要本命命宫或夫妻宫不逢煞星，皆主早婚，且有一见钟情的情况。&lt;/p&gt;
&lt;p&gt;感情和婚姻都需要稳定，而天机星定性不足，所以其坐夫妻宫，命主之婚姻生活难稳定，容易出现变化，大则波澜，小则涟漪。男命或者金屋藏娇，或者有昙花一现的外遇。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;天梁(旺)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;婚前常有许多的波折，容易受到父母或是亲友的反对阻挠，不过也因为婚前的困难，而造就婚后的幸福美满。&lt;/p&gt;
&lt;p&gt;另外，配偶的个性比较稳重老成，有责任感，常帮助他人。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;擎羊(煞)(庙)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;擎羊在夫妻宫，无论如何，都表示配偶个性刚强，不服管，时常与自己有矛盾、争吵。所以，不要老是想着去管你的配偶，让对方自由一些，双方的相处就更和睦。&lt;/p&gt;
&lt;p&gt;擎羊也主孤，表示配偶人缘一般，会受排挤、孤立等等。&lt;/p&gt;
&lt;p&gt;配偶经常与自己意见不同，需要商量、协调后才能统一看法。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;擎羊在夫妻宫，如果入庙，性质尚可，表示配偶积极努力，生活上的矛盾不算很大。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;擎羊在夫妻宫，如果落陷，性质很不利，矛盾较大，而且性格强势、霸道甚至不讲道理。女命必须找年纪比自己大个四五岁以上的对象。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;地劫(煞)(陷)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;地劫在夫妻宫，配偶的个性有点怪，爱好特殊。婚前较难寻觅理想对象。&lt;/p&gt;
&lt;p&gt;配偶会乱花钱，较难攒钱。本人在感情上有一些波折。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;天官(旺)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;天官星为官贵之星，本身聪明有智慧，做事认真负责，因此可以一步步往上爬，适合从事公职或在有升迁管道的大企业工作。&lt;/p&gt;
&lt;p&gt;个性随缘，喜欢自然的生活方式，悠閒自在的田园生活。&lt;/p&gt;
&lt;p&gt;感情婚姻生活幸福快乐，另一伴在工作事业上多能身居要职，且有不错的成就。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;解神&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;解神有解散的意思。易与配偶分开、聚少离多。&lt;/p&gt;
&lt;p&gt;如果与煞星、化忌同宫，离异的可能性较大，必须重视婚姻问题。&lt;/p&gt;
&lt;p&gt;也不宜与天马同宫，分开的时间更多。&lt;/p&gt;
&lt;h4 id=&#34;43&#34;&gt;4.3 四化解析&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;天机化禄&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本人的异性缘较好，易有多次感情经历。妻子较聪明，有志气，在内务方面井井有条。&lt;/p&gt;
&lt;p&gt;但天机也是动星，婚前婚后都易有聚少离多的情况，常有异地恋。&lt;/p&gt;
&lt;p&gt;可以因工作关系而结识异性，对方对自己有少量助力。&lt;/p&gt;
&lt;p&gt;男命在中年以后，桃花运更旺。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;天梁化权&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本人尊重家中配偶，配偶在家里有地位。&lt;/p&gt;
&lt;p&gt;男命，找一个比自己略大的老婆较好，对方会管你，但也会帮助你，生活还算稳定；如果你找比你小的对象，配偶花钱厉害，你比较辛苦劳累。&lt;/p&gt;
&lt;p&gt;女命，找一个比自己大八岁以上的老公更好，对方经济实力不错，愿意花钱。&lt;/p&gt;
&lt;p&gt;主配偶喜掌权、喜欢管事情，能说善道，很会教训人。&lt;/p&gt;
&lt;p&gt;配偶以赚取正财为主，不要搞歪门邪道，不要炒股和投机倒把，易亏损。&lt;/p&gt;
&lt;h3 id=&#34;5&#34;&gt;5. 子女&lt;/h3&gt;
&lt;h4 id=&#34;51&#34;&gt;5.1 星曜解析&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;天相(陷)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;命主之子女优秀孝顺，诚实敦厚，有福荫，心地善良，有正义感，注重体面，爱惜面子，贪吃爱漂亮，虚荣心强，较内向保守，喜欢一个人独处，不喜从事自己不感兴趣的行业。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;禄存(吉)(旺)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;禄存在子女宫，可以表示“子女带财而来”，在生育子女后，自己的财运有进步。&lt;/p&gt;
&lt;p&gt;禄存永远与博士同宫，博士是聪明的星曜，代表生的小孩比较聪明。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;禄存最怕落空亡，如果与地空、地劫同宫，则在小孩身上破耗很大，花钱多。也不能做“子女带财而来”解释。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;铃星(煞)(旺)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;铃星在子女宫，与子女有代沟，小时候大都与子女分开，聚少离多。&lt;/p&gt;
&lt;p&gt;铃星表示子女对自己有暗在的不满。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;恩光(庙)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;子女有一些知名度，能够与有名气的人、层次高的人结交。&lt;/p&gt;
&lt;h3 id=&#34;6&#34;&gt;6. 财帛&lt;/h3&gt;
&lt;h4 id=&#34;61&#34;&gt;6.1 星曜解析&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;太阳(旺)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;太阳星光明磊落，是广财星，主贵不主富，坐守财帛宫，命主之财皆凭社会地位而来，因此必须争取地位，如利于学术者，应追求较高学位，利于经商者，应追求代理名牌商品，或自行创造商标商誉，利于任职者，应积极进修，争取声誉，或凭人际关系创造升职条件。&lt;/p&gt;
&lt;p&gt;太阳主散，太阴主聚，故太阳守财帛宫，除非有太阴同度，否则必主散财，命主钱财出入大，出手大方。除了应注意节流外，更要去开创财富。必须一分耕耘，才有一分收获，宜防为亲戚、朋友耗财，利于从事公职、贸易、司法、军警、医护、公众福利、保险业。多能投资置产，晚景佳。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;巨门(庙)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;巨门星掌管口才和是非，坐守财帛宫，命主口才好，多靠一张嘴巴和脑力挣钱，如律师、教师、推销、传播、表演等行业，巨门化忌者尤然，否则必多是非词讼。&lt;/p&gt;
&lt;p&gt;命主须经劳心费神、竞争才能获财。命主一般不靠祖业，靠自己劳动取财，白手起家，但不宜心高气傲或太贪心，否则易受同事亲友排挤算计而致破败。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;陀罗(煞)(陷)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;陀罗在财帛宫，对财运不利，会为了钱财苦恼，或者赚钱的过程很不顺利。&lt;/p&gt;
&lt;p&gt;如果搭配的好，也能赚到不少钱，但过程是比较辛苦的。&lt;/p&gt;
&lt;p&gt;大都适合以技术手段求财，也有做武职工作的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;八座(庙)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对赚钱有好处，表示有人抬举你、帮你赚钱。搭配吉星吉化，可以靠车辆、交通工具赚钱。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;红鸾(旺)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在财帛宫主吉利，能加强赚钱的效果。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;孤辰(平)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;求财方面得到的助力不大，更多的是靠自己努力。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;天空&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;7&#34;&gt;7. 疾厄&lt;/h3&gt;
&lt;h4 id=&#34;71&#34;&gt;7.1 基本解析&lt;/h4&gt;
&lt;p&gt;你要注意呼吸系统、鼻气管发炎、外伤，皮服、痔疮、大肠、胃、生殖系统、关节神经方面的健康问题。&lt;/p&gt;
&lt;h4 id=&#34;72&#34;&gt;7.2 星曜解析&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;武曲(庙)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以肺及呼吸系统疾病及损伤为主，易有感冒，咳嗽，哮喘，鼻炎过敏，牙痛，鼻血，语塞音哑，肺痨吐血，大肠秘结，骨痛。&lt;/p&gt;
&lt;p&gt;幼年多灾，手足头面易有伤损而留下疤痕，亦易患百日咳。晚年易有风痰。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;贪狼(庙)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;贪狼星五行属阳木，坐守疾厄宫，主其人有肝胆病或肝胃不和、头昏气闷或皮肤有癖瘢。主肝胆、肾脏、泌尿升值器、花柳病、性病等症，以及因肾疾病引发之心脏病。&lt;/p&gt;
&lt;p&gt;另主疑症，不易治疗，找不到病源。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;左辅(吉)(庙)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;左辅阳土,主脾胃病,灾病少，加吉一生平安。加煞，易有脾胃不和，腿脚浮肿，湿热下注，扭伤，风湿，左半部疾患。化科，脾胃病，但逢灾有救，遇难呈祥，人生乐观。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;右弼(吉)(庙)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;右弼在疾厄宫，对身体状况来说，不算是一颗吉星。&lt;/p&gt;
&lt;p&gt;右弼为癸水，有森冷的气质，所以入疾厄宫以后，表示小毛病多，例如炎症反复发作。但单有一颗右弼，不会产生大问题。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;天使(陷)&lt;/p&gt;
&lt;p&gt;破碎(陷)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在疾厄宫是凶星，不吉利，身体易受伤、破损、留疤痕。&lt;/p&gt;
&lt;p&gt;如果遇到煞星、化忌很多，凶气很强，凡事都要谨慎小心。&lt;/p&gt;
&lt;h3 id=&#34;8&#34;&gt;8. 迁移&lt;/h3&gt;
&lt;h4 id=&#34;81&#34;&gt;8.1 星曜解析&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;天同(旺)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;天同为吉星，坐守迁移宫，主出门和谐安宁，不奔忙，无是非纷争的烦恼，有清闲之福，但不主发达成名，见诸吉多则除外。天同星爱静，懒惰，好享受，坐迁移宫，离家在外时若能逆其性而行，多努力活动则可提高社会地位。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;太阴(庙)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;太阴星坐守迁移宫主多动，可为行商，越积极活动、变动越有利。庙旺，在外人缘广，会有地位高的贵人（多为女性）提携，事业有成。加煞，仅主辛劳奔波，经努力仍可致富，不宜与人竞争。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;天魁(吉)(庙)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;天魁在迁移宫主吉利，在外地有贵人运，也更容易发挥自己的优点。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;三台(平)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;三台在迁移宫主吉利，大都可以在很年轻的时候购买车辆，也表示在外地受人抬举，有一些助力。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不宜见煞星、化忌，如果煞气太重，反而有交通事故的可能性。（三台是车辆，加煞星就是车辆带煞气了）&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;82&#34;&gt;8.2 四化解析&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;太阴化忌&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在庙旺地化忌时，危害较小，外出仍然有利可图。&lt;/p&gt;
&lt;p&gt;陷地化忌，劳碌奔波，辛苦、孤独，对母亲有刑克。本人在外地获利少，财运一般。&lt;/p&gt;
&lt;p&gt;在外容易遭小人暗算，因为太阴有阴险的意思，化忌以后易在外地招惹小人、阴人，使你破财、使你心情不好。&lt;/p&gt;
&lt;p&gt;也表示本人得到女性的助力小，与女人合不来。注意出外暗损金钱，或因女人破财，等等。&lt;/p&gt;
&lt;p&gt;冲命，婚姻感情不顺利，较难结婚，易有波折、受伤的感情经历。&lt;/p&gt;
&lt;h3 id=&#34;9&#34;&gt;9. 奴仆&lt;/h3&gt;
&lt;h4 id=&#34;91&#34;&gt;9.1 星曜解析&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;天府(旺)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;天府星坐守交友宫，命主择交谨慎，故多交益友。然必须见魁钺、辅弼，然后主可得知交，且主下属得力。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;天马(吉)(平)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;天马表示奔波，所以你的朋友大都是外地人哦！也有不少是外地过来，到这里工作、学习、上班的人哦！&lt;/p&gt;
&lt;p&gt;天马也表示你跟朋友的感情不错，但不会太长久，因为天马是跑来跑去的星，慢慢的联络就减少了！&lt;/p&gt;
&lt;p&gt;你的朋友来自天南地北，也能帮你做一些事情。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;台辅&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;小吉星，力量比较弱，表示你的朋友、下属能帮上一些忙。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;天伤(旺)&lt;/p&gt;
&lt;p&gt;旬空&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;10&#34;&gt;10. 官禄&lt;/h3&gt;
&lt;h4 id=&#34;101&#34;&gt;10.1 基本解析&lt;/h4&gt;
&lt;p&gt;受到你的命宫（无主星）、迁移宫（太阴星、天同星）、夫妻宫（天机星、天梁星）的交互影响，你的工作具有变动、主导的特性。适合从事有变化性、与需要创意的工作，如果工作的环境有制度，公平合理，你比较能发挥长处。&lt;/p&gt;
&lt;p&gt;此外，你的工作也具有服务和付出的特色，多帮助需要帮助的人，扮演一个协助的角色，更可以发挥你天生的潜能。&lt;/p&gt;
&lt;h4 id=&#34;102&#34;&gt;10.2 星曜解析&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;天姚&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在工作上接触异性挺多，本人可能从事艺术类工作。&lt;/p&gt;
&lt;p&gt;也比一般人更可能出轨，因为官禄宫可以是工作的情况，在工作上遇到异性多，所以容易发生这类事情。&lt;/p&gt;
&lt;p&gt;（官禄宫冲夫妻宫，所以天姚在这里，有时表示丈夫出轨，而不是自己出轨）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;寡宿(平)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;寡宿在事业宫，工作上需要靠个人能力的更多，不要总是期待别人来帮你。你要努力提高自己的水平。&lt;/p&gt;
&lt;h3 id=&#34;11_1&#34;&gt;11. 田宅&lt;/h3&gt;
&lt;h4 id=&#34;111&#34;&gt;11.1 星曜解析&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;廉贞(平)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;廉贞星性质动荡，入田宅宫不为吉论，主破祖败业，有祖业亦难有份，自置纠纷多。须有入庙或吉星同宫才能顺利地自置产业，陷地或稍见煞星就破祖败业，置业时易有是非纠纷。&lt;/p&gt;
&lt;p&gt;廉贞在寅宫、申宫守田宅宫，情况好一些，此时是“紫府朝垣”的情况，还是不错的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;破军(陷)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;破军星在紫微斗数中化气为耗，具有充分的变化性、破坏性和突发性，因此破军星坐田宅宫不为吉论，命主一般无法继承祖业，有亦破荡，需靠自己打拼置业，即使有财禄也会挥霍，先败后成。&lt;/p&gt;
&lt;p&gt;住宅狭隘、陈旧、零乱，地势高低不平，常翻新或搬家，附近环境复杂，有闹市、水道、低洼地、堆积物、杂贷市场、破旧建筑。住宅怎样维修也会漏水。破军庙旺可充分利用祖产，但仍易破败，先破祖业而后自置；亦主旧业翻新。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;文曲(吉)(庙)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在田宅宫比较吉利，表示家里人爱读书，而且大都是子女爱读书、子女的成绩不错。&lt;/p&gt;
&lt;p&gt;家庭成员感情还可以，有一些共同话题。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;凤阁(庙)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;凤阁在田宅宫，家庭比较清洁、有档次，条件好。&lt;/p&gt;
&lt;p&gt;凤阁可以理解为“凤凰的楼阁”，照入子女宫，子女大都有前途，因为凤凰不落无宝地。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;年解&lt;/p&gt;
&lt;p&gt;蜚廉&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在田宅宫，注意家里可能招虫，蚊虫多，甚至可能有白蚁。&lt;/p&gt;
&lt;h3 id=&#34;12&#34;&gt;12. 福德&lt;/h3&gt;
&lt;h4 id=&#34;121&#34;&gt;12.1 基本解析&lt;/h4&gt;
&lt;p&gt;你的物质享受，必须经过努力打拼，才会获得。减少内心的飘忽不定，为自己找到生活的重心，福报就会渐渐被自己所撑握。&lt;/p&gt;
&lt;h4 id=&#34;122&#34;&gt;12.2 星曜解析&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;天钺(吉)(庙)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;天钺在福德宫，也有一些贵人运，心肠好，心性高洁。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;火星(煞)(陷)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在福德宫，性情外向，脾气比较急躁，直来直去。&lt;/p&gt;
&lt;p&gt;你会有感情上、事业上的波折，但最终能够走出来，并且继续往前奋进。&lt;/p&gt;
&lt;p&gt;女命不利婚姻，早年感情运不顺利。&lt;/p&gt;
&lt;p&gt;火星最好是庙旺，这样带来的波折不多，而且能让你愈挫愈勇。&lt;/p&gt;
&lt;p&gt;如果火星落陷，你内心是受过不少伤痛的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;天福(庙)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在福德宫非常吉利，这颗星在福德宫是得位，表示很有福气，不干家务，有别人为你服务。生活滋润，心情开朗。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;天喜(旺)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;天喜在福德宫是一颗吉星，表示内心欢喜，乐观外向，有一些福气。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;天巫&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;天巫在福德宫，本人对宗教、玄学、命理、风水、中医等感兴趣。&lt;/p&gt;
&lt;p&gt;天巫是吉星，搭配吉星吉化，表示自己聪明有才、多学多能。&lt;/p&gt;
&lt;p&gt;遇到禄存、化禄，很有钱，得财容易，有遗产等等。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;阴煞&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在福德宫，婚姻上犯小人，自己疑心病略重。&lt;/p&gt;
&lt;h3 id=&#34;13&#34;&gt;13. 父母&lt;/h3&gt;
&lt;h4 id=&#34;131&#34;&gt;13.1 星曜解析&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;天才(平)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;父母比较聪明、有头脑。你能继承到他们的聪明细胞。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;天贵(旺)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;父母有一些社会地位，受人尊重。但需要搭配吉星吉化，才以此论。&lt;/p&gt;
&lt;p&gt;如果搭配煞星、化忌，则力量很小，可以忽略不计。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;封诰&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;小吉星，力量比较弱，表示父母有一些名誉，受人尊重。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;天虚(陷)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;代表父母有虚荣、爱面子的特点。身体也有一些虚弱。&lt;/p&gt;
&lt;p&gt;如果遇到煞星、化忌，表示父母不爱说真话，喜欢隐藏真实想法，有点虚伪。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;截空&lt;/p&gt;
&lt;/blockquote&gt;</description>  
      <pubDate>2025-10-09 17:54:40</pubDate>  
      <link>https://testpoo.github.io/紫薇斗数解析.html</link>  
      <guid isPermaLink="true">https://testpoo.github.io/紫薇斗数解析.html</guid>
       
      <category>摘录</category> 
      
    </item>
    
    <item> 
      <title>分分种学会python3</title>  
      <description>&lt;div class=&#34;toc&#34;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#python3x&#34;&gt;python3.x&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_1&#34;&gt;基本数据类型和操作符&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_2&#34;&gt;变量和集合&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_3&#34;&gt;控制流&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_4&#34;&gt;函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_5&#34;&gt;类&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_6&#34;&gt;模块&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h3 id=&#34;python3x&#34;&gt;python3.x&lt;/h3&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;# 单行注释由一个井号开头。
&amp;quot;&amp;quot;&amp;quot; 
   三个双引号（或单引号）之间可以写多行字符串，
   通常用来写注释。
&amp;quot;&amp;quot;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;_1&#34;&gt;基本数据类型和操作符&lt;/h3&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;# 数字就是数字
3 #=&amp;gt; 3
&lt;/code&gt;&lt;/pre&gt;

&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;# 四则运算也是你所期望的那样
1 + 1 #=&amp;gt; 2
8 - 1 #=&amp;gt; 7
10 * 2 #=&amp;gt; 20
35 / 5 #=&amp;gt; 7.0
&lt;/code&gt;&lt;/pre&gt;

&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;# 为了修正除法的问题，我们需要先学习浮点数。
2.0     # This is a float
2.0     # 这是一个浮点数
11.0 / 4.0 #=&amp;gt; 2.75 ahhh...much better
11.0 / 4.0 #=&amp;gt; 2.75 啊……这样就好多了
&lt;/code&gt;&lt;/pre&gt;

&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;# 使用小括号来强制计算的优先顺序
(1 + 3) * 2 #=&amp;gt; 8
&lt;/code&gt;&lt;/pre&gt;

&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;# 布尔值也是基本数据类型
True
False
&lt;/code&gt;&lt;/pre&gt;

&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;# 使用 not 来取反
not True #=&amp;gt; False
not False #=&amp;gt; True
&lt;/code&gt;&lt;/pre&gt;

&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;# 等式判断用 ==
1 == 1 #=&amp;gt; True
2 == 1 #=&amp;gt; False
&lt;/code&gt;&lt;/pre&gt;

&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;# 不等式判断是用 !=
1 != 1 #=&amp;gt; False
2 != 1 #=&amp;gt; True
&lt;/code&gt;&lt;/pre&gt;

&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;# 还有更多的比较运算
1 &amp;lt; 10 #=&amp;gt; True
1 &amp;gt; 10 #=&amp;gt; False
2 &amp;lt;= 2 #=&amp;gt; True
2 &amp;gt;= 2 #=&amp;gt; True
&lt;/code&gt;&lt;/pre&gt;

&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;# 居然可以把比较运算串连起来！
1 &amp;lt; 2 &amp;lt; 3 #=&amp;gt; True
2 &amp;lt; 3 &amp;lt; 2 #=&amp;gt; False
&lt;/code&gt;&lt;/pre&gt;

&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;# 使用 &amp;quot; 或 &#39; 来创建字符串
&amp;quot;This is a string.&amp;quot;
&#39;This is also a string.&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;# 字符串也可以相加！
&amp;quot;Hello &amp;quot; + &amp;quot;world!&amp;quot; #=&amp;gt; &amp;quot;Hello world!&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;# 一个字符串可以视为一个字符的列表
&amp;quot;This is a string&amp;quot;[0] #=&amp;gt; &#39;T&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;# % 可以用来格式化字符串，就像这样：
&amp;quot;%s can be %s&amp;quot; % (&amp;quot;strings&amp;quot;, &amp;quot;interpolated&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;# 格式化字符串的新方法：format 方法。
&amp;quot;{0} can be {1}&amp;quot;.format(&amp;quot;strings&amp;quot;, &amp;quot;formatted&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;# 如果你不喜欢数数的话，可以使用关键字（变量）。
&amp;quot;{name} wants to eat {food}&amp;quot;.format(name=&amp;quot;Bob&amp;quot;, food=&amp;quot;lasagna&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;# None 是一个对象
None #=&amp;gt; None
&lt;/code&gt;&lt;/pre&gt;

&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;# 不要使用相等符号 `==` 来把对象和 None 进行比较，
# 而要用 `is`。
&amp;quot;etc&amp;quot; is None #=&amp;gt; False
None is None  #=&amp;gt; True

# 这个 `is` 操作符用于比较两个对象的标识。
# （译注：对象一旦建立，其标识就不会改变，可以认为它就是对象的内存地址。）
# 在处理基本数据类型时基本用不上，
# 但它在处理对象时很有用。
&lt;/code&gt;&lt;/pre&gt;

&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;# None、0 以及空字符串和空列表都等于 False，
# 除此以外的所有值都等于 True。
0 == False  #=&amp;gt; True
&amp;quot;&amp;quot; == False #=&amp;gt; True
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;_2&#34;&gt;变量和集合&lt;/h3&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;# 打印输出很简单
print(&amp;quot;I&#39;m Python. Nice to meet you!&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;# 在赋值给变量之前不需要声明
some_var = 5   # 变量名的约定是使用下划线分隔的小写单词
some_var #=&amp;gt; 5
&lt;/code&gt;&lt;/pre&gt;

&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;# 访问一个未赋值的变量会产生一个异常。
some_other_var  # 会抛出一个名称错误 NameError: name &#39;some_other_var&#39; is not defined
&lt;/code&gt;&lt;/pre&gt;

&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;# if 可以作为表达式来使用
&amp;quot;yahoo!&amp;quot; if 3 &amp;gt; 2 else 2 #=&amp;gt; &amp;quot;yahoo!&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;# 列表用于存储序列
li = []
# 我们先尝试一个预先填充好的列表
other_li = [4, 5, 6]

# 使用 append 方法把元素添加到列表的尾部
li.append(1)   #li 现在是 [1]
li.append(2)   #li 现在是 [1, 2]
li.append(4)   #li 现在是 [1, 2, 4]
li.append(3)   #li 现在是 [1, 2, 4, 3]

# 使用 pop 来移除最后一个元素
li.pop()       #=&amp;gt; 3，然后 li 现在是 [1, 2, 4]
# 我们再把它放回去
li.append(3)   # li 现在又是 [1, 2, 4, 3] 了

# 像访问其它语言的数组那样访问列表
li[0] #=&amp;gt; 1
# 查询最后一个元素
li[-1] #=&amp;gt; 3

# 越界查询会产生一个索引错误
li[4] # 抛出一个索引错误 IndexError: list index out of range

# 你可以使用切片语法来查询列表的一个范围。
# （这个范围相当于数学中的左闭右开区间。）
li[1:3] #=&amp;gt; [2, 4]
# 省略开头
li[2:] #=&amp;gt; [4, 3]
# 省略结尾
li[:3] #=&amp;gt; [1, 2, 4]

# 使用 del 来删除列表中的任意元素
del li[2] # li 现在是 [1, 2, 3]

# 可以把列表相加
other_li = [4, 5, 6]
li + other_li #=&amp;gt; [1, 2, 3, 4, 5, 6] - 请留意 li 和 other_li 并不会被修改

# 使用 extend 来合并列表
li.extend(other_li) # 现在 li 是 [1, 2, 3, 4, 5, 6]

# 用 in 来检查是否存在于某个列表中
1 in li #=&amp;gt; True

# 用 len 来检测列表的长度
len(li) #=&amp;gt; 6
&lt;/code&gt;&lt;/pre&gt;

&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;# 元组很像列表，但它是“不可变”的。
tup = (1, 2, 3)
tup[0] #=&amp;gt; 1
tup[0] = 3  # 抛出一个类型错误 SyntaxError: can&#39;t assign to function call

# 操作列表的方式通常也能用在元组身上
len(tup) #=&amp;gt; 3
tup + (4, 5, 6) #=&amp;gt; (1, 2, 3, 4, 5, 6)
tup[:2] #=&amp;gt; (1, 2)
2 in tup #=&amp;gt; True

# 你可以把元组（或列表）中的元素解包赋值给多个变量
a, b, c = (1, 2, 3)    # 现在 a 是 1，b 是 2，c 是 3
# 如果你省去了小括号，那么元组会被自动创建
d, e, f = 4, 5, 6
# 再来看看交换两个值是多么简单。
e, d = d, e    # 现在 d 是 5 而 e 是 4
&lt;/code&gt;&lt;/pre&gt;

&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;# 字典用于存储映射关系
empty_dict = {}
# 这是一个预先填充的字典
filled_dict = {&amp;quot;one&amp;quot;: 1, &amp;quot;two&amp;quot;: 2, &amp;quot;three&amp;quot;: 3}

# 使用 [] 来查询键值
filled_dict[&amp;quot;one&amp;quot;] #=&amp;gt; 1

# 将字典的所有键名获取为一个列表
filled_dict.keys() #=&amp;gt; [&amp;quot;three&amp;quot;, &amp;quot;two&amp;quot;, &amp;quot;one&amp;quot;]
# 请注意：无法保证字典键名的顺序如何排列。
# 你得到的结果可能跟上面的示例不一致。

# 将字典的所有键值获取为一个列表
filled_dict.values() #=&amp;gt; [3, 2, 1]
# 请注意：顺序的问题和上面一样。

# 使用 in 来检查一个字典是否包含某个键名
&amp;quot;one&amp;quot; in filled_dict #=&amp;gt; True
1 in filled_dict #=&amp;gt; False

# 查询一个不存在的键名会产生一个键名错误
filled_dict[&amp;quot;four&amp;quot;] # 键名错误 KeyError: &#39;four&#39;

# 所以要使用 get 方法来避免键名错误
filled_dict.get(&amp;quot;one&amp;quot;) #=&amp;gt; 1
filled_dict.get(&amp;quot;four&amp;quot;) #=&amp;gt; None
# get 方法支持传入一个默认值参数，将在取不到值时返回。
filled_dict.get(&amp;quot;one&amp;quot;, 4) #=&amp;gt; 1
filled_dict.get(&amp;quot;four&amp;quot;, 4) #=&amp;gt; 4

# Setdefault 方法可以安全地把新的名值对添加到字典里
filled_dict.setdefault(&amp;quot;five&amp;quot;, 5) #filled_dict[&amp;quot;five&amp;quot;] 被设置为 5
filled_dict.setdefault(&amp;quot;five&amp;quot;, 6) #filled_dict[&amp;quot;five&amp;quot;] 仍然为 5
&lt;/code&gt;&lt;/pre&gt;

&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;# set 用于保存集合
empty_set = set()
# 使用一堆值来初始化一个集合
some_set = set([1,2,2,3,4]) # some_set 现在是 set([1, 2, 3, 4])

# {} 可以用来声明一个集合
filled_set = {1, 2, 2, 3, 4} # =&amp;gt; {1, 2, 3, 4}
# 集合是种无序不重复的元素集，因此重复的 2 被滤除了。
# {} 不会创建一个空集合，只会创建一个空字典。

# 把更多的元素添加进一个集合
filled_set.add(5) # filled_set 现在是 {1, 2, 3, 4, 5}

# 使用 &amp;amp; 来获取交集
other_set = {3, 4, 5, 6}
filled_set &amp;amp; other_set #=&amp;gt; {3, 4, 5}

# 使用 | 来获取并集
filled_set | other_set #=&amp;gt; {1, 2, 3, 4, 5, 6}

# 使用 - 来获取补集
{1,2,3,4} - {2,3,5} #=&amp;gt; {1, 4}

# 使用 in 来检查是否存在于某个集合中
2 in filled_set #=&amp;gt; True
10 in filled_set #=&amp;gt; False
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;_3&#34;&gt;控制流&lt;/h3&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;# 我们先创建一个变量
some_var = 5

# 这里有一个条件语句。缩进在 Python 中可是很重要的哦！
# 程序会打印出 &amp;quot;some_var is smaller than 10&amp;quot;
if some_var &amp;gt; 10:
   print(&amp;quot;some_var is totally bigger than 10.&amp;quot;)
elif some_var &amp;lt; 10:   # 这里的 elif 子句是可选的
   print(&amp;quot;some_var is smaller than 10.&amp;quot;)
else:          # 这一句也是可选的
   print(&amp;quot;some_var is indeed 10.&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;# for 循环可以遍历列表
# 如果要打印出：
dog is a mammal
cat is a mammal
mouse is a mammal

for animal in [&amp;quot;dog&amp;quot;, &amp;quot;cat&amp;quot;, &amp;quot;mouse&amp;quot;]:
   # 别忘了你可以使用 % 来格式化字符串
   print(&amp;quot;%s is a mammal&amp;quot; % animal)
   # （译注：意为“%s 是哺乳动物”。）
&lt;/code&gt;&lt;/pre&gt;

&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;# range(数字) 会返回一个数字列表，这个列表将包含从零到给定的数字。
如果要打印出：
0
1
2
3

for i in range(4):
   print(i)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;while 循环会一直继续，直到条件不再满足。
如果要打印出：
0
1
2
3

x = 0
while x &amp;lt; 4:
   print(x)
   x += 1  # 这是 x = x + 1 的简写方式
&lt;/code&gt;&lt;/pre&gt;

&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;# 使用 try/except 代码块来处理异常

try:
   # 使用 raise 来抛出一个错误
   # 抛出一个索引错误：“这是一个索引错误”。
except IndexError as e:
   pass    # pass 只是一个空操作。通常你应该在这里做一些恢复工作。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;_4&#34;&gt;函数&lt;/h3&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;# 使用 def 来创建新函数
def add(x, y):
   print(&amp;quot;x is %s and y is %s&amp;quot; % (x, y))
   # （译注：意为&amp;quot;x 是 %s 而且 y 是 %s&amp;quot;。）
   return x + y    # 使用 return 语句来返回值

# 调用函数并传入参数
add(5, 6) #=&amp;gt; 意为“x 是 5 而且 y 是 6”，并返回 11

# 调用函数的另一种方式是传入关键字参数
add(y=6, x=5)  # 关键字参数可以以任意顺序传入

# 你可以定义一个函数，并让它接受可变数量的定位参数。
def varargs(*args):
   return args

varargs(1, 2, 3) #=&amp;gt; (1,2,3)

# 你也可以定义一个函数，并让它接受可变数量的关键字参数。
def keyword_args(**kwargs):
   return kwargs

# 我们试着调用它，看看会发生什么：
keyword_args(big=&amp;quot;foot&amp;quot;, loch=&amp;quot;ness&amp;quot;) #=&amp;gt; {&amp;quot;big&amp;quot;: &amp;quot;foot&amp;quot;, &amp;quot;loch&amp;quot;: &amp;quot;ness&amp;quot;}

# 你还可以同时使用这两类参数，只要你愿意：
def all_the_args(*args, **kwargs):
   print(args)
   print(kwargs)

all_the_args(1, 2, a=3, b=4) prints:
   (1, 2)
   {&amp;quot;a&amp;quot;: 3, &amp;quot;b&amp;quot;: 4}

# 在调用函数时，定位参数和关键字参数还可以反过来用。
# 使用 * 来展开元组，使用 ** 来展开关键字参数。
args = (1, 2, 3, 4)
kwargs = {&amp;quot;a&amp;quot;: 3, &amp;quot;b&amp;quot;: 4}
all_the_args(*args) # 相当于 all_the_args(1, 2, 3, 4)
all_the_args(**kwargs) # 相当于 all_the_args(a=3, b=4)
all_the_args(*args, **kwargs) # 相当于 all_the_args(1, 2, 3, 4, a=3, b=4)

# 函数在 Python 中是一等公民
def create_adder(x):
   def adder(y):
       return x + y
   return adder

add_10 = create_adder(10)
add_10(3) #=&amp;gt; 13

# 还有匿名函数
(lambda x: x &amp;gt; 2)(3) #=&amp;gt; True

# 还有一些内建的高阶函数
list(map(add_10, [1,2,3])) #=&amp;gt; [11, 12, 13]l
list(filter(lambda x: x &amp;gt; 5, [3, 4, 5, 6, 7])) #=&amp;gt; [6, 7]

# 我们可以使用列表推导式来模拟 map 和 filter
[add_10(i) for i in [1, 2, 3]]  #=&amp;gt; [11, 12, 13]
[x for x in [3, 4, 5, 6, 7] if x &amp;gt; 5] #=&amp;gt; [6, 7]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;_5&#34;&gt;类&lt;/h3&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;# 我们可以从对象中继承，来得到一个类。
class Human(object):

   # 下面是一个类属性。它将被这个类的所有实例共享。
   species = &amp;quot;H. sapiens&amp;quot;

   # 基本的初始化函数（构造函数）
   def __init__(self, name):
       # 把参数赋值为实例的 name 属性
       self.name = name

   # 下面是一个实例方法。所有方法都以 self 作为第一个参数。
   def say(self, msg):
      return &amp;quot;%s: %s&amp;quot; % (self.name, msg)

   # 类方法会被所有实例共享。
   # 类方法在调用时，会将类本身作为第一个函数传入。
   @classmethod
   def get_species(cls):
       return cls.species

   # 静态方法在调用时，不会传入类或实例的引用。
   @staticmethod
   def grunt():
       return &amp;quot;*grunt*&amp;quot;

# 实例化一个类
i = Human(name=&amp;quot;Ian&amp;quot;)
print（i.say(&amp;quot;hi&amp;quot;)） # 打印出 &amp;quot;Ian: hi&amp;quot;

j = Human(&amp;quot;Joel&amp;quot;)
print(j.say(&amp;quot;hello&amp;quot;))  # 打印出 &amp;quot;Joel: hello&amp;quot;

# 调用我们的类方法
i.get_species() #=&amp;gt; &amp;quot;H. sapiens&amp;quot;

# 修改共享属性
Human.species = &amp;quot;H. neanderthalensis&amp;quot;
i.get_species() #=&amp;gt; &amp;quot;H. neanderthalensis&amp;quot;
j.get_species() #=&amp;gt; &amp;quot;H. neanderthalensis&amp;quot;

# 调用静态方法
Human.grunt() #=&amp;gt; &amp;quot;*grunt*&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;_6&#34;&gt;模块&lt;/h3&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;# 你可以导入模块
import math
print(math.sqrt(16)) #=&amp;gt; 4

# 也可以从一个模块中获取指定的函数
from math import ceil, floor
print(ceil(3.7))  #=&amp;gt; 4.0
print(floor(3.7)) #=&amp;gt; 3.0

# 你可以从一个模块中导入所有函数
# 警告：不建议使用这种方式
from math import *

# 你可以缩短模块的名称
import math as m
math.sqrt(16) == m.sqrt(16) #=&amp;gt; True

# Python 模块就是普通的 Python 文件。
# 你可以编写你自己的模块，然后导入它们。
# 模块的名称与文件名相同。

# 你可以查出一个模块里有哪些函数和属性，定义一个模块
import math
dir(math)
&lt;/code&gt;&lt;/pre&gt;</description>  
      <pubDate>2025-10-09 17:54:40</pubDate>  
      <link>https://testpoo.github.io/分分种学会python3.html</link>  
      <guid isPermaLink="true">https://testpoo.github.io/分分种学会python3.html</guid>
       
      <category>技术</category> 
      
    </item>
    
    <item> 
      <title>Markdown笔记</title>  
      <description>&lt;div class=&#34;toc&#34;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-markdown&#34;&gt;1. Markdown 标题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_1&#34;&gt;我展示的是一级标题&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#_2&#34;&gt;我展示的是二级标题&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_3&#34;&gt;一级标题&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#_4&#34;&gt;二级标题&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#_5&#34;&gt;三级标题&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#_6&#34;&gt;四级标题&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#_7&#34;&gt;五级标题&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#_8&#34;&gt;六级标题&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-markdown&#34;&gt;2. Markdown 段落&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#_9&#34;&gt;字体&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_10&#34;&gt;分隔线&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_11&#34;&gt;下划线&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_12&#34;&gt;脚注&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3-markdown&#34;&gt;3. Markdown 列表&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#_13&#34;&gt;列表嵌套&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4-markdown&#34;&gt;4. Markdown 区块&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#_14&#34;&gt;区块中使用列表&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_15&#34;&gt;列表中使用区块&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5-markdown&#34;&gt;5. Markdown 代码&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#_16&#34;&gt;代码区块&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#6-markdown&#34;&gt;6. Markdown 链接&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#_17&#34;&gt;高级链接&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#7-markdown&#34;&gt;7. Markdown 图片&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#8-markdown&#34;&gt;8. Markdown 表格&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#9-markdown&#34;&gt;9. Markdown 高级技巧&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#_18&#34;&gt;转义&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h3 id=&#34;1-markdown&#34;&gt;1. Markdown 标题&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;使用 = 和 - 标记一级和二级标题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;= 和 - 标记语法格式如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;我展示的是一级标题
=================

我展示的是二级标题
-----------------
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;显示效果如下图：&lt;/p&gt;
&lt;h1 id=&#34;_1&#34;&gt;我展示的是一级标题&lt;/h1&gt;
&lt;h2 id=&#34;_2&#34;&gt;我展示的是二级标题&lt;/h2&gt;
&lt;p&gt;使用 # 号标记&lt;/p&gt;
&lt;p&gt;使用 # 号可表示 1-6 级标题，一级标题对应一个 # 号，二级标题对应两个 # 号，以此类推。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;# 一级标题
## 二级标题
### 三级标题
#### 四级标题
##### 五级标题
###### 六级标题
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;显示效果如下图：&lt;/p&gt;
&lt;h1 id=&#34;_3&#34;&gt;一级标题&lt;/h1&gt;
&lt;h2 id=&#34;_4&#34;&gt;二级标题&lt;/h2&gt;
&lt;h3 id=&#34;_5&#34;&gt;三级标题&lt;/h3&gt;
&lt;h4 id=&#34;_6&#34;&gt;四级标题&lt;/h4&gt;
&lt;h5 id=&#34;_7&#34;&gt;五级标题&lt;/h5&gt;
&lt;h6 id=&#34;_8&#34;&gt;六级标题&lt;/h6&gt;
&lt;h3 id=&#34;2-markdown&#34;&gt;2. Markdown 段落&lt;/h3&gt;
&lt;p&gt;Markdown 段落没有特殊的格式，直接编写文字就好，段落的换行是使用两个以上空格加上回车。&lt;/p&gt;
&lt;p&gt;当然也可以在段落后面使用一个空行来表示重新开始一个段落。&lt;/p&gt;
&lt;h4 id=&#34;_9&#34;&gt;字体&lt;/h4&gt;
&lt;p&gt;Markdown 可以使用以下几种字体：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;*斜体文本*
_斜体文本_
**粗体文本**
__粗体文本__
***粗斜体文本***
___粗斜体文本___
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;显示效果如下所示：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;斜体文本&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;斜体文本&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;粗体文本&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;粗体文本&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;粗斜体文本&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;粗斜体文本&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;_10&#34;&gt;分隔线&lt;/h4&gt;
&lt;p&gt;你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;***

* * *

*****

- - -

----------
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;显示效果如下所示：&lt;/p&gt;
&lt;hr /&gt;
&lt;hr /&gt;
&lt;hr /&gt;
&lt;hr /&gt;
&lt;hr /&gt;
&lt;h4 id=&#34;_11&#34;&gt;下划线&lt;/h4&gt;
&lt;p&gt;下划线可以通过 HTML 的&lt;code&gt;&amp;lt;u&amp;gt;&lt;/code&gt;标签来实现：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;&amp;lt;u&amp;gt;带下划线文本&amp;lt;/u&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;显示效果如下所示：&lt;/p&gt;
&lt;p&gt;&lt;u&gt;带下划线文本&lt;/u&gt;&lt;/p&gt;
&lt;h4 id=&#34;_12&#34;&gt;脚注&lt;/h4&gt;
&lt;p&gt;脚注是对文本的补充说明。&lt;/p&gt;
&lt;p&gt;Markdown 脚注的格式如下:&lt;/p&gt;
&lt;p&gt;[^要注明的文本] 以下实例演示了脚注的用法：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;创建脚注格式类似这样 [^TESTPOO]。

[^TESTPOO]: Markdown笔记 -- 做个记录方便查找！！！
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;演示效果如下：&lt;/p&gt;
&lt;p&gt;创建脚注格式类似这样 &lt;sup id=&#34;fnref:TESTPOO&#34;&gt;&lt;a class=&#34;footnote-ref&#34; href=&#34;#fn:TESTPOO&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;
&lt;h3 id=&#34;3-markdown&#34;&gt;3. Markdown 列表&lt;/h3&gt;
&lt;p&gt;Markdown 支持有序列表和无序列表。&lt;/p&gt;
&lt;p&gt;无序列表使用星号(*)、加号(+)或是减号(-)作为列表标记：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;* 第一项
* 第二项
* 第三项

+ 第一项
+ 第二项
+ 第三项

- 第一项
- 第二项
- 第三项
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;显示结果如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;第一项&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第二项&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第三项&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第一项&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第二项&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第三项&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第一项&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第二项&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第三项&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有序列表使用数字并加上.号来表示，如：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;1. 第一项
2. 第二项
3. 第三项
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;显示结果如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;第一项&lt;/li&gt;
&lt;li&gt;第二项&lt;/li&gt;
&lt;li&gt;第三项&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;_13&#34;&gt;列表嵌套&lt;/h4&gt;
&lt;p&gt;列表嵌套只需在子列表中的选项添加四个空格即可：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;1. 第一项：
    - 第一项嵌套的第一个元素
    - 第一项嵌套的第二个元素
2. 第二项：
    - 第二项嵌套的第一个元素
    - 第二项嵌套的第二个元素
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;显示结果如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;第一项：&lt;/li&gt;
&lt;li&gt;第一项嵌套的第一个元素&lt;/li&gt;
&lt;li&gt;第一项嵌套的第二个元素&lt;/li&gt;
&lt;li&gt;第二项：&lt;/li&gt;
&lt;li&gt;第二项嵌套的第一个元素&lt;/li&gt;
&lt;li&gt;第二项嵌套的第二个元素&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;4-markdown&#34;&gt;4. Markdown 区块&lt;/h3&gt;
&lt;p&gt;Markdown 区块引用是在段落开头使用 &amp;gt; 符号 ，然后后面紧跟一个空格符号：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;&amp;gt; 区块引用
&amp;gt; Markdown笔记
&amp;gt; 做个记录方便查找
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;显示结果如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;区块引用
Markdown笔记
做个记录方便查找&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;另外区块是可以嵌套的，一个 &amp;gt; 符号是最外层，两个 &amp;gt; 符号是第一层嵌套，以此类推：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;&amp;gt; 最外层
&amp;gt; &amp;gt; 第一层嵌套
&amp;gt; &amp;gt; &amp;gt; 第二层嵌套
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;显示结果如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;最外层&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;第一层嵌套&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;第二层嵌套&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;_14&#34;&gt;区块中使用列表&lt;/h4&gt;
&lt;p&gt;区块中使用列表实例如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;&amp;gt; 区块中使用列表
&amp;gt; 1. 第一项
&amp;gt; 2. 第二项
&amp;gt; + 第一项
&amp;gt; + 第二项
&amp;gt; + 第三项
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;显示结果如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;区块中使用列表&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;第一项&lt;/li&gt;
&lt;li&gt;第二项&lt;/li&gt;
&lt;li&gt;第一项&lt;/li&gt;
&lt;li&gt;第二项&lt;/li&gt;
&lt;li&gt;第三项&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;_15&#34;&gt;列表中使用区块&lt;/h4&gt;
&lt;p&gt;如果要在列表项目内放进区块，那么就需要在 &amp;gt; 前添加四个空格的缩进。&lt;/p&gt;
&lt;p&gt;区块中使用列表实例如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;* 第一项
    &amp;gt; Markdown笔记
    &amp;gt; 做个记录方便查找
* 第二项
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;显示结果如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一项&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;Markdown笔记
做个记录方便查找
* 第二项&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;5-markdown&#34;&gt;5. Markdown 代码&lt;/h3&gt;
&lt;p&gt;如果是段落上的一个函数或片段的代码可以用反引号把它包起来（`），例如：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;`print()` 函数
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;显示结果如下：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;print()&lt;/code&gt; 函数&lt;/p&gt;
&lt;h4 id=&#34;_16&#34;&gt;代码区块&lt;/h4&gt;
&lt;p&gt;代码区块使用 4 个空格或者一个制表符（Tab 键）。&lt;/p&gt;
&lt;p&gt;实例如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;    ```
    print(&#39;这是Tab&#39;)

    print(&#39;这是四个空格&#39;)
    ```
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;显示结果如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;    print(&#39;这是Tab&#39;)

    print(&#39;这是四个空格&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你也可以用 ``` 包裹一段代码，并指定一种语言（也可以不指定）：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;    ```python
print(&#39;This is a test!&#39;)
    ```
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;显示结果如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code class=&#34;language-python&#34;&gt;print(&#39;This is a test!&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;6-markdown&#34;&gt;6. Markdown 链接&lt;/h3&gt;
&lt;p&gt;链接使用方法如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;[链接名称](链接地址)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;&amp;lt;链接地址&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例如：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;这是一个链接 [Markdown笔记](https://testpoo.github.io/)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;显示结果如下：&lt;/p&gt;
&lt;p&gt;这是一个链接 &lt;a href=&#34;https://testpoo.github.io/&#34;&gt;Markdown笔记&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;直接使用链接地址：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;&amp;lt;https://testpoo.github.io/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;显示结果如下：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://testpoo.github.io/&#34;&gt;https://testpoo.github.io/&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&#34;_17&#34;&gt;高级链接&lt;/h4&gt;
&lt;p&gt;我们可以通过变量来设置一个链接，变量赋值在文档末尾进行：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;这个链接用 1 作为网址变量 [Baidu][1]
这个链接用 testpoo 作为网址变量 [Testpoo][testpoo]
然后在文档的结尾为变量赋值（网址）

  [1]: http://www.baidu.com/
  [testpoo]: https://testpoo.github.io/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;显示结果如下：&lt;/p&gt;
&lt;p&gt;这个链接用 1 作为网址变量 &lt;a href=&#34;https://testpoo.github.io/themes/img/favicon.ico&#34;&gt;Baidu&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这个链接用 testpoo 作为网址变量 &lt;a href=&#34;https://testpoo.github.io/&#34;&gt;Testpoo&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;然后在文档的结尾为变量赋值（网址）&lt;/p&gt;
&lt;h3 id=&#34;7-markdown&#34;&gt;7. Markdown 图片&lt;/h3&gt;
&lt;p&gt;Markdown 图片语法格式如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;![alt 属性文本](图片地址)

![alt 属性文本](图片地址 &amp;quot;可选标题&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;开头一个感叹号 !&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;接着一个方括号，里面放上图片的替代文字&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上选择性的 &#39;title&#39; 属性的文字。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用实例：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;![TESTPOO 图标](https://testpoo.github.io/themes/img/favicon.ico)

![TESTPOO 图标](https://testpoo.github.io/themes/img/favicon.ico &amp;quot;TESTPOO&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;显示结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;TESTPOO 图标&#34; src=&#34;https://testpoo.github.io/themes/img/favicon.ico&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;TESTPOO 图标&#34; src=&#34;https://testpoo.github.io/themes/img/favicon.ico&#34; title=&#34;TESTPOO&#34; /&gt;&lt;/p&gt;
&lt;p&gt;当然，你也可以像网址那样对图片网址使用变量:&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;这个链接用 1 作为网址变量 [TESTPOO][1].
然后在文档的结尾为变量赋值（网址）

[1]: https://testpoo.github.io/themes/img/favicon.ico
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;显示结果如下：&lt;/p&gt;
&lt;p&gt;这个链接用 1 作为网址变量 TESTPOO. 然后在文档的结尾为变量赋值（网址）&lt;/p&gt;
&lt;p&gt;Markdown 还没有办法指定图片的高度与宽度，如果你需要的话，你可以使用普通的  标签。&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;&amp;lt;img src=&amp;quot;https://testpoo.github.io/themes/img/favicon.ico&amp;quot; width=&amp;quot;50%&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;显示结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://testpoo.github.io/themes/img/favicon.ico&#34; width=&#34;50%&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;8-markdown&#34;&gt;8. Markdown 表格&lt;/h3&gt;
&lt;p&gt;Markdown 制作表格使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行。&lt;/p&gt;
&lt;p&gt;语法格式如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;|  表头   | 表头  |
|  ----  | ----  |
| 单元格  | 单元格 |
| 单元格  | 单元格 |
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上代码显示结果如下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;表头&lt;/th&gt;
&lt;th&gt;表头&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;单元格&lt;/td&gt;
&lt;td&gt;单元格&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;单元格&lt;/td&gt;
&lt;td&gt;单元格&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;对齐方式&lt;/p&gt;
&lt;p&gt;我们可以设置表格的对齐方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;-: 设置内容和标题栏居右对齐。&lt;/li&gt;
&lt;li&gt;:- 设置内容和标题栏居左对齐。&lt;/li&gt;
&lt;li&gt;:-: 设置内容和标题栏居中对齐。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;实例如下：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;| 左对齐 | 右对齐 | 居中对齐 |
| :-----| ----: | :----: |
| 单元格 | 单元格 | 单元格 |
| 单元格 | 单元格 | 单元格 |
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上代码显示结果如下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align: left;&#34;&gt;左对齐&lt;/th&gt;
&lt;th style=&#34;text-align: right;&#34;&gt;右对齐&lt;/th&gt;
&lt;th style=&#34;text-align: center;&#34;&gt;居中对齐&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: left;&#34;&gt;单元格&lt;/td&gt;
&lt;td style=&#34;text-align: right;&#34;&gt;单元格&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;单元格&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align: left;&#34;&gt;单元格&lt;/td&gt;
&lt;td style=&#34;text-align: right;&#34;&gt;单元格&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;单元格&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;9-markdown&#34;&gt;9. Markdown 高级技巧&lt;/h3&gt;
&lt;p&gt;支持的 HTML 元素不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。&lt;/p&gt;
&lt;h4 id=&#34;_18&#34;&gt;转义&lt;/h4&gt;
&lt;p&gt;Markdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符，Markdown 使用反斜杠转义特殊字符：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;**文本加粗** 
\*\* 正常显示星号 \*\*
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出结果为：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;文本加粗&lt;/strong&gt; 
** 正常显示星号 **&lt;/p&gt;
&lt;p&gt;Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;\   反斜线
`   反引号
*   星号
_   下划线
{}  花括号
[]  方括号
()  小括号
#   井字号
+   加号
-   减号
.   英文句点
!   感叹号
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#34;footnote&#34;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:TESTPOO&#34;&gt;
&lt;p&gt;Markdown笔记 -- 做个记录方便查找！！！&amp;#160;&lt;a class=&#34;footnote-backref&#34; href=&#34;#fnref:TESTPOO&#34; title=&#34;Jump back to footnote 1 in the text&#34;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description>  
      <pubDate>2025-10-09 17:54:40</pubDate>  
      <link>https://testpoo.github.io/Markdown笔记.html</link>  
      <guid isPermaLink="true">https://testpoo.github.io/Markdown笔记.html</guid>
       
      <category>技术</category> 
      
    </item>
    
    <item> 
      <title>Linux下SVN服务器的搭建</title>  
      <description>&lt;div class=&#34;toc&#34;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#ubuntusvn&#34;&gt;Ubuntu下SVN服务器的配置及搭建&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#svn&#34;&gt;检查是否安装SVN&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#svnsvn&#34;&gt;配置svn并启动svn服务&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#svn_1&#34;&gt;检测svn服务是否正常启动&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#svnadminsvn&#34;&gt;使用svnadmin建立svn项目版本库&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#testdoc&#34;&gt;配置testdoc版本可的权限&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#svn_2&#34;&gt;为Svn版本库创建用户并授权访问指定项目版本库&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#svn_3&#34;&gt;重新启动svn服务进行验证&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h3 id=&#34;ubuntusvn&#34;&gt;Ubuntu下SVN服务器的配置及搭建&lt;/h3&gt;
&lt;p&gt;SVN是Subversion的简称，是一个开放源代码的版本控制系统，相较于RCS、CVS，它采用了分支管理系统，它的设计目标就是取代CVS。互联网上很多版本控制服务已从CVS迁移到Subversion。说得简单一点SVN就是用于多个人共同开发同一个项目，共用资源的目的。&lt;/p&gt;
&lt;h4 id=&#34;svn&#34;&gt;检查是否安装SVN&lt;/h4&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;dpkg --get-selections|grep &#39;subversion&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果安装了，会有如下提示&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;root@ubuntu:~$ dpkg --get-selections|grep &#39;subversion&#39;
subversion                                      install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果没有安装，使用以下命令安装&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;apt install subversion
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;svnsvn&#34;&gt;配置svn并启动svn服务&lt;/h4&gt;
&lt;p&gt;可以使用svnserve --help查看启动帮助&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;root@ubuntu:~# svnserve --help
usage: svnserve [-d | -i | -t | -X] [options]
Subversion repository server.
Type &#39;svnserve --version&#39; to see the program version.

Valid options:
  -d [--daemon]            : 后台模式
  -i [--inetd]             : inetd 模式
  -t [--tunnel]            : 隧道模式
  -X [--listen-once]       : 监听一次方式(调试用)
  -r [--root] ARG          : 服务的根目录
  -R [--read-only]         : 强制只读；覆盖版本库配置文件
  --config-file ARG        : 从文件 ARG 读取配置
  --listen-port ARG        : listen port. The default port is 3690.
                             [mode: daemon, listen-once]
  --listen-host ARG        : listen hostname or IP address
                             By default svnserve listens on all addresses.
                             [mode: daemon, listen-once]
  -6 [--prefer-ipv6]       : 在使用主机名称监听时，首选 IPv6
                             [默认首选 IPv4。不支持在守护进程模式中同时使用 IPv4
                             和 IPv6。如果需要，请使用 inetd 模式或隧道模式。]
  -c [--compression] ARG   : 用于网络传输的压缩级别
                             [0 .. 不压缩, 5 .. 默认,
                              9 .. 最大压缩]
  -M [--memory-cache-size] ARG : size of the extra in-memory cache in MB used to
                             minimize redundant operations.
                             Default is 16.
                             0 switches to dynamically sized caches.
                             [used for FSFS and FSX repositories only]
  --cache-txdeltas ARG     : enable or disable caching of deltas between older
                             revisions.
                             Default is yes.
                             [used for FSFS and FSX repositories only]
  --cache-fulltexts ARG    : enable or disable caching of file contents
                             Default is yes.
                             [used for FSFS and FSX repositories only]
  --cache-revprops ARG     : enable or disable caching of revision properties.
                             Consult the documentation before activating this.
                             Default is no.
                             [used for FSFS and FSX repositories only]
  --client-speed ARG       : Optimize network handling based on the assumption
                             that most clients are connected with a bitrate of
                             ARG Mbit/s.
                             Default is 0 (optimizations disabled).
  --block-read ARG         : Parse and cache all data found in block instead
                             of just the requested item.
                             Default is no.
                             [used for FSFS repositories in 1.9 format only]
  -T [--threads]           : 使用线程代替进程 [方式: daemon]
  --min-threads ARG        : Minimum number of server threads, even if idle.
                             Capped to max-threads; minimum value is 0.
                             Default is 1.
                             [used only with --threads]
  --max-threads ARG        : Maximum number of server threads, even if there
                             are more connections.  Minimum value is 1.
                             Default is 256.
                             [used only with --threads]
  --foreground             : 在前台运行(调试用)
                             [方式: daemon]
  --single-thread          : handle one connection at a time in the parent
                             process (useful for debugging)
  --log-file ARG           : svnserve 日志文件
  --pid-file ARG           : 写进程 PID 到文件 ARG
                             [方式: daemon, listen-once]
  --tunnel-user ARG        : 隧道用户名(默认是当前UID对应的用户名)
                             [方式: tunnel]
  -h [--help]              : 显示本帮助
  --virtual-host           : virtual host mode (look for repo in directory
                             of provided hostname)
  --version                : 显示程序版本信息
  -q [--quiet]             : 在标准错误输出不显示进度 (仅错误)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;指定svn的数据存储路径&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;mkdir -p /home/poo/svn/data
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;指定svn的配置文件信息路径&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;mkdir -p /home/poo/svn/passwd
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;启动svn服务&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;svnserve -d -r /home/poo/svn/data
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;svn_1&#34;&gt;检测svn服务是否正常启动&lt;/h4&gt;
&lt;p&gt;第一通过进程检测&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;root@ubuntu:~# ps -ef|grep svn
root        76     1  0 21:15 ?        00:00:00 svnserve -d -r /home/poo/svn/data/
root        78    52  0 21:15 tty1     00:00:00 grep --color=auto svn
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第二通过端口3690检测&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;netstat -lntup | grep 3690
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第三通过文件检测&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;lsof -i :3690
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;svnadminsvn&#34;&gt;使用svnadmin建立svn项目版本库&lt;/h4&gt;
&lt;p&gt;查看创建项目版本库命令&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;svnadmin --help
&lt;/code&gt;&lt;/pre&gt;

&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;root@ubuntu:~# svnadmin --help
general usage: svnadmin SUBCOMMAND REPOS_PATH  [ARGS &amp;amp; OPTIONS ...]
Subversion repository administration tool.
Type &#39;svnadmin help &amp;lt;subcommand&amp;gt;&#39; for help on a specific subcommand.
Type &#39;svnadmin --version&#39; to see the program version and FS modules.

Available subcommands:
   crashtest
   create
   delrevprop
   deltify
   dump
   freeze
   help (?, h)
   hotcopy
   info
   list-dblogs
   list-unused-dblogs
   load
   lock
   lslocks
   lstxns
   pack
   recover
   rmlocks
   rmtxns
   setlog
   setrevprop
   setuuid
   unlock
   upgrade
   verify
&lt;/code&gt;&lt;/pre&gt;

&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;svnadmin help create
&lt;/code&gt;&lt;/pre&gt;

&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;root@ubuntu:~# svnadmin help create
create: 用法: svnadmin create REPOS_PATH

在 REPOS_PATH 创建一个新的空版本库。

有效选项:
  --bdb-txn-nosync         : 在提交事务时禁用fsync [BDB]
  --bdb-log-keep           : 禁用自动删除日志文件 [BDB]
  --config-dir ARG         : 从目录 ARG 读取用户配置文件
  --fs-type ARG            : type of repository:
                             &#39;fsfs&#39; (default), &#39;bdb&#39; or &#39;fsx&#39;
                             CAUTION: FSX is for EXPERIMENTAL use only!
  --compatible-version ARG : use repository format compatible with Subversion
                             version ARG (&amp;quot;1.5.5&amp;quot;, &amp;quot;1.7&amp;quot;, etc.)
  --pre-1.4-compatible     : 已经淘汰; 参见 --compatible-version
  --pre-1.5-compatible     : 已经淘汰; 参见 --compatible-version
  --pre-1.6-compatible     : 已经淘汰; 参见 --compatible-version
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;创建testdoc版本库&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;root@ubuntu:~# svnadmin create /home/poo/svn/data/testdoc
root@ubuntu:~# ll /home/poo/svn/data/testdoc/
总用量 0
drwxr-xr-x 0 root root 512 12月  9 21:26 conf/
drwxr-sr-x 0 root root 512 12月  9 21:26 db/
-r--r--r-- 1 root root   2 12月  9 21:26 format
drwxr-xr-x 0 root root 512 12月  9 21:26 hooks/
drwxr-xr-x 0 root root 512 12月  9 21:26 locks/
-rw-r--r-- 1 root root 246 12月  9 21:26 README.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;testdoc&#34;&gt;配置testdoc版本可的权限&lt;/h4&gt;
&lt;p&gt;进入testdoc版本库配置目录,并备份配置文件&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;cd /home/poo/svn/data/testdoc/conf/
cp -p svnserve.conf svnserve.conf.default
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;进行详细配置&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;anon-access = none //禁止匿名访问
auth-access = write //认证后有读的权限
password-db = /home/poo/svn/passwd/passwd //指定密码文件
authz-db = /home/poo/svn/passwd/authz //指定权限认证文件
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;svnserve.conf文件general的一部分&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;[general]
### The anon-access and auth-access options control access to the
### repository for unauthenticated (a.k.a. anonymous) users and
### authenticated users, respectively.
### Valid values are &amp;quot;write&amp;quot;, &amp;quot;read&amp;quot;, and &amp;quot;none&amp;quot;.
### Setting the value to &amp;quot;none&amp;quot; prohibits both reading and writing;
### &amp;quot;read&amp;quot; allows read-only access, and &amp;quot;write&amp;quot; allows complete
### read/write access to the repository.
### The sample settings below are the defaults and specify that anonymous
### users have read-only access to the repository, while authenticated
### users have read and write access to the repository.
anon-access = none
auth-access = write
### The password-db option controls the location of the password
### database file.  Unless you specify a path starting with a /,
### the file&#39;s location is relative to the directory containing
### this configuration file.
### If SASL is enabled (see below), this file will NOT be used.
### Uncomment the line below to use the default password file.
password-db = /home/poo/svn/passwd/passwd
### The authz-db option controls the location of the authorization
### rules for path-based access control.  Unless you specify a path
### starting with a /, the file&#39;s location is relative to the
### directory containing this file.  The specified path may be a
### repository relative URL (^/) or an absolute file:// URL to a text
### file in a Subversion repository.  If you don&#39;t specify an authz-db,
### no path-based access control is done.
### Uncomment the line below to use the default authorization file.
authz-db = /home/poo/svn/passwdauthz
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;复制passwd和authz文件到passwd目录并修改权限&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;cp -p passwd authz /home/poo/svn/passwd/
cd /home/poo/svn/passwd/
chmod 700 authz passwd
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;svn_2&#34;&gt;为Svn版本库创建用户并授权访问指定项目版本库&lt;/h4&gt;
&lt;p&gt;编辑passwd文件配置用户和密码&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;vi passwd 
xiaowei = 123456
shenyi = 123456
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;passwd文件&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;### This file is an example password file for svnserve.
### Its format is similar to that of svnserve.conf. As shown in the
### example below it contains one section labelled [users].
### The name and password for each user follow, one account per line.

[users]
# harry = harryssecret
# sally = sallyssecret

# 等号前是用户名，后面是密码
xiaowei = 123456
shenyi = 123456

# 测试账号
test1 = 123456
test2 = 123456
test3 = 123456
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编辑authz文件配置读取权限&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;[&amp;lt;版本库&amp;gt;:/项目/目录]
@&amp;lt;用户组名&amp;gt; = &amp;lt;权限&amp;gt;
&amp;lt;用户名&amp;gt;  = &amp;lt;权限&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;authz文件&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;### This file is an example authorization file for svnserve.
### Its format is identical to that of mod_authz_svn authorization
### files.
### As shown below each section defines authorizations for the path and
### (optional) repository specified by the section name.
### The authorizations follow. An authorization line can refer to:
###  - a single user,
###  - a group of users defined in a special [groups] section,
###  - an alias defined in a special [aliases] section,
###  - all authenticated users, using the &#39;$authenticated&#39; token,
###  - only anonymous users, using the &#39;$anonymous&#39; token,
###  - anyone, using the &#39;*&#39; wildcard.
###
### A match can be inverted by prefixing the rule with &#39;~&#39;. Rules can
### grant read (&#39;r&#39;) access, read-write (&#39;rw&#39;) access, or no access
### (&#39;&#39;).

[aliases]
# joe = /C=XZ/ST=Dessert/L=Snake City/O=Snake Oil, Ltd./OU=Research Institute/CN=Joe Average

[groups]
# harry_and_sally = harry,sally
# harry_sally_and_joe = harry,sally,&amp;amp;joe
# 这里可以定义组，多个用户这间用逗号隔开
test = test1,test2,test3

# [/foo/bar]
# harry = rw
# &amp;amp;joe = r

[testdoc:/]
@test = rw
xiaowei = rw
shenyi = r
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;svn_3&#34;&gt;重新启动svn服务进行验证&lt;/h4&gt;
&lt;p&gt;杀死svn服务&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;pkill svnserve
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;启动svn&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;svnserve -d -r /home/poo/svn/data/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;备注：修改passwd和authz文件不需要重启svn服务，而修改svnserve.conf则需要&lt;/p&gt;
&lt;p&gt;最后安装客户端进行testdoc的配置是否正确&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;svn --username=xiaowei co svn://127.0.0.1/testdoc
&lt;/code&gt;&lt;/pre&gt;

&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;root@ubuntu:# svn --username=xiaowei co svn://127.0.0.1/testdoc
认证领域: &amp;lt;svn://127.0.0.1:3690&amp;gt; f36acfd9-8e0c-4973-bd35-44e75440e1c3
“xiaowei”的密码: ******


-----------------------------------------------------------------------
注意!  你的密码，对于认证域:

   &amp;lt;svn://127.0.0.1:3690&amp;gt; f36acfd9-8e0c-4973-bd35-44e75440e1c3

只能明文保存在磁盘上!  如果可能的话，请考虑配置你的系统，让 Subversion
可以保存加密后的密码。请参阅文档以获得详细信息。

你可以通过在“/root/.subversion/servers”中设置选项“store-plaintext-passwords”为“yes”或“no”，
来避免再次出现此警告。
-----------------------------------------------------------------------
保存未加密的密码(yes/no)? yes
取出版本 0。
&lt;/code&gt;&lt;/pre&gt;</description>  
      <pubDate>2025-10-09 17:54:40</pubDate>  
      <link>https://testpoo.github.io/Linux下SVN服务器的搭建.html</link>  
      <guid isPermaLink="true">https://testpoo.github.io/Linux下SVN服务器的搭建.html</guid>
       
      <category>技术</category> 
      
    </item>
    
    <item> 
      <title>mysql笔记</title>  
      <description>&lt;div class=&#34;toc&#34;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#_1&#34;&gt;创建用户&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#mysql&#34;&gt;MYSQL配置&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_2&#34;&gt;字段增加删除修改&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_3&#34;&gt;替换特定字段的值&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_4&#34;&gt;查找库中含有特定字段的表&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#auto_increment&#34;&gt;修改auto_increment&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#foreign_key_checks&#34;&gt;查询FOREIGN_KEY_CHECKS的值&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_5&#34;&gt;备份数据库&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#mysql_1&#34;&gt;MYSQL卡死了就这样搞&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#mysql_2&#34;&gt;Mysql复制表结构、表数据的方法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_6&#34;&gt;导出表结构和数据&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h3 id=&#34;_1&#34;&gt;创建用户&lt;/h3&gt;
&lt;p&gt;非本地登录&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;CREATE USER &#39;test&#39;@&#39;%&#39; IDENTIFIED BY &#39;test&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;本地登录&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;CREATE USER &#39;test&#39;@&#39;127.0.0.1&#39; IDENTIFIED BY &#39;test&#39;;
CREATE USER &#39;test&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;test&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;创建数据库&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;CREATE database testrcb default character set utf8 collate utf8_general_ci;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;给用户授权&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;grant select,delete,update,create,drop on testrcb.* to test@&amp;quot;%&amp;quot; identified by &amp;quot;test&amp;quot;; -- 增删改查
grant all privileges on testrcb.* to test@localhost identified by &#39;test&#39;; -- all
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改密码&lt;/p&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;UPDATE mysql.user SET PASSWORD=PASSWORD(&#39;test&#39;) WHERE User = &#39;test&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;mysql&#34;&gt;MYSQL配置&lt;/h3&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;[mysql]

# 设置mysql客户端默认字符集

default-character-set=utf8 

[mysqld]

#设置3306端口
port = 3306 

# 设置mysql的安装目录
basedir=C:\Program Files\MySQL\MySQL Server 5.6

# 设置mysql数据库的数据的存放目录
datadir=C:\Program Files\MySQL\MySQL Server 5.6\data

# 允许最大连接数
max_connections=200

# 服务端使用的字符集默认为8比特编码的latin1字符集
character-set-server=utf8

# 创建新表时将使用的默认存储引擎
default-storage-engine=INNODB
Access denied for user &#39;test&#39;@&#39;localhost&#39; (using password: YES)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;_2&#34;&gt;字段增加删除修改&lt;/h3&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;添加字段的语法：alter table tablename add (column datatype [default value][null/not null],….);
修改字段的语法：alter table tablename modify (column datatype [default value][null/not null],….);
删除字段的语法：alter table tablename drop (column);

mysql修改字段类型：
--能修改字段类型、类型长度、默认值、注释
--对某字段进行修改
ALTER  TABLE 表名 MODIFY COLUMN 字段名 新数据类型 新类型长度  新默认值  新注释; -- COLUMN可以省略
alter  table table1 modify  column column1  decimal(10,1) DEFAULT NULL COMMENT &#39;注释&#39;; -- 正常，能修改字段类型、类型长度、默认值、注释

mysql修改字段名：
ALTER  TABLE 表名 CHANGE 旧字段名 新字段名 新数据类型;     
alter  table table1 change column1 column1 varchar(100) DEFAULT 1.2 COMMENT &#39;注释&#39;; -- 正常，此时字段名称没有改变，能修改字段类型、类型长度、默认值、注释
alter  table table1 change column1 column2 decimal(10,1) DEFAULT NULL COMMENT &#39;注释&#39; -- 正常，能修改字段名、字段类型、类型长度、默认值、注释
alter  table table1 change column2 column1 decimal(10,1) DEFAULT NULL COMMENT &#39;注释&#39; -- 正常，能修改字段名、字段类型、类型长度、默认值、注释
alter  table table1 change column1 column2; -- 报错  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;_3&#34;&gt;替换特定字段的值&lt;/h3&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;update hoyi_zfb_activity_enroll set shop_name = replace(shop_name,&#39;Test&#39;,&#39;&#39;); 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;_4&#34;&gt;查找库中含有特定字段的表&lt;/h3&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;SELECT * FROM information_schema.columns WHERE column_name=&#39;shop_name&#39; AND table_schema = &#39;tyrcb14&#39;; 
SELECT * FROM information_schema.tables WHERE TABLE_NAME LIKE &#39;%shop%&#39; AND table_schema = &#39;tyrcb14&#39;; 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;auto_increment&#34;&gt;修改auto_increment&lt;/h3&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;alter table hoyi_etc_order auto_increment=38;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;foreign_key_checks&#34;&gt;查询FOREIGN_KEY_CHECKS的值&lt;/h3&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;SELECT @@FOREIGN_KEY_CHECKS; 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;_5&#34;&gt;备份数据库&lt;/h3&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;mysqldump -utest -p123 --databases test  &amp;gt; testdp.sql
mysqldump -utest -p123 --databases test  &amp;lt; testdp.sql
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;mysql_1&#34;&gt;MYSQL卡死了就这样搞&lt;/h3&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;SHOW PROCESSLIST;
SELECT * FROM information_schema.innodb_trx;
SELECT * FROM  performance_schema.events_statements_current WHERE sql_text LIKE &#39;%video%&#39;;
KILL XXX;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;mysql_2&#34;&gt;Mysql复制表结构、表数据的方法&lt;/h3&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;1、复制表结构及数据到新表（不包含主键、索引、分区等）

CREATE TABLE 新表 SELECT * FROM 旧表

或 CREATE TABLE 新表 AS SELECT * FROM 旧表

这种方法将旧表基本结构和数据复制到新表。

不过这种方法的一个最不好的地方就是新表中没有了旧表的主键、索引、Extra（auto_increment，字符集编码及排序）、注释、分区等属性 以及触发器、外键等。

2、只复制表结构到新表

CREATE TABLE 新表 SELECT * FROM 旧表 WHERE 1=2 （只是第一种方式去除掉数据）

CREATE TABLE 新表 LIKE 旧表

这种方式的复制可以复制旧表的主键、索引、Extra（auto_increment，字符集编码及排序）、注释、分区等属性。但是不包含触发器、外键等

3、复制旧表的数据到新表

INSERT INTO 新表 SELECT * FROM 旧表

INSERT INTO 新表(字段1,字段2,.......) SELECT 字段1,字段2,...... FROM 旧表

上面两条语句的前提是新表已经存在

4、复制表结构及数据到新表（包含主键、索引、分区等）

结合上述第2、3点，即：

先 CREATE TABLE 新表 LIKE 旧表

然后 INSERT INTO 新表 SELECT * FROM 旧表
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;_6&#34;&gt;导出表结构和数据&lt;/h3&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;1.导出结构不导出数据
mysqldump -d 数据库名 -uroot -p &amp;gt; xxx.sql

2.导出数据不导出结构
mysqldump -t 数据库名 -uroot -p &amp;gt; xxx.sql

3.导出数据和表结构
mysqldump 数据库名 -uroot -p &amp;gt; xxx.sql

4.导出特定表的结构
mysqldump -uroot -p -B数据库名 --table 表名 &amp;gt; xxx.sql
&lt;/code&gt;&lt;/pre&gt;</description>  
      <pubDate>2025-10-09 17:54:40</pubDate>  
      <link>https://testpoo.github.io/mysql笔记.html</link>  
      <guid isPermaLink="true">https://testpoo.github.io/mysql笔记.html</guid>
       
      <category>技术</category> 
      
    </item>
    
    <item> 
      <title>python标准异常</title>  
      <description>&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;异常名称&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;BaseException&lt;/td&gt;
&lt;td&gt;所有异常的基类&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SystemExit&lt;/td&gt;
&lt;td&gt;解释器请求退出&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;KeyboardInterrupt&lt;/td&gt;
&lt;td&gt;用户中断执行(通常是输入^C)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Exception&lt;/td&gt;
&lt;td&gt;常规错误的基类&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;StopIteration&lt;/td&gt;
&lt;td&gt;迭代器没有更多的值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;GeneratorExit&lt;/td&gt;
&lt;td&gt;生成器(generator)发生异常来通知退出&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;StandardError&lt;/td&gt;
&lt;td&gt;所有的内建标准异常的基类&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ArithmeticError&lt;/td&gt;
&lt;td&gt;所有数值计算错误的基类&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;FloatingPointError&lt;/td&gt;
&lt;td&gt;浮点计算错误&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;OverflowError&lt;/td&gt;
&lt;td&gt;数值运算超出最大限制&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ZeroDivisionError&lt;/td&gt;
&lt;td&gt;除(或取模)零 (所有数据类型)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;AssertionError&lt;/td&gt;
&lt;td&gt;断言语句失败&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;AttributeError&lt;/td&gt;
&lt;td&gt;对象没有这个属性&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;EOFError&lt;/td&gt;
&lt;td&gt;没有内建输入,到达EOF 标记&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;EnvironmentError&lt;/td&gt;
&lt;td&gt;操作系统错误的基类&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;IOError&lt;/td&gt;
&lt;td&gt;输入/输出操作失败&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;OSError&lt;/td&gt;
&lt;td&gt;操作系统错误&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;WindowsError&lt;/td&gt;
&lt;td&gt;系统调用失败&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ImportError&lt;/td&gt;
&lt;td&gt;导入模块/对象失败&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;LookupError&lt;/td&gt;
&lt;td&gt;无效数据查询的基类&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;IndexError&lt;/td&gt;
&lt;td&gt;序列中没有此索引(index)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;KeyError&lt;/td&gt;
&lt;td&gt;映射中没有这个键&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;MemoryError&lt;/td&gt;
&lt;td&gt;内存溢出错误(对于Python 解释器不是致命的)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;NameError&lt;/td&gt;
&lt;td&gt;未声明/初始化对象 (没有属性)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;UnboundLocalError&lt;/td&gt;
&lt;td&gt;访问未初始化的本地变量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ReferenceError&lt;/td&gt;
&lt;td&gt;弱引用(Weak reference)试图访问已经垃圾回收了的对象&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;RuntimeError&lt;/td&gt;
&lt;td&gt;一般的运行时错误&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;NotImplementedError&lt;/td&gt;
&lt;td&gt;尚未实现的方法&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SyntaxError&lt;/td&gt;
&lt;td&gt;Python 语法错误&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;IndentationError&lt;/td&gt;
&lt;td&gt;缩进错误&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TabError&lt;/td&gt;
&lt;td&gt;Tab 和空格混用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SystemError&lt;/td&gt;
&lt;td&gt;一般的解释器系统错误&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TypeError&lt;/td&gt;
&lt;td&gt;对类型无效的操作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ValueError&lt;/td&gt;
&lt;td&gt;传入无效的参数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;UnicodeError&lt;/td&gt;
&lt;td&gt;Unicode 相关的错误&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;UnicodeDecodeError&lt;/td&gt;
&lt;td&gt;Unicode 解码时的错误&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;UnicodeEncodeError&lt;/td&gt;
&lt;td&gt;Unicode 编码时错误&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;UnicodeTranslateError&lt;/td&gt;
&lt;td&gt;Unicode 转换时错误&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Warning&lt;/td&gt;
&lt;td&gt;警告的基类&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DeprecationWarning&lt;/td&gt;
&lt;td&gt;关于被弃用的特征的警告&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;FutureWarning&lt;/td&gt;
&lt;td&gt;关于构造将来语义会有改变的警告&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;OverflowWarning&lt;/td&gt;
&lt;td&gt;旧的关于自动提升为长整型(long)的警告&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;PendingDeprecationWarning&lt;/td&gt;
&lt;td&gt;关于特性将会被废弃的警告&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;RuntimeWarning&lt;/td&gt;
&lt;td&gt;可疑的运行时行为(runtime behavior)的警告&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SyntaxWarning&lt;/td&gt;
&lt;td&gt;可疑的语法的警告&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;UserWarning&lt;/td&gt;
&lt;td&gt;用户代码生成的警告&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</description>  
      <pubDate>2025-10-09 17:54:40</pubDate>  
      <link>https://testpoo.github.io/python标准异常.html</link>  
      <guid isPermaLink="true">https://testpoo.github.io/python标准异常.html</guid>
       
      <category>技术</category> 
      
    </item>
    
    <item> 
      <title>svn命令全解</title>  
      <description>&lt;div class=&#34;toc&#34;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#checkout&#34;&gt;将文件checkout到本地&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_1&#34;&gt;往版本库中添加新的文件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_2&#34;&gt;将改动的文件提交到版本库&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_3&#34;&gt;加锁/解锁&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_4&#34;&gt;更新到某个版本&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_5&#34;&gt;查看文件或者目录状态&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_6&#34;&gt;删除文件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_7&#34;&gt;查看日志&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_8&#34;&gt;查看文件详细信息&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_9&#34;&gt;比较差异&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_10&#34;&gt;将两个版本的文件的差异合并到当前文件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#svn&#34;&gt;SVN帮助&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_11&#34;&gt;查看版本库下的文件和列表&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_12&#34;&gt;创建纳入版本控制下的新目录&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_13&#34;&gt;恢复本地修改&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#url&#34;&gt;代码库URL变更&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_14&#34;&gt;解决冲突&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#url_1&#34;&gt;输出指定文件的URL内容&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h4 id=&#34;checkout&#34;&gt;将文件checkout到本地&lt;/h4&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;svn checkout path(path是服务器的目录)

例如 ：svn checkout svn://192.168.214.1/pro/domain
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;_1&#34;&gt;往版本库中添加新的文件&lt;/h4&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;svn add filename

例如：svn add test.cpp
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;_2&#34;&gt;将改动的文件提交到版本库&lt;/h4&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;svn commit -m &amp;quot;注释&amp;quot; [-N] [--no-unlock] PATH(如果选择了保持锁，就使用--no-unlock开关)

例如：svn commit -m &amp;quot;注释&amp;quot; test.cpp

简写：svn ci
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;_3&#34;&gt;加锁/解锁&lt;/h4&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;svn lock -m &amp;quot;注释&amp;quot; path

例如: svn lock -m &amp;quot;注释&amp;quot; test.cpp

svn unlock path
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;_4&#34;&gt;更新到某个版本&lt;/h4&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;svn update -r 版本号 path

svn update 更新当前目录以及子目录下的所有文件到最新版本

svn upate -r 200 test.cpp 将版本库中的test.cpp还原到版本200

简写 svn up
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;_5&#34;&gt;查看文件或者目录状态&lt;/h4&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;（1）svn status path （显示目录下的文件和子目录下的文件状态,正常状态不显示）

【?:不在svn控制中;M:内容被修改;C：发生冲突;A:预定义加入到版本库;K:被锁定】

（2）svn status -v path （显示文件和子目录状态）

注意：svn status、svn diff和svn revert这三条命令在没有网络情况下可以执行，因为svn在本地.svn中保留了本地版本原始拷贝。

简写： svn st
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;_6&#34;&gt;删除文件&lt;/h4&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;svn delete path -m &amp;quot;注释&amp;quot;

例如: svn delete svn://192.168.####1/pro/domain/test.cpp -m &amp;quot;delete test file&amp;quot;

或者直接svn delete test.php 然后再svn ci -m &#39;delete test file‘，推荐使用这种

简写： svn (del、remove、rm)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;_7&#34;&gt;查看日志&lt;/h4&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;svn log path
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;_8&#34;&gt;查看文件详细信息&lt;/h4&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;svn info path
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;_9&#34;&gt;比较差异&lt;/h4&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;svn diff path（将修改的文件与基础版本比较）

svn diff -r m:n （将修改的文件m版本和n版本比较）

简写 svn di
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;_10&#34;&gt;将两个版本的文件的差异合并到当前文件&lt;/h4&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;svn merge -r m:n path

 例如：svn merge -r 20:25 test.cpp（将版本20与25之间的差异合并到当前文件，但一般会发生冲突，需要处理一下）
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;svn&#34;&gt;SVN帮助&lt;/h4&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;svn help

以上为常用命令，下面为不常用命令
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;_11&#34;&gt;查看版本库下的文件和列表&lt;/h4&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;svn list path （显示path目录下的所属于版本的文件和目录）

简写: svn ls
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;_12&#34;&gt;创建纳入版本控制下的新目录&lt;/h4&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;svn mkdir: 创建纳入版本控制下的新目录。

用法: 1、mkdir PATH...
         2、mkdir URL...
创建版本控制的目录。
1、每一个以工作副本 PATH 指定的目录，都会创建在本地端，并且加入新增调度，以待下一次的提交。
2、每个以URL指定的目录，都会透过立即提交于仓库中创建。在这两个情况下，所有的中间目录都必须事先存在。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;_13&#34;&gt;恢复本地修改&lt;/h4&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;svn revert：恢复原始未改变的工作副本文件（恢复大部分的本地修改）revert用法：revert path

注意：本子命令不会存储网络，并且会解除冲突的情况。但它不会恢复被创建的目录
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;url&#34;&gt;代码库URL变更&lt;/h4&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;svn switch(sw): 更新工作副本到不同的URL。

用法 
1、switch URL [PATH]

2、switch --relocate FROM TO [PATH]

1、更新工作副本，映射到一个新的URL，会将服务上的文件与本地文件合并。这是将工作副本对应到同一创库的某个分支或者标记的方法。

2、改写工作副本URL元数据，以反映URL的变更，创库URL变动但工作副本仍旧对映同一创库的同一目录时使用该命令更新工作副本与创库的对应关系。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;_14&#34;&gt;解决冲突&lt;/h4&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;svn resolved：移除工作副本的目录或文件的“冲突”状态。

用法 resolved path

注意：本子命令不会依语法来解决冲突或是移除冲突标记；它只是移除冲突的相关文件，然后让path可以再次提交。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;url_1&#34;&gt;输出指定文件的URL内容&lt;/h4&gt;
&lt;pre class=&#34;codehilite&#34;&gt;&lt;code&gt;svn cat 目标[@版本] 如果指定了版本将从指定的版本开始查找。
&lt;/code&gt;&lt;/pre&gt;</description>  
      <pubDate>2025-10-09 17:54:40</pubDate>  
      <link>https://testpoo.github.io/svn命令全解.html</link>  
      <guid isPermaLink="true">https://testpoo.github.io/svn命令全解.html</guid>
       
      <category>技术</category> 
      
    </item>
    
  </channel> 
</rss>